//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Git\\NPortugol\\src\\grammar\\ASM.g 2014-02-07 15:44:03

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace NPortugol.Runtime.Asm
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class ASMParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "CALL", "CNT", "COMMENT", "DCL", "DEC", "DIV", "EMP", "ESC_SEQ", "EXIT", "EXPONENT", "FLOAT", "HEX_DIGIT", "HOST", "ID", "INC", "INT", "JE", "JG", "JGE", "JL", "JLE", "JMP", "JNE", "MOD", "MOV", "MUL", "NEG", "NEWLINE", "OCTAL_ESC", "POP", "POW", "PUSH", "RET", "SADD", "SCNT", "SDIV", "SMUL", "SSUB", "STRING", "SUB", "UNICODE_ESC", "WS", "','", "'.'", "':'"
	};
	public const int EOF=-1;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int ADD=4;
	public const int CALL=5;
	public const int CNT=6;
	public const int COMMENT=7;
	public const int DCL=8;
	public const int DEC=9;
	public const int DIV=10;
	public const int EMP=11;
	public const int ESC_SEQ=12;
	public const int EXIT=13;
	public const int EXPONENT=14;
	public const int FLOAT=15;
	public const int HEX_DIGIT=16;
	public const int HOST=17;
	public const int ID=18;
	public const int INC=19;
	public const int INT=20;
	public const int JE=21;
	public const int JG=22;
	public const int JGE=23;
	public const int JL=24;
	public const int JLE=25;
	public const int JMP=26;
	public const int JNE=27;
	public const int MOD=28;
	public const int MOV=29;
	public const int MUL=30;
	public const int NEG=31;
	public const int NEWLINE=32;
	public const int OCTAL_ESC=33;
	public const int POP=34;
	public const int POW=35;
	public const int PUSH=36;
	public const int RET=37;
	public const int SADD=38;
	public const int SCNT=39;
	public const int SDIV=40;
	public const int SMUL=41;
	public const int SSUB=42;
	public const int STRING=43;
	public const int SUB=44;
	public const int UNICODE_ESC=45;
	public const int WS=46;

	public ASMParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ASMParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ASMParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Git\\NPortugol\\src\\grammar\\ASM.g"; } }


		public bool DebugInfo { get; set; }
	        public Dictionary<string, int> _labels = new Dictionary<string, int>();
	        public List<Instruction> _instructions = new List<Instruction>();
	        public FunctionTable _functionTable = new FunctionTable();
	        public int _index = 0;


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:8: public script returns [IList<Instruction> value] : ( func ( instructions )+ )* ;
	[GrammarRule("script")]
	public IList<Instruction> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		IList<Instruction> value = default(IList<Instruction>);


		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(52, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:49: ( ( func ( instructions )+ )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:51: ( func ( instructions )+ )*
			{
			DebugLocation(52, 51);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:51: ( func ( instructions )+ )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==ID))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:52: func ( instructions )+
					{
					DebugLocation(52, 52);
					PushFollow(Follow._func_in_script377);
					func();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(52, 57);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:57: ( instructions )+
					int cnt1=0;
					try { DebugEnterSubRule(1);
					while (true)
					{
						int alt1=2;
						try { DebugEnterDecision(1, false);
						int LA1_0 = input.LA(1);

						if ((LA1_0==ID))
						{
							int LA1_2 = input.LA(2);

							if ((LA1_2==49))
							{
								int LA1_4 = input.LA(3);

								if ((LA1_4==NEWLINE))
								{
									int LA1_5 = input.LA(4);

									if ((EvaluatePredicate(synpred1_ASM_fragment)))
									{
										alt1 = 1;
									}


								}


							}


						}
						else if (((LA1_0>=ADD && LA1_0<=CNT)||(LA1_0>=DCL && LA1_0<=EMP)||LA1_0==EXIT||LA1_0==HOST||LA1_0==INC||(LA1_0>=JE && LA1_0<=NEG)||(LA1_0>=POP && LA1_0<=SSUB)||LA1_0==SUB||LA1_0==48))
						{
							alt1 = 1;
						}


						} finally { DebugExitDecision(1); }
						switch (alt1)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:57: instructions
							{
							DebugLocation(52, 57);
							PushFollow(Follow._instructions_in_script379);
							instructions();
							PopFollow();
							if (state.failed) return value;

							}
							break;

						default:
							if (cnt1 >= 1)
								goto loop1;

							if (state.backtracking>0) {state.failed=true; return value;}
							EarlyExitException eee1 = new EarlyExitException( 1, input );
							DebugRecognitionException(eee1);
							throw eee1;
						}
						cnt1++;
					}
					loop1:
						;

					} finally { DebugExitSubRule(1); }


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(52, 72);
			if (state.backtracking == 0)
			{


				            foreach (Instruction inst in _instructions)
				            {
				                if (inst.OpCode.ToString().StartsWith("J"))
				                {
				                   inst.Operands[0].Value = _labels[inst.Operands[0].Value.ToString()];
				                   inst.Operands[0].Type = OperandType.InstructionRef;
				                }
				            }
				            
				            value = _instructions;

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(64, 1);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return value;

	}
	// $ANTLR end "script"

	partial void EnterRule_func();
	partial void LeaveRule_func();

	// $ANTLR start "func"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:67:1: func : ID ':' NEWLINE ;
	[GrammarRule("func")]
	private void func()
	{
		EnterRule_func();
		EnterRule("func", 2);
		TraceIn("func", 2);
		IToken ID1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "func");
		DebugLocation(67, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:67:6: ( ID ':' NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:67:8: ID ':' NEWLINE
			{
			DebugLocation(67, 8);
			ID1=(IToken)Match(input,ID,Follow._ID_in_func392); if (state.failed) return;
			DebugLocation(67, 11);
			Match(input,49,Follow._49_in_func394); if (state.failed) return;
			DebugLocation(67, 15);
			Match(input,NEWLINE,Follow._NEWLINE_in_func396); if (state.failed) return;
			DebugLocation(67, 22);
			if (state.backtracking == 0)
			{

				            var _function = new Function((ID1!=null?ID1.Text:null), _index );
				            _functionTable.Add(_function.Name, _function);
				            
				            if (DebugInfo)
				            {
				              var _instruction = new Instruction(OpCode.EMP, _index);
				              _index++;
				              _instructions.Add(_instruction);            
				            }

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("func", 2);
			LeaveRule("func", 2);
			LeaveRule_func();
		}
		DebugLocation(77, 1);
		} finally { DebugExitRule(GrammarFileName, "func"); }
		return;

	}
	// $ANTLR end "func"

	partial void EnterRule_instructions();
	partial void LeaveRule_instructions();

	// $ANTLR start "instructions"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:79:1: instructions : ( func | inst_no_op | inst_one_op | inst_two_op | inst_n_op | label );
	[GrammarRule("instructions")]
	private void instructions()
	{
		EnterRule_instructions();
		EnterRule("instructions", 3);
		TraceIn("instructions", 3);
		try { DebugEnterRule(GrammarFileName, "instructions");
		DebugLocation(79, 14);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:80:2: ( func | inst_no_op | inst_one_op | inst_two_op | inst_n_op | label )
			int alt3=6;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt3 = 1;
				}
				break;
			case EMP:
			case EXIT:
			case RET:
			case SADD:
			case SCNT:
			case SDIV:
			case SMUL:
			case SSUB:
				{
				alt3 = 2;
				}
				break;
			case CALL:
			case DCL:
			case DEC:
			case INC:
			case JE:
			case JG:
			case JGE:
			case JL:
			case JLE:
			case JMP:
			case JNE:
			case NEG:
			case POP:
			case PUSH:
				{
				alt3 = 3;
				}
				break;
			case ADD:
			case CNT:
			case DIV:
			case MOD:
			case MOV:
			case MUL:
			case POW:
			case SUB:
				{
				alt3 = 4;
				}
				break;
			case HOST:
				{
				alt3 = 5;
				}
				break;
			case 48:
				{
				alt3 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:80:4: func
				{
				DebugLocation(80, 4);
				PushFollow(Follow._func_in_instructions407);
				func();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:81:10: inst_no_op
				{
				DebugLocation(81, 10);
				PushFollow(Follow._inst_no_op_in_instructions418);
				inst_no_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:82:10: inst_one_op
				{
				DebugLocation(82, 10);
				PushFollow(Follow._inst_one_op_in_instructions429);
				inst_one_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:83:10: inst_two_op
				{
				DebugLocation(83, 10);
				PushFollow(Follow._inst_two_op_in_instructions440);
				inst_two_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:84:10: inst_n_op
				{
				DebugLocation(84, 10);
				PushFollow(Follow._inst_n_op_in_instructions451);
				inst_n_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:85:10: label
				{
				DebugLocation(85, 10);
				PushFollow(Follow._label_in_instructions462);
				label();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("instructions", 3);
			LeaveRule("instructions", 3);
			LeaveRule_instructions();
		}
		DebugLocation(85, 14);
		} finally { DebugExitRule(GrammarFileName, "instructions"); }
		return;

	}
	// $ANTLR end "instructions"

	partial void EnterRule_label();
	partial void LeaveRule_label();

	// $ANTLR start "label"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:87:1: label : '.' ID NEWLINE ;
	[GrammarRule("label")]
	private void label()
	{
		EnterRule_label();
		EnterRule("label", 4);
		TraceIn("label", 4);
		IToken ID2 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "label");
		DebugLocation(87, 2);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:87:7: ( '.' ID NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:87:9: '.' ID NEWLINE
			{
			DebugLocation(87, 9);
			Match(input,48,Follow._48_in_label471); if (state.failed) return;
			DebugLocation(87, 13);
			ID2=(IToken)Match(input,ID,Follow._ID_in_label473); if (state.failed) return;
			DebugLocation(87, 16);
			Match(input,NEWLINE,Follow._NEWLINE_in_label475); if (state.failed) return;
			DebugLocation(87, 24);
			if (state.backtracking == 0)
			{
				 
					_labels.Add((ID2!=null?ID2.Text:null), _index);
					if (DebugInfo)
				        {
				            var _instruction = new Instruction(OpCode.EMP, _index);
				            _index++;
				            _instructions.Add(_instruction);	
				        }

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("label", 4);
			LeaveRule("label", 4);
			LeaveRule_label();
		}
		DebugLocation(95, 2);
		} finally { DebugExitRule(GrammarFileName, "label"); }
		return;

	}
	// $ANTLR end "label"

	partial void EnterRule_inst_no_op();
	partial void LeaveRule_inst_no_op();

	// $ANTLR start "inst_no_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:97:1: inst_no_op : e= opcode_no_op ( NEWLINE )* ;
	[GrammarRule("inst_no_op")]
	private void inst_no_op()
	{
		EnterRule_inst_no_op();
		EnterRule("inst_no_op", 5);
		TraceIn("inst_no_op", 5);
		OpCode e = default(OpCode);

		try { DebugEnterRule(GrammarFileName, "inst_no_op");
		DebugLocation(97, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:97:12: (e= opcode_no_op ( NEWLINE )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:97:14: e= opcode_no_op ( NEWLINE )*
			{
			DebugLocation(97, 15);
			PushFollow(Follow._opcode_no_op_in_inst_no_op488);
			e=opcode_no_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(97, 29);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:97:29: ( NEWLINE )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==NEWLINE))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:97:29: NEWLINE
					{
					DebugLocation(97, 29);
					Match(input,NEWLINE,Follow._NEWLINE_in_inst_no_op490); if (state.failed) return;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(97, 37);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new Operand[0]);
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_no_op", 5);
			LeaveRule("inst_no_op", 5);
			LeaveRule_inst_no_op();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_no_op"); }
		return;

	}
	// $ANTLR end "inst_no_op"

	partial void EnterRule_inst_one_op();
	partial void LeaveRule_inst_one_op();

	// $ANTLR start "inst_one_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:103:1: inst_one_op : e= opcode_one_op o= operand NEWLINE ;
	[GrammarRule("inst_one_op")]
	private void inst_one_op()
	{
		EnterRule_inst_one_op();
		EnterRule("inst_one_op", 6);
		TraceIn("inst_one_op", 6);
		OpCode e = default(OpCode);
		Operand o = default(Operand);

		try { DebugEnterRule(GrammarFileName, "inst_one_op");
		DebugLocation(103, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:103:13: (e= opcode_one_op o= operand NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:103:15: e= opcode_one_op o= operand NEWLINE
			{
			DebugLocation(103, 16);
			PushFollow(Follow._opcode_one_op_in_inst_one_op502);
			e=opcode_one_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(103, 32);
			PushFollow(Follow._operand_in_inst_one_op506);
			o=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(103, 41);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_one_op508); if (state.failed) return;
			DebugLocation(103, 48);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new []{o});
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_one_op", 6);
			LeaveRule("inst_one_op", 6);
			LeaveRule_inst_one_op();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_one_op"); }
		return;

	}
	// $ANTLR end "inst_one_op"

	partial void EnterRule_inst_two_op();
	partial void LeaveRule_inst_two_op();

	// $ANTLR start "inst_two_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:109:1: inst_two_op : e= opcode_two_op o= operand ',' p= operand NEWLINE ;
	[GrammarRule("inst_two_op")]
	private void inst_two_op()
	{
		EnterRule_inst_two_op();
		EnterRule("inst_two_op", 7);
		TraceIn("inst_two_op", 7);
		OpCode e = default(OpCode);
		Operand o = default(Operand);
		Operand p = default(Operand);

		try { DebugEnterRule(GrammarFileName, "inst_two_op");
		DebugLocation(109, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:109:13: (e= opcode_two_op o= operand ',' p= operand NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:109:15: e= opcode_two_op o= operand ',' p= operand NEWLINE
			{
			DebugLocation(109, 16);
			PushFollow(Follow._opcode_two_op_in_inst_two_op519);
			e=opcode_two_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(109, 32);
			PushFollow(Follow._operand_in_inst_two_op523);
			o=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(109, 41);
			Match(input,47,Follow._47_in_inst_two_op525); if (state.failed) return;
			DebugLocation(109, 46);
			PushFollow(Follow._operand_in_inst_two_op529);
			p=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(109, 55);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_two_op531); if (state.failed) return;
			DebugLocation(109, 62);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new []{o, p});
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_two_op", 7);
			LeaveRule("inst_two_op", 7);
			LeaveRule_inst_two_op();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_two_op"); }
		return;

	}
	// $ANTLR end "inst_two_op"

	partial void EnterRule_inst_n_op();
	partial void LeaveRule_inst_n_op();

	// $ANTLR start "inst_n_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:115:1: inst_n_op : e= opcode_n_op o+= ID ( ',' o+= ID )* NEWLINE ;
	[GrammarRule("inst_n_op")]
	private void inst_n_op()
	{
		EnterRule_inst_n_op();
		EnterRule("inst_n_op", 8);
		TraceIn("inst_n_op", 8);
		IToken o = default(IToken);
		List<IToken> list_o = null;
		OpCode e = default(OpCode);

		try { DebugEnterRule(GrammarFileName, "inst_n_op");
		DebugLocation(115, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:115:11: (e= opcode_n_op o+= ID ( ',' o+= ID )* NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:115:13: e= opcode_n_op o+= ID ( ',' o+= ID )* NEWLINE
			{
			DebugLocation(115, 14);
			PushFollow(Follow._opcode_n_op_in_inst_n_op542);
			e=opcode_n_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(115, 28);
			o=(IToken)Match(input,ID,Follow._ID_in_inst_n_op546); if (state.failed) return;
			if (list_o==null) list_o=new List<IToken>();
			list_o.Add(o);

			DebugLocation(115, 33);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:115:33: ( ',' o+= ID )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==47))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:115:34: ',' o+= ID
					{
					DebugLocation(115, 34);
					Match(input,47,Follow._47_in_inst_n_op549); if (state.failed) return;
					DebugLocation(115, 39);
					o=(IToken)Match(input,ID,Follow._ID_in_inst_n_op553); if (state.failed) return;
					if (list_o==null) list_o=new List<IToken>();
					list_o.Add(o);


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(115, 46);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_n_op557); if (state.failed) return;
			DebugLocation(115, 53);
			if (state.backtracking == 0)
			{


					    var plist = new List<Operand>();
								            
				            foreach(var item in list_o)
				            {
				            	plist.Add(new Operand(OperandType.HostObjectRef, item.Text));
				            }
				            
					    var _instruction = new Instruction(e, _index, plist.ToArray());
				            _index++;
				            _instructions.Add(_instruction);                          

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_n_op", 8);
			LeaveRule("inst_n_op", 8);
			LeaveRule_inst_n_op();
		}
		DebugLocation(127, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_n_op"); }
		return;

	}
	// $ANTLR end "inst_n_op"

	partial void EnterRule_opcode_two_op();
	partial void LeaveRule_opcode_two_op();

	// $ANTLR start "opcode_two_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:129:1: opcode_two_op returns [OpCode value] : ( MOV | ADD | SUB | MUL | DIV | MOD | POW | CNT );
	[GrammarRule("opcode_two_op")]
	private OpCode opcode_two_op()
	{
		EnterRule_opcode_two_op();
		EnterRule("opcode_two_op", 9);
		TraceIn("opcode_two_op", 9);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_two_op");
		DebugLocation(129, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:130:2: ( MOV | ADD | SUB | MUL | DIV | MOD | POW | CNT )
			int alt6=8;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case MOV:
				{
				alt6 = 1;
				}
				break;
			case ADD:
				{
				alt6 = 2;
				}
				break;
			case SUB:
				{
				alt6 = 3;
				}
				break;
			case MUL:
				{
				alt6 = 4;
				}
				break;
			case DIV:
				{
				alt6 = 5;
				}
				break;
			case MOD:
				{
				alt6 = 6;
				}
				break;
			case POW:
				{
				alt6 = 7;
				}
				break;
			case CNT:
				{
				alt6 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:130:4: MOV
				{
				DebugLocation(130, 4);
				Match(input,MOV,Follow._MOV_in_opcode_two_op572); if (state.failed) return value;
				DebugLocation(130, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MOV;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:131:4: ADD
				{
				DebugLocation(131, 4);
				Match(input,ADD,Follow._ADD_in_opcode_two_op579); if (state.failed) return value;
				DebugLocation(131, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.ADD;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:132:4: SUB
				{
				DebugLocation(132, 4);
				Match(input,SUB,Follow._SUB_in_opcode_two_op586); if (state.failed) return value;
				DebugLocation(132, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.SUB;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:133:4: MUL
				{
				DebugLocation(133, 4);
				Match(input,MUL,Follow._MUL_in_opcode_two_op593); if (state.failed) return value;
				DebugLocation(133, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MUL;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:134:4: DIV
				{
				DebugLocation(134, 4);
				Match(input,DIV,Follow._DIV_in_opcode_two_op600); if (state.failed) return value;
				DebugLocation(134, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DIV;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:135:4: MOD
				{
				DebugLocation(135, 4);
				Match(input,MOD,Follow._MOD_in_opcode_two_op607); if (state.failed) return value;
				DebugLocation(135, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MOD;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:136:4: POW
				{
				DebugLocation(136, 4);
				Match(input,POW,Follow._POW_in_opcode_two_op614); if (state.failed) return value;
				DebugLocation(136, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.POW;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:137:4: CNT
				{
				DebugLocation(137, 4);
				Match(input,CNT,Follow._CNT_in_opcode_two_op621); if (state.failed) return value;
				DebugLocation(137, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.CNT;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_two_op", 9);
			LeaveRule("opcode_two_op", 9);
			LeaveRule_opcode_two_op();
		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_two_op"); }
		return value;

	}
	// $ANTLR end "opcode_two_op"

	partial void EnterRule_opcode_one_op();
	partial void LeaveRule_opcode_one_op();

	// $ANTLR start "opcode_one_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:140:1: opcode_one_op returns [OpCode value] : ( DCL | NEG | INC | DEC | JMP | PUSH | POP | JE | JNE | JG | JL | JGE | JLE | CALL );
	[GrammarRule("opcode_one_op")]
	private OpCode opcode_one_op()
	{
		EnterRule_opcode_one_op();
		EnterRule("opcode_one_op", 10);
		TraceIn("opcode_one_op", 10);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_one_op");
		DebugLocation(140, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:141:2: ( DCL | NEG | INC | DEC | JMP | PUSH | POP | JE | JNE | JG | JL | JGE | JLE | CALL )
			int alt7=14;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case DCL:
				{
				alt7 = 1;
				}
				break;
			case NEG:
				{
				alt7 = 2;
				}
				break;
			case INC:
				{
				alt7 = 3;
				}
				break;
			case DEC:
				{
				alt7 = 4;
				}
				break;
			case JMP:
				{
				alt7 = 5;
				}
				break;
			case PUSH:
				{
				alt7 = 6;
				}
				break;
			case POP:
				{
				alt7 = 7;
				}
				break;
			case JE:
				{
				alt7 = 8;
				}
				break;
			case JNE:
				{
				alt7 = 9;
				}
				break;
			case JG:
				{
				alt7 = 10;
				}
				break;
			case JL:
				{
				alt7 = 11;
				}
				break;
			case JGE:
				{
				alt7 = 12;
				}
				break;
			case JLE:
				{
				alt7 = 13;
				}
				break;
			case CALL:
				{
				alt7 = 14;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:141:4: DCL
				{
				DebugLocation(141, 4);
				Match(input,DCL,Follow._DCL_in_opcode_one_op641); if (state.failed) return value;
				DebugLocation(141, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DCL;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:142:4: NEG
				{
				DebugLocation(142, 4);
				Match(input,NEG,Follow._NEG_in_opcode_one_op648); if (state.failed) return value;
				DebugLocation(142, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.NEG;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:143:4: INC
				{
				DebugLocation(143, 4);
				Match(input,INC,Follow._INC_in_opcode_one_op655); if (state.failed) return value;
				DebugLocation(143, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.INC;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:144:4: DEC
				{
				DebugLocation(144, 4);
				Match(input,DEC,Follow._DEC_in_opcode_one_op662); if (state.failed) return value;
				DebugLocation(144, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DEC;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:145:4: JMP
				{
				DebugLocation(145, 4);
				Match(input,JMP,Follow._JMP_in_opcode_one_op669); if (state.failed) return value;
				DebugLocation(145, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JMP;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:146:4: PUSH
				{
				DebugLocation(146, 4);
				Match(input,PUSH,Follow._PUSH_in_opcode_one_op676); if (state.failed) return value;
				DebugLocation(146, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.PUSH;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:147:4: POP
				{
				DebugLocation(147, 4);
				Match(input,POP,Follow._POP_in_opcode_one_op683); if (state.failed) return value;
				DebugLocation(147, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.POP;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:148:4: JE
				{
				DebugLocation(148, 4);
				Match(input,JE,Follow._JE_in_opcode_one_op690); if (state.failed) return value;
				DebugLocation(148, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JE;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:149:4: JNE
				{
				DebugLocation(149, 4);
				Match(input,JNE,Follow._JNE_in_opcode_one_op697); if (state.failed) return value;
				DebugLocation(149, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JNE;
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:150:4: JG
				{
				DebugLocation(150, 4);
				Match(input,JG,Follow._JG_in_opcode_one_op704); if (state.failed) return value;
				DebugLocation(150, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JG;
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:151:4: JL
				{
				DebugLocation(151, 4);
				Match(input,JL,Follow._JL_in_opcode_one_op711); if (state.failed) return value;
				DebugLocation(151, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JL;
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:152:4: JGE
				{
				DebugLocation(152, 4);
				Match(input,JGE,Follow._JGE_in_opcode_one_op718); if (state.failed) return value;
				DebugLocation(152, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JGE;
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:153:4: JLE
				{
				DebugLocation(153, 4);
				Match(input,JLE,Follow._JLE_in_opcode_one_op725); if (state.failed) return value;
				DebugLocation(153, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JLE;
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:154:4: CALL
				{
				DebugLocation(154, 4);
				Match(input,CALL,Follow._CALL_in_opcode_one_op733); if (state.failed) return value;
				DebugLocation(154, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.CALL;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_one_op", 10);
			LeaveRule("opcode_one_op", 10);
			LeaveRule_opcode_one_op();
		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_one_op"); }
		return value;

	}
	// $ANTLR end "opcode_one_op"

	partial void EnterRule_opcode_n_op();
	partial void LeaveRule_opcode_n_op();

	// $ANTLR start "opcode_n_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:157:1: opcode_n_op returns [OpCode value] : HOST ;
	[GrammarRule("opcode_n_op")]
	private OpCode opcode_n_op()
	{
		EnterRule_opcode_n_op();
		EnterRule("opcode_n_op", 11);
		TraceIn("opcode_n_op", 11);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_n_op");
		DebugLocation(157, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:158:2: ( HOST )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:158:4: HOST
			{
			DebugLocation(158, 4);
			Match(input,HOST,Follow._HOST_in_opcode_n_op752); if (state.failed) return value;
			DebugLocation(158, 9);
			if (state.backtracking == 0)
			{
				value = OpCode.HOST;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_n_op", 11);
			LeaveRule("opcode_n_op", 11);
			LeaveRule_opcode_n_op();
		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_n_op"); }
		return value;

	}
	// $ANTLR end "opcode_n_op"

	partial void EnterRule_opcode_no_op();
	partial void LeaveRule_opcode_no_op();

	// $ANTLR start "opcode_no_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:161:1: opcode_no_op returns [OpCode value] : ( EXIT | RET | SADD | SSUB | SMUL | SDIV | SCNT | EMP );
	[GrammarRule("opcode_no_op")]
	private OpCode opcode_no_op()
	{
		EnterRule_opcode_no_op();
		EnterRule("opcode_no_op", 12);
		TraceIn("opcode_no_op", 12);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_no_op");
		DebugLocation(161, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:162:2: ( EXIT | RET | SADD | SSUB | SMUL | SDIV | SCNT | EMP )
			int alt8=8;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case EXIT:
				{
				alt8 = 1;
				}
				break;
			case RET:
				{
				alt8 = 2;
				}
				break;
			case SADD:
				{
				alt8 = 3;
				}
				break;
			case SSUB:
				{
				alt8 = 4;
				}
				break;
			case SMUL:
				{
				alt8 = 5;
				}
				break;
			case SDIV:
				{
				alt8 = 6;
				}
				break;
			case SCNT:
				{
				alt8 = 7;
				}
				break;
			case EMP:
				{
				alt8 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:162:4: EXIT
				{
				DebugLocation(162, 4);
				Match(input,EXIT,Follow._EXIT_in_opcode_no_op771); if (state.failed) return value;
				DebugLocation(162, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.EXIT;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:163:4: RET
				{
				DebugLocation(163, 4);
				Match(input,RET,Follow._RET_in_opcode_no_op778); if (state.failed) return value;
				DebugLocation(163, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.RET;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:164:4: SADD
				{
				DebugLocation(164, 4);
				Match(input,SADD,Follow._SADD_in_opcode_no_op785); if (state.failed) return value;
				DebugLocation(164, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SADD;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:165:4: SSUB
				{
				DebugLocation(165, 4);
				Match(input,SSUB,Follow._SSUB_in_opcode_no_op792); if (state.failed) return value;
				DebugLocation(165, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SSUB;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:166:4: SMUL
				{
				DebugLocation(166, 4);
				Match(input,SMUL,Follow._SMUL_in_opcode_no_op799); if (state.failed) return value;
				DebugLocation(166, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SMUL;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:167:4: SDIV
				{
				DebugLocation(167, 4);
				Match(input,SDIV,Follow._SDIV_in_opcode_no_op806); if (state.failed) return value;
				DebugLocation(167, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SDIV;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:168:4: SCNT
				{
				DebugLocation(168, 4);
				Match(input,SCNT,Follow._SCNT_in_opcode_no_op816); if (state.failed) return value;
				DebugLocation(168, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SCNT;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:169:4: EMP
				{
				DebugLocation(169, 4);
				Match(input,EMP,Follow._EMP_in_opcode_no_op824); if (state.failed) return value;
				DebugLocation(169, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.EMP;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_no_op", 12);
			LeaveRule("opcode_no_op", 12);
			LeaveRule_opcode_no_op();
		}
		DebugLocation(170, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_no_op"); }
		return value;

	}
	// $ANTLR end "opcode_no_op"

	partial void EnterRule_operand();
	partial void LeaveRule_operand();

	// $ANTLR start "operand"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:172:1: operand returns [Operand value] : ( ID ( ':' i= index )? | INT | FLOAT | STRING );
	[GrammarRule("operand")]
	private Operand operand()
	{
		EnterRule_operand();
		EnterRule("operand", 13);
		TraceIn("operand", 13);
		Operand value = default(Operand);


		IToken ID3 = default(IToken);
		IToken INT4 = default(IToken);
		IToken FLOAT5 = default(IToken);
		IToken STRING6 = default(IToken);
		object i = default(object);

		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(172, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:173:9: ( ID ( ':' i= index )? | INT | FLOAT | STRING )
			int alt10=4;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt10 = 1;
				}
				break;
			case INT:
				{
				alt10 = 2;
				}
				break;
			case FLOAT:
				{
				alt10 = 3;
				}
				break;
			case STRING:
				{
				alt10 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:173:11: ID ( ':' i= index )?
				{
				DebugLocation(173, 11);
				ID3=(IToken)Match(input,ID,Follow._ID_in_operand852); if (state.failed) return value;
				DebugLocation(173, 14);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:173:14: ( ':' i= index )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==49))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:173:15: ':' i= index
					{
					DebugLocation(173, 15);
					Match(input,49,Follow._49_in_operand855); if (state.failed) return value;
					DebugLocation(173, 20);
					PushFollow(Follow._index_in_operand859);
					i=index();
					PopFollow();
					if (state.failed) return value;

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(173, 29);
				if (state.backtracking == 0)
				{

					        value = i==null? new Operand(OperandType.Variable, (ID3!=null?ID3.Text:null)): new Operand(OperandType.Variable, (ID3!=null?ID3.Text:null), i);
					        
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:176:4: INT
				{
				DebugLocation(176, 4);
				INT4=(IToken)Match(input,INT,Follow._INT_in_operand868); if (state.failed) return value;
				DebugLocation(176, 8);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, int.Parse((INT4!=null?INT4.Text:null)));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:177:4: FLOAT
				{
				DebugLocation(177, 4);
				FLOAT5=(IToken)Match(input,FLOAT,Follow._FLOAT_in_operand875); if (state.failed) return value;
				DebugLocation(177, 10);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, float.Parse((FLOAT5!=null?FLOAT5.Text:null)));
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:178:4: STRING
				{
				DebugLocation(178, 4);
				STRING6=(IToken)Match(input,STRING,Follow._STRING_in_operand882); if (state.failed) return value;
				DebugLocation(178, 11);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, (STRING6!=null?STRING6.Text:null).Substring(1, STRING6.Text.Length-2));
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("operand", 13);
			LeaveRule("operand", 13);
			LeaveRule_operand();
		}
		DebugLocation(179, 1);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		return value;

	}
	// $ANTLR end "operand"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:181:1: index returns [object value] : ( INT | ID );
	[GrammarRule("index")]
	private object index()
	{
		EnterRule_index();
		EnterRule("index", 14);
		TraceIn("index", 14);
		object value = default(object);


		IToken INT7 = default(IToken);
		IToken ID8 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(181, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:182:2: ( INT | ID )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==INT))
			{
				alt11 = 1;
			}
			else if ((LA11_0==ID))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:182:4: INT
				{
				DebugLocation(182, 4);
				INT7=(IToken)Match(input,INT,Follow._INT_in_index899); if (state.failed) return value;
				DebugLocation(182, 8);
				if (state.backtracking == 0)
				{
					value = int.Parse((INT7!=null?INT7.Text:null));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:183:4: ID
				{
				DebugLocation(183, 4);
				ID8=(IToken)Match(input,ID,Follow._ID_in_index906); if (state.failed) return value;
				DebugLocation(183, 8);
				if (state.backtracking == 0)
				{
					value = (ID8!=null?ID8.Text:null);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("index", 14);
			LeaveRule("index", 14);
			LeaveRule_index();
		}
		DebugLocation(184, 1);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return value;

	}
	// $ANTLR end "index"

	partial void EnterRule_synpred1_ASM_fragment();
	partial void LeaveRule_synpred1_ASM_fragment();

	// $ANTLR start synpred1_ASM
	public void synpred1_ASM_fragment()
	{
		EnterRule_synpred1_ASM_fragment();
		EnterRule("synpred1_ASM_fragment", 15);
		TraceIn("synpred1_ASM_fragment", 15);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:57: ( instructions )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:52:57: instructions
			{
			DebugLocation(52, 57);
			PushFollow(Follow._instructions_in_synpred1_ASM379);
			instructions();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_ASM_fragment", 15);
			LeaveRule("synpred1_ASM_fragment", 15);
			LeaveRule_synpred1_ASM_fragment();
		}
	}
	// $ANTLR end synpred1_ASM
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _func_in_script377 = new BitSet(new ulong[]{0x117FCFFEE2F70UL});
		public static readonly BitSet _instructions_in_script379 = new BitSet(new ulong[]{0x117FCFFEE2F72UL});
		public static readonly BitSet _ID_in_func392 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_func394 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _NEWLINE_in_func396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_in_instructions407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_no_op_in_instructions418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_one_op_in_instructions429 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_two_op_in_instructions440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_n_op_in_instructions451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _label_in_instructions462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_label471 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_label473 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _NEWLINE_in_label475 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_no_op_in_inst_no_op488 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _NEWLINE_in_inst_no_op490 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _opcode_one_op_in_inst_one_op502 = new BitSet(new ulong[]{0x80000148000UL});
		public static readonly BitSet _operand_in_inst_one_op506 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _NEWLINE_in_inst_one_op508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_two_op_in_inst_two_op519 = new BitSet(new ulong[]{0x80000148000UL});
		public static readonly BitSet _operand_in_inst_two_op523 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _47_in_inst_two_op525 = new BitSet(new ulong[]{0x80000148000UL});
		public static readonly BitSet _operand_in_inst_two_op529 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _NEWLINE_in_inst_two_op531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_n_op_in_inst_n_op542 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_inst_n_op546 = new BitSet(new ulong[]{0x800100000000UL});
		public static readonly BitSet _47_in_inst_n_op549 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_inst_n_op553 = new BitSet(new ulong[]{0x800100000000UL});
		public static readonly BitSet _NEWLINE_in_inst_n_op557 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MOV_in_opcode_two_op572 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_opcode_two_op579 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_opcode_two_op586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MUL_in_opcode_two_op593 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_opcode_two_op600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MOD_in_opcode_two_op607 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POW_in_opcode_two_op614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CNT_in_opcode_two_op621 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DCL_in_opcode_one_op641 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_opcode_one_op648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_opcode_one_op655 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_opcode_one_op662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JMP_in_opcode_one_op669 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PUSH_in_opcode_one_op676 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POP_in_opcode_one_op683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JE_in_opcode_one_op690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JNE_in_opcode_one_op697 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JG_in_opcode_one_op704 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JL_in_opcode_one_op711 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JGE_in_opcode_one_op718 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JLE_in_opcode_one_op725 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_opcode_one_op733 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HOST_in_opcode_n_op752 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXIT_in_opcode_no_op771 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RET_in_opcode_no_op778 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SADD_in_opcode_no_op785 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SSUB_in_opcode_no_op792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SMUL_in_opcode_no_op799 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SDIV_in_opcode_no_op806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SCNT_in_opcode_no_op816 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EMP_in_opcode_no_op824 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_operand852 = new BitSet(new ulong[]{0x2000000000002UL});
		public static readonly BitSet _49_in_operand855 = new BitSet(new ulong[]{0x140000UL});
		public static readonly BitSet _index_in_operand859 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_operand868 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_operand875 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_operand882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_index899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_index906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _instructions_in_synpred1_ASM379 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol.Runtime.Asm
