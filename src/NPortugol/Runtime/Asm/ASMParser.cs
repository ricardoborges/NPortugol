//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Git\\NPortugol\\src\\grammar\\ASM.g 2012-05-10 10:40:45

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace NPortugol.Runtime.Asm
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class ASMParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "CALL", "CNT", "COMMENT", "DCL", "DEC", "DIV", "ESC_SEQ", "EXIT", "EXPONENT", "FLOAT", "HEX_DIGIT", "HOST", "ID", "INC", "INT", "JE", "JG", "JGE", "JL", "JLE", "JMP", "JNE", "MOD", "MOV", "MUL", "NEG", "NEWLINE", "OCTAL_ESC", "POP", "POW", "PUSH", "RET", "SADD", "SCNT", "SDIV", "SMUL", "SSUB", "STRING", "SUB", "UNICODE_ESC", "WS", "','", "'.'", "':'"
	};
	public const int EOF=-1;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int ADD=4;
	public const int CALL=5;
	public const int CNT=6;
	public const int COMMENT=7;
	public const int DCL=8;
	public const int DEC=9;
	public const int DIV=10;
	public const int ESC_SEQ=11;
	public const int EXIT=12;
	public const int EXPONENT=13;
	public const int FLOAT=14;
	public const int HEX_DIGIT=15;
	public const int HOST=16;
	public const int ID=17;
	public const int INC=18;
	public const int INT=19;
	public const int JE=20;
	public const int JG=21;
	public const int JGE=22;
	public const int JL=23;
	public const int JLE=24;
	public const int JMP=25;
	public const int JNE=26;
	public const int MOD=27;
	public const int MOV=28;
	public const int MUL=29;
	public const int NEG=30;
	public const int NEWLINE=31;
	public const int OCTAL_ESC=32;
	public const int POP=33;
	public const int POW=34;
	public const int PUSH=35;
	public const int RET=36;
	public const int SADD=37;
	public const int SCNT=38;
	public const int SDIV=39;
	public const int SMUL=40;
	public const int SSUB=41;
	public const int STRING=42;
	public const int SUB=43;
	public const int UNICODE_ESC=44;
	public const int WS=45;

	public ASMParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ASMParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ASMParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Git\\NPortugol\\src\\grammar\\ASM.g"; } }


		public bool DebugInfo { get; set; }
	        public Dictionary<string, int> _labels = new Dictionary<string, int>();
	        public List<Instruction> _instructions = new List<Instruction>();
	        public FunctionTable _functionTable = new FunctionTable();
	        public int _index = 0;


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:8: public script returns [IList<Instruction> value] : ( func ( instructions )+ )* ;
	[GrammarRule("script")]
	public IList<Instruction> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		IList<Instruction> value = default(IList<Instruction>);


		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(51, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:49: ( ( func ( instructions )+ )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:51: ( func ( instructions )+ )*
			{
			DebugLocation(51, 51);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:51: ( func ( instructions )+ )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==ID))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:52: func ( instructions )+
					{
					DebugLocation(51, 52);
					PushFollow(Follow._func_in_script367);
					func();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(51, 57);
					// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:57: ( instructions )+
					int cnt1=0;
					try { DebugEnterSubRule(1);
					while (true)
					{
						int alt1=2;
						try { DebugEnterDecision(1, false);
						int LA1_0 = input.LA(1);

						if ((LA1_0==ID))
						{
							int LA1_2 = input.LA(2);

							if ((LA1_2==48))
							{
								int LA1_4 = input.LA(3);

								if ((LA1_4==NEWLINE))
								{
									int LA1_5 = input.LA(4);

									if ((EvaluatePredicate(synpred1_ASM_fragment)))
									{
										alt1 = 1;
									}


								}


							}


						}
						else if (((LA1_0>=ADD && LA1_0<=CNT)||(LA1_0>=DCL && LA1_0<=DIV)||LA1_0==EXIT||LA1_0==HOST||LA1_0==INC||(LA1_0>=JE && LA1_0<=NEG)||(LA1_0>=POP && LA1_0<=SSUB)||LA1_0==SUB||LA1_0==47))
						{
							alt1 = 1;
						}


						} finally { DebugExitDecision(1); }
						switch (alt1)
						{
						case 1:
							DebugEnterAlt(1);
							// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:57: instructions
							{
							DebugLocation(51, 57);
							PushFollow(Follow._instructions_in_script369);
							instructions();
							PopFollow();
							if (state.failed) return value;

							}
							break;

						default:
							if (cnt1 >= 1)
								goto loop1;

							if (state.backtracking>0) {state.failed=true; return value;}
							EarlyExitException eee1 = new EarlyExitException( 1, input );
							DebugRecognitionException(eee1);
							throw eee1;
						}
						cnt1++;
					}
					loop1:
						;

					} finally { DebugExitSubRule(1); }


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(51, 72);
			if (state.backtracking == 0)
			{


				            foreach (Instruction inst in _instructions)
				            {
				                if (inst.OpCode.ToString().StartsWith("J"))
				                {
				                   inst.Operands[0].Value = _labels[inst.Operands[0].Value.ToString()];
				                   inst.Operands[0].Type = OperandType.InstructionRef;
				                }
				            }
				            
				            value = _instructions;

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return value;

	}
	// $ANTLR end "script"

	partial void EnterRule_func();
	partial void LeaveRule_func();

	// $ANTLR start "func"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:66:1: func : ID ':' NEWLINE ;
	[GrammarRule("func")]
	private void func()
	{
		EnterRule_func();
		EnterRule("func", 2);
		TraceIn("func", 2);
		IToken ID1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "func");
		DebugLocation(66, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:66:6: ( ID ':' NEWLINE )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:66:8: ID ':' NEWLINE
			{
			DebugLocation(66, 8);
			ID1=(IToken)Match(input,ID,Follow._ID_in_func382); if (state.failed) return;
			DebugLocation(66, 11);
			Match(input,48,Follow._48_in_func384); if (state.failed) return;
			DebugLocation(66, 15);
			Match(input,NEWLINE,Follow._NEWLINE_in_func386); if (state.failed) return;
			DebugLocation(66, 22);
			if (state.backtracking == 0)
			{

				            var _function = new Function((ID1!=null?ID1.Text:null), _index );
				            _functionTable.Add(_function.Name, _function);
				            
				            if (DebugInfo)
				            {
				              var _instruction = new Instruction(OpCode.EMP, _index);
				              _index++;
				              _instructions.Add(_instruction);            
				            }

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("func", 2);
			LeaveRule("func", 2);
			LeaveRule_func();
		}
		DebugLocation(76, 1);
		} finally { DebugExitRule(GrammarFileName, "func"); }
		return;

	}
	// $ANTLR end "func"

	partial void EnterRule_instructions();
	partial void LeaveRule_instructions();

	// $ANTLR start "instructions"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:78:1: instructions : ( func | inst_no_op | inst_one_op | inst_two_op | inst_n_op | label );
	[GrammarRule("instructions")]
	private void instructions()
	{
		EnterRule_instructions();
		EnterRule("instructions", 3);
		TraceIn("instructions", 3);
		try { DebugEnterRule(GrammarFileName, "instructions");
		DebugLocation(78, 14);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:79:2: ( func | inst_no_op | inst_one_op | inst_two_op | inst_n_op | label )
			int alt3=6;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt3 = 1;
				}
				break;
			case EXIT:
			case RET:
			case SADD:
			case SCNT:
			case SDIV:
			case SMUL:
			case SSUB:
				{
				alt3 = 2;
				}
				break;
			case CALL:
			case DCL:
			case DEC:
			case INC:
			case JE:
			case JG:
			case JGE:
			case JL:
			case JLE:
			case JMP:
			case JNE:
			case NEG:
			case POP:
			case PUSH:
				{
				alt3 = 3;
				}
				break;
			case ADD:
			case CNT:
			case DIV:
			case MOD:
			case MOV:
			case MUL:
			case POW:
			case SUB:
				{
				alt3 = 4;
				}
				break;
			case HOST:
				{
				alt3 = 5;
				}
				break;
			case 47:
				{
				alt3 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:79:4: func
				{
				DebugLocation(79, 4);
				PushFollow(Follow._func_in_instructions397);
				func();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:80:10: inst_no_op
				{
				DebugLocation(80, 10);
				PushFollow(Follow._inst_no_op_in_instructions408);
				inst_no_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:81:10: inst_one_op
				{
				DebugLocation(81, 10);
				PushFollow(Follow._inst_one_op_in_instructions419);
				inst_one_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:82:10: inst_two_op
				{
				DebugLocation(82, 10);
				PushFollow(Follow._inst_two_op_in_instructions430);
				inst_two_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:83:10: inst_n_op
				{
				DebugLocation(83, 10);
				PushFollow(Follow._inst_n_op_in_instructions441);
				inst_n_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:84:10: label
				{
				DebugLocation(84, 10);
				PushFollow(Follow._label_in_instructions452);
				label();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("instructions", 3);
			LeaveRule("instructions", 3);
			LeaveRule_instructions();
		}
		DebugLocation(84, 14);
		} finally { DebugExitRule(GrammarFileName, "instructions"); }
		return;

	}
	// $ANTLR end "instructions"

	partial void EnterRule_label();
	partial void LeaveRule_label();

	// $ANTLR start "label"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:86:1: label : '.' ID NEWLINE ;
	[GrammarRule("label")]
	private void label()
	{
		EnterRule_label();
		EnterRule("label", 4);
		TraceIn("label", 4);
		IToken ID2 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "label");
		DebugLocation(86, 2);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:86:7: ( '.' ID NEWLINE )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:86:9: '.' ID NEWLINE
			{
			DebugLocation(86, 9);
			Match(input,47,Follow._47_in_label461); if (state.failed) return;
			DebugLocation(86, 13);
			ID2=(IToken)Match(input,ID,Follow._ID_in_label463); if (state.failed) return;
			DebugLocation(86, 16);
			Match(input,NEWLINE,Follow._NEWLINE_in_label465); if (state.failed) return;
			DebugLocation(86, 24);
			if (state.backtracking == 0)
			{
				 
					_labels.Add((ID2!=null?ID2.Text:null), _index);
					if (DebugInfo)
				        {
				            var _instruction = new Instruction(OpCode.EMP, _index);
				            _index++;
				            _instructions.Add(_instruction);	
				        }

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("label", 4);
			LeaveRule("label", 4);
			LeaveRule_label();
		}
		DebugLocation(94, 2);
		} finally { DebugExitRule(GrammarFileName, "label"); }
		return;

	}
	// $ANTLR end "label"

	partial void EnterRule_inst_no_op();
	partial void LeaveRule_inst_no_op();

	// $ANTLR start "inst_no_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:96:1: inst_no_op : e= opcode_no_op ( NEWLINE )* ;
	[GrammarRule("inst_no_op")]
	private void inst_no_op()
	{
		EnterRule_inst_no_op();
		EnterRule("inst_no_op", 5);
		TraceIn("inst_no_op", 5);
		OpCode e = default(OpCode);

		try { DebugEnterRule(GrammarFileName, "inst_no_op");
		DebugLocation(96, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:96:12: (e= opcode_no_op ( NEWLINE )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:96:14: e= opcode_no_op ( NEWLINE )*
			{
			DebugLocation(96, 15);
			PushFollow(Follow._opcode_no_op_in_inst_no_op478);
			e=opcode_no_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(96, 29);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:96:29: ( NEWLINE )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==NEWLINE))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:96:29: NEWLINE
					{
					DebugLocation(96, 29);
					Match(input,NEWLINE,Follow._NEWLINE_in_inst_no_op480); if (state.failed) return;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(96, 37);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new Operand[0]);
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_no_op", 5);
			LeaveRule("inst_no_op", 5);
			LeaveRule_inst_no_op();
		}
		DebugLocation(100, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_no_op"); }
		return;

	}
	// $ANTLR end "inst_no_op"

	partial void EnterRule_inst_one_op();
	partial void LeaveRule_inst_one_op();

	// $ANTLR start "inst_one_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:102:1: inst_one_op : e= opcode_one_op o= operand NEWLINE ;
	[GrammarRule("inst_one_op")]
	private void inst_one_op()
	{
		EnterRule_inst_one_op();
		EnterRule("inst_one_op", 6);
		TraceIn("inst_one_op", 6);
		OpCode e = default(OpCode);
		Operand o = default(Operand);

		try { DebugEnterRule(GrammarFileName, "inst_one_op");
		DebugLocation(102, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:102:13: (e= opcode_one_op o= operand NEWLINE )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:102:15: e= opcode_one_op o= operand NEWLINE
			{
			DebugLocation(102, 16);
			PushFollow(Follow._opcode_one_op_in_inst_one_op492);
			e=opcode_one_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(102, 32);
			PushFollow(Follow._operand_in_inst_one_op496);
			o=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(102, 41);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_one_op498); if (state.failed) return;
			DebugLocation(102, 48);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new []{o});
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_one_op", 6);
			LeaveRule("inst_one_op", 6);
			LeaveRule_inst_one_op();
		}
		DebugLocation(106, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_one_op"); }
		return;

	}
	// $ANTLR end "inst_one_op"

	partial void EnterRule_inst_two_op();
	partial void LeaveRule_inst_two_op();

	// $ANTLR start "inst_two_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:108:1: inst_two_op : e= opcode_two_op o= operand ',' p= operand NEWLINE ;
	[GrammarRule("inst_two_op")]
	private void inst_two_op()
	{
		EnterRule_inst_two_op();
		EnterRule("inst_two_op", 7);
		TraceIn("inst_two_op", 7);
		OpCode e = default(OpCode);
		Operand o = default(Operand);
		Operand p = default(Operand);

		try { DebugEnterRule(GrammarFileName, "inst_two_op");
		DebugLocation(108, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:108:13: (e= opcode_two_op o= operand ',' p= operand NEWLINE )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:108:15: e= opcode_two_op o= operand ',' p= operand NEWLINE
			{
			DebugLocation(108, 16);
			PushFollow(Follow._opcode_two_op_in_inst_two_op509);
			e=opcode_two_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(108, 32);
			PushFollow(Follow._operand_in_inst_two_op513);
			o=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(108, 41);
			Match(input,46,Follow._46_in_inst_two_op515); if (state.failed) return;
			DebugLocation(108, 46);
			PushFollow(Follow._operand_in_inst_two_op519);
			p=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(108, 55);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_two_op521); if (state.failed) return;
			DebugLocation(108, 62);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new []{o, p});
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_two_op", 7);
			LeaveRule("inst_two_op", 7);
			LeaveRule_inst_two_op();
		}
		DebugLocation(112, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_two_op"); }
		return;

	}
	// $ANTLR end "inst_two_op"

	partial void EnterRule_inst_n_op();
	partial void LeaveRule_inst_n_op();

	// $ANTLR start "inst_n_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:114:1: inst_n_op : e= opcode_n_op o+= ID ( ',' o+= ID )* NEWLINE ;
	[GrammarRule("inst_n_op")]
	private void inst_n_op()
	{
		EnterRule_inst_n_op();
		EnterRule("inst_n_op", 8);
		TraceIn("inst_n_op", 8);
		IToken o = default(IToken);
		List<IToken> list_o = null;
		OpCode e = default(OpCode);

		try { DebugEnterRule(GrammarFileName, "inst_n_op");
		DebugLocation(114, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:114:11: (e= opcode_n_op o+= ID ( ',' o+= ID )* NEWLINE )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:114:13: e= opcode_n_op o+= ID ( ',' o+= ID )* NEWLINE
			{
			DebugLocation(114, 14);
			PushFollow(Follow._opcode_n_op_in_inst_n_op532);
			e=opcode_n_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(114, 28);
			o=(IToken)Match(input,ID,Follow._ID_in_inst_n_op536); if (state.failed) return;
			if (list_o==null) list_o=new List<IToken>();
			list_o.Add(o);

			DebugLocation(114, 33);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:114:33: ( ',' o+= ID )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==46))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:114:34: ',' o+= ID
					{
					DebugLocation(114, 34);
					Match(input,46,Follow._46_in_inst_n_op539); if (state.failed) return;
					DebugLocation(114, 39);
					o=(IToken)Match(input,ID,Follow._ID_in_inst_n_op543); if (state.failed) return;
					if (list_o==null) list_o=new List<IToken>();
					list_o.Add(o);


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(114, 46);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_n_op547); if (state.failed) return;
			DebugLocation(114, 53);
			if (state.backtracking == 0)
			{


					    var plist = new List<Operand>();
								            
				            foreach(var item in list_o)
				            {
				            	plist.Add(new Operand(OperandType.HostObjectRef, item.Text));
				            }
				            
					    var _instruction = new Instruction(e, _index, plist.ToArray());
				            _index++;
				            _instructions.Add(_instruction);                          

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_n_op", 8);
			LeaveRule("inst_n_op", 8);
			LeaveRule_inst_n_op();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_n_op"); }
		return;

	}
	// $ANTLR end "inst_n_op"

	partial void EnterRule_opcode_two_op();
	partial void LeaveRule_opcode_two_op();

	// $ANTLR start "opcode_two_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:128:1: opcode_two_op returns [OpCode value] : ( MOV | ADD | SUB | MUL | DIV | MOD | POW | CNT );
	[GrammarRule("opcode_two_op")]
	private OpCode opcode_two_op()
	{
		EnterRule_opcode_two_op();
		EnterRule("opcode_two_op", 9);
		TraceIn("opcode_two_op", 9);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_two_op");
		DebugLocation(128, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:129:2: ( MOV | ADD | SUB | MUL | DIV | MOD | POW | CNT )
			int alt6=8;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case MOV:
				{
				alt6 = 1;
				}
				break;
			case ADD:
				{
				alt6 = 2;
				}
				break;
			case SUB:
				{
				alt6 = 3;
				}
				break;
			case MUL:
				{
				alt6 = 4;
				}
				break;
			case DIV:
				{
				alt6 = 5;
				}
				break;
			case MOD:
				{
				alt6 = 6;
				}
				break;
			case POW:
				{
				alt6 = 7;
				}
				break;
			case CNT:
				{
				alt6 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:129:4: MOV
				{
				DebugLocation(129, 4);
				Match(input,MOV,Follow._MOV_in_opcode_two_op562); if (state.failed) return value;
				DebugLocation(129, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MOV;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:130:4: ADD
				{
				DebugLocation(130, 4);
				Match(input,ADD,Follow._ADD_in_opcode_two_op569); if (state.failed) return value;
				DebugLocation(130, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.ADD;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:131:4: SUB
				{
				DebugLocation(131, 4);
				Match(input,SUB,Follow._SUB_in_opcode_two_op576); if (state.failed) return value;
				DebugLocation(131, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.SUB;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:132:4: MUL
				{
				DebugLocation(132, 4);
				Match(input,MUL,Follow._MUL_in_opcode_two_op583); if (state.failed) return value;
				DebugLocation(132, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MUL;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:133:4: DIV
				{
				DebugLocation(133, 4);
				Match(input,DIV,Follow._DIV_in_opcode_two_op590); if (state.failed) return value;
				DebugLocation(133, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DIV;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:134:4: MOD
				{
				DebugLocation(134, 4);
				Match(input,MOD,Follow._MOD_in_opcode_two_op597); if (state.failed) return value;
				DebugLocation(134, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MOD;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:135:4: POW
				{
				DebugLocation(135, 4);
				Match(input,POW,Follow._POW_in_opcode_two_op604); if (state.failed) return value;
				DebugLocation(135, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.POW;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:136:4: CNT
				{
				DebugLocation(136, 4);
				Match(input,CNT,Follow._CNT_in_opcode_two_op611); if (state.failed) return value;
				DebugLocation(136, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.CNT;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_two_op", 9);
			LeaveRule("opcode_two_op", 9);
			LeaveRule_opcode_two_op();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_two_op"); }
		return value;

	}
	// $ANTLR end "opcode_two_op"

	partial void EnterRule_opcode_one_op();
	partial void LeaveRule_opcode_one_op();

	// $ANTLR start "opcode_one_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:139:1: opcode_one_op returns [OpCode value] : ( DCL | NEG | INC | DEC | JMP | PUSH | POP | JE | JNE | JG | JL | JGE | JLE | CALL );
	[GrammarRule("opcode_one_op")]
	private OpCode opcode_one_op()
	{
		EnterRule_opcode_one_op();
		EnterRule("opcode_one_op", 10);
		TraceIn("opcode_one_op", 10);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_one_op");
		DebugLocation(139, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:140:2: ( DCL | NEG | INC | DEC | JMP | PUSH | POP | JE | JNE | JG | JL | JGE | JLE | CALL )
			int alt7=14;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case DCL:
				{
				alt7 = 1;
				}
				break;
			case NEG:
				{
				alt7 = 2;
				}
				break;
			case INC:
				{
				alt7 = 3;
				}
				break;
			case DEC:
				{
				alt7 = 4;
				}
				break;
			case JMP:
				{
				alt7 = 5;
				}
				break;
			case PUSH:
				{
				alt7 = 6;
				}
				break;
			case POP:
				{
				alt7 = 7;
				}
				break;
			case JE:
				{
				alt7 = 8;
				}
				break;
			case JNE:
				{
				alt7 = 9;
				}
				break;
			case JG:
				{
				alt7 = 10;
				}
				break;
			case JL:
				{
				alt7 = 11;
				}
				break;
			case JGE:
				{
				alt7 = 12;
				}
				break;
			case JLE:
				{
				alt7 = 13;
				}
				break;
			case CALL:
				{
				alt7 = 14;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:140:4: DCL
				{
				DebugLocation(140, 4);
				Match(input,DCL,Follow._DCL_in_opcode_one_op631); if (state.failed) return value;
				DebugLocation(140, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DCL;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:141:4: NEG
				{
				DebugLocation(141, 4);
				Match(input,NEG,Follow._NEG_in_opcode_one_op638); if (state.failed) return value;
				DebugLocation(141, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.NEG;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:142:4: INC
				{
				DebugLocation(142, 4);
				Match(input,INC,Follow._INC_in_opcode_one_op645); if (state.failed) return value;
				DebugLocation(142, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.INC;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:143:4: DEC
				{
				DebugLocation(143, 4);
				Match(input,DEC,Follow._DEC_in_opcode_one_op652); if (state.failed) return value;
				DebugLocation(143, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DEC;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:144:4: JMP
				{
				DebugLocation(144, 4);
				Match(input,JMP,Follow._JMP_in_opcode_one_op659); if (state.failed) return value;
				DebugLocation(144, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JMP;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:145:4: PUSH
				{
				DebugLocation(145, 4);
				Match(input,PUSH,Follow._PUSH_in_opcode_one_op666); if (state.failed) return value;
				DebugLocation(145, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.PUSH;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:146:4: POP
				{
				DebugLocation(146, 4);
				Match(input,POP,Follow._POP_in_opcode_one_op673); if (state.failed) return value;
				DebugLocation(146, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.POP;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:147:4: JE
				{
				DebugLocation(147, 4);
				Match(input,JE,Follow._JE_in_opcode_one_op680); if (state.failed) return value;
				DebugLocation(147, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JE;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:148:4: JNE
				{
				DebugLocation(148, 4);
				Match(input,JNE,Follow._JNE_in_opcode_one_op687); if (state.failed) return value;
				DebugLocation(148, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JNE;
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:149:4: JG
				{
				DebugLocation(149, 4);
				Match(input,JG,Follow._JG_in_opcode_one_op694); if (state.failed) return value;
				DebugLocation(149, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JG;
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:150:4: JL
				{
				DebugLocation(150, 4);
				Match(input,JL,Follow._JL_in_opcode_one_op701); if (state.failed) return value;
				DebugLocation(150, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JL;
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:151:4: JGE
				{
				DebugLocation(151, 4);
				Match(input,JGE,Follow._JGE_in_opcode_one_op708); if (state.failed) return value;
				DebugLocation(151, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JGE;
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:152:4: JLE
				{
				DebugLocation(152, 4);
				Match(input,JLE,Follow._JLE_in_opcode_one_op715); if (state.failed) return value;
				DebugLocation(152, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JLE;
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:153:4: CALL
				{
				DebugLocation(153, 4);
				Match(input,CALL,Follow._CALL_in_opcode_one_op723); if (state.failed) return value;
				DebugLocation(153, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.CALL;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_one_op", 10);
			LeaveRule("opcode_one_op", 10);
			LeaveRule_opcode_one_op();
		}
		DebugLocation(154, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_one_op"); }
		return value;

	}
	// $ANTLR end "opcode_one_op"

	partial void EnterRule_opcode_n_op();
	partial void LeaveRule_opcode_n_op();

	// $ANTLR start "opcode_n_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:156:1: opcode_n_op returns [OpCode value] : HOST ;
	[GrammarRule("opcode_n_op")]
	private OpCode opcode_n_op()
	{
		EnterRule_opcode_n_op();
		EnterRule("opcode_n_op", 11);
		TraceIn("opcode_n_op", 11);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_n_op");
		DebugLocation(156, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:157:2: ( HOST )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:157:4: HOST
			{
			DebugLocation(157, 4);
			Match(input,HOST,Follow._HOST_in_opcode_n_op742); if (state.failed) return value;
			DebugLocation(157, 9);
			if (state.backtracking == 0)
			{
				value = OpCode.HOST;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_n_op", 11);
			LeaveRule("opcode_n_op", 11);
			LeaveRule_opcode_n_op();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_n_op"); }
		return value;

	}
	// $ANTLR end "opcode_n_op"

	partial void EnterRule_opcode_no_op();
	partial void LeaveRule_opcode_no_op();

	// $ANTLR start "opcode_no_op"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:160:1: opcode_no_op returns [OpCode value] : ( EXIT | RET | SADD | SSUB | SMUL | SDIV | SCNT );
	[GrammarRule("opcode_no_op")]
	private OpCode opcode_no_op()
	{
		EnterRule_opcode_no_op();
		EnterRule("opcode_no_op", 12);
		TraceIn("opcode_no_op", 12);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_no_op");
		DebugLocation(160, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:161:2: ( EXIT | RET | SADD | SSUB | SMUL | SDIV | SCNT )
			int alt8=7;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case EXIT:
				{
				alt8 = 1;
				}
				break;
			case RET:
				{
				alt8 = 2;
				}
				break;
			case SADD:
				{
				alt8 = 3;
				}
				break;
			case SSUB:
				{
				alt8 = 4;
				}
				break;
			case SMUL:
				{
				alt8 = 5;
				}
				break;
			case SDIV:
				{
				alt8 = 6;
				}
				break;
			case SCNT:
				{
				alt8 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:161:4: EXIT
				{
				DebugLocation(161, 4);
				Match(input,EXIT,Follow._EXIT_in_opcode_no_op761); if (state.failed) return value;
				DebugLocation(161, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.EXIT;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:162:4: RET
				{
				DebugLocation(162, 4);
				Match(input,RET,Follow._RET_in_opcode_no_op768); if (state.failed) return value;
				DebugLocation(162, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.RET;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:163:4: SADD
				{
				DebugLocation(163, 4);
				Match(input,SADD,Follow._SADD_in_opcode_no_op775); if (state.failed) return value;
				DebugLocation(163, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SADD;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:164:4: SSUB
				{
				DebugLocation(164, 4);
				Match(input,SSUB,Follow._SSUB_in_opcode_no_op782); if (state.failed) return value;
				DebugLocation(164, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SSUB;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:165:4: SMUL
				{
				DebugLocation(165, 4);
				Match(input,SMUL,Follow._SMUL_in_opcode_no_op789); if (state.failed) return value;
				DebugLocation(165, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SMUL;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:166:4: SDIV
				{
				DebugLocation(166, 4);
				Match(input,SDIV,Follow._SDIV_in_opcode_no_op796); if (state.failed) return value;
				DebugLocation(166, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SDIV;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:167:4: SCNT
				{
				DebugLocation(167, 4);
				Match(input,SCNT,Follow._SCNT_in_opcode_no_op806); if (state.failed) return value;
				DebugLocation(167, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SCNT;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_no_op", 12);
			LeaveRule("opcode_no_op", 12);
			LeaveRule_opcode_no_op();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_no_op"); }
		return value;

	}
	// $ANTLR end "opcode_no_op"

	partial void EnterRule_operand();
	partial void LeaveRule_operand();

	// $ANTLR start "operand"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:170:1: operand returns [Operand value] : ( ID ( ':' i= index )? | INT | FLOAT | STRING );
	[GrammarRule("operand")]
	private Operand operand()
	{
		EnterRule_operand();
		EnterRule("operand", 13);
		TraceIn("operand", 13);
		Operand value = default(Operand);


		IToken ID3 = default(IToken);
		IToken INT4 = default(IToken);
		IToken FLOAT5 = default(IToken);
		IToken STRING6 = default(IToken);
		object i = default(object);

		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(170, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:171:9: ( ID ( ':' i= index )? | INT | FLOAT | STRING )
			int alt10=4;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt10 = 1;
				}
				break;
			case INT:
				{
				alt10 = 2;
				}
				break;
			case FLOAT:
				{
				alt10 = 3;
				}
				break;
			case STRING:
				{
				alt10 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:171:11: ID ( ':' i= index )?
				{
				DebugLocation(171, 11);
				ID3=(IToken)Match(input,ID,Follow._ID_in_operand835); if (state.failed) return value;
				DebugLocation(171, 14);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:171:14: ( ':' i= index )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==48))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:171:15: ':' i= index
					{
					DebugLocation(171, 15);
					Match(input,48,Follow._48_in_operand838); if (state.failed) return value;
					DebugLocation(171, 20);
					PushFollow(Follow._index_in_operand842);
					i=index();
					PopFollow();
					if (state.failed) return value;

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(171, 29);
				if (state.backtracking == 0)
				{

					        value = i==null? new Operand(OperandType.Variable, (ID3!=null?ID3.Text:null)): new Operand(OperandType.Variable, (ID3!=null?ID3.Text:null), i);
					        
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:174:4: INT
				{
				DebugLocation(174, 4);
				INT4=(IToken)Match(input,INT,Follow._INT_in_operand851); if (state.failed) return value;
				DebugLocation(174, 8);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, int.Parse((INT4!=null?INT4.Text:null)));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:175:4: FLOAT
				{
				DebugLocation(175, 4);
				FLOAT5=(IToken)Match(input,FLOAT,Follow._FLOAT_in_operand858); if (state.failed) return value;
				DebugLocation(175, 10);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, float.Parse((FLOAT5!=null?FLOAT5.Text:null)));
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:176:4: STRING
				{
				DebugLocation(176, 4);
				STRING6=(IToken)Match(input,STRING,Follow._STRING_in_operand865); if (state.failed) return value;
				DebugLocation(176, 11);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, (STRING6!=null?STRING6.Text:null).Substring(1, STRING6.Text.Length-2));
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("operand", 13);
			LeaveRule("operand", 13);
			LeaveRule_operand();
		}
		DebugLocation(177, 1);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		return value;

	}
	// $ANTLR end "operand"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:179:1: index returns [object value] : ( INT | ID );
	[GrammarRule("index")]
	private object index()
	{
		EnterRule_index();
		EnterRule("index", 14);
		TraceIn("index", 14);
		object value = default(object);


		IToken INT7 = default(IToken);
		IToken ID8 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(179, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:180:2: ( INT | ID )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==INT))
			{
				alt11 = 1;
			}
			else if ((LA11_0==ID))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:180:4: INT
				{
				DebugLocation(180, 4);
				INT7=(IToken)Match(input,INT,Follow._INT_in_index882); if (state.failed) return value;
				DebugLocation(180, 8);
				if (state.backtracking == 0)
				{
					value = int.Parse((INT7!=null?INT7.Text:null));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:181:4: ID
				{
				DebugLocation(181, 4);
				ID8=(IToken)Match(input,ID,Follow._ID_in_index889); if (state.failed) return value;
				DebugLocation(181, 8);
				if (state.backtracking == 0)
				{
					value = (ID8!=null?ID8.Text:null);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("index", 14);
			LeaveRule("index", 14);
			LeaveRule_index();
		}
		DebugLocation(182, 1);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return value;

	}
	// $ANTLR end "index"

	partial void EnterRule_synpred1_ASM_fragment();
	partial void LeaveRule_synpred1_ASM_fragment();

	// $ANTLR start synpred1_ASM
	public void synpred1_ASM_fragment()
	{
		EnterRule_synpred1_ASM_fragment();
		EnterRule("synpred1_ASM_fragment", 15);
		TraceIn("synpred1_ASM_fragment", 15);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:57: ( instructions )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\ASM.g:51:57: instructions
			{
			DebugLocation(51, 57);
			PushFollow(Follow._instructions_in_synpred1_ASM369);
			instructions();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_ASM_fragment", 15);
			LeaveRule("synpred1_ASM_fragment", 15);
			LeaveRule_synpred1_ASM_fragment();
		}
	}
	// $ANTLR end synpred1_ASM
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _func_in_script367 = new BitSet(new ulong[]{0x8BFE7FF71770UL});
		public static readonly BitSet _instructions_in_script369 = new BitSet(new ulong[]{0x8BFE7FF71772UL});
		public static readonly BitSet _ID_in_func382 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_func384 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _NEWLINE_in_func386 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_in_instructions397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_no_op_in_instructions408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_one_op_in_instructions419 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_two_op_in_instructions430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_n_op_in_instructions441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _label_in_instructions452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _47_in_label461 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_label463 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _NEWLINE_in_label465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_no_op_in_inst_no_op478 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _NEWLINE_in_inst_no_op480 = new BitSet(new ulong[]{0x80000002UL});
		public static readonly BitSet _opcode_one_op_in_inst_one_op492 = new BitSet(new ulong[]{0x400000A4000UL});
		public static readonly BitSet _operand_in_inst_one_op496 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _NEWLINE_in_inst_one_op498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_two_op_in_inst_two_op509 = new BitSet(new ulong[]{0x400000A4000UL});
		public static readonly BitSet _operand_in_inst_two_op513 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _46_in_inst_two_op515 = new BitSet(new ulong[]{0x400000A4000UL});
		public static readonly BitSet _operand_in_inst_two_op519 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _NEWLINE_in_inst_two_op521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_n_op_in_inst_n_op532 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_inst_n_op536 = new BitSet(new ulong[]{0x400080000000UL});
		public static readonly BitSet _46_in_inst_n_op539 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_inst_n_op543 = new BitSet(new ulong[]{0x400080000000UL});
		public static readonly BitSet _NEWLINE_in_inst_n_op547 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MOV_in_opcode_two_op562 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_opcode_two_op569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_opcode_two_op576 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MUL_in_opcode_two_op583 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_opcode_two_op590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MOD_in_opcode_two_op597 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POW_in_opcode_two_op604 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CNT_in_opcode_two_op611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DCL_in_opcode_one_op631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_opcode_one_op638 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_opcode_one_op645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_opcode_one_op652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JMP_in_opcode_one_op659 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PUSH_in_opcode_one_op666 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POP_in_opcode_one_op673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JE_in_opcode_one_op680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JNE_in_opcode_one_op687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JG_in_opcode_one_op694 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JL_in_opcode_one_op701 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JGE_in_opcode_one_op708 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JLE_in_opcode_one_op715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_opcode_one_op723 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HOST_in_opcode_n_op742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXIT_in_opcode_no_op761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RET_in_opcode_no_op768 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SADD_in_opcode_no_op775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SSUB_in_opcode_no_op782 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SMUL_in_opcode_no_op789 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SDIV_in_opcode_no_op796 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SCNT_in_opcode_no_op806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_operand835 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _48_in_operand838 = new BitSet(new ulong[]{0xA0000UL});
		public static readonly BitSet _index_in_operand842 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_operand851 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_operand858 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_operand865 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_index882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_index889 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _instructions_in_synpred1_ASM369 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol.Runtime.Asm
