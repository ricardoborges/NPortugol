//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Git\\NPortugol\\src\\grammar\\ASM.g 2014-04-15 14:49:48

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace NPortugol.Runtime.Asm
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class ASMParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "CALL", "CNT", "COMMENT", "DCL", "DEC", "DIV", "EMP", "ESC_SEQ", "EXIT", "EXPONENT", "F", "FLOAT", "HEX_DIGIT", "HOST", "ID", "INC", "INT", "JE", "JG", "JGE", "JL", "JLE", "JMP", "JNE", "MOD", "MOV", "MUL", "NEG", "NEWLINE", "OCTAL_ESC", "POP", "POW", "PUSH", "RET", "SADD", "SCNT", "SDIV", "SMOD", "SMUL", "SSUB", "STRING", "SUB", "T", "UNICODE_ESC", "WS", "'.'", "':'", "';'"
	};
	public const int EOF=-1;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int ADD=4;
	public const int CALL=5;
	public const int CNT=6;
	public const int COMMENT=7;
	public const int DCL=8;
	public const int DEC=9;
	public const int DIV=10;
	public const int EMP=11;
	public const int ESC_SEQ=12;
	public const int EXIT=13;
	public const int EXPONENT=14;
	public const int F=15;
	public const int FLOAT=16;
	public const int HEX_DIGIT=17;
	public const int HOST=18;
	public const int ID=19;
	public const int INC=20;
	public const int INT=21;
	public const int JE=22;
	public const int JG=23;
	public const int JGE=24;
	public const int JL=25;
	public const int JLE=26;
	public const int JMP=27;
	public const int JNE=28;
	public const int MOD=29;
	public const int MOV=30;
	public const int MUL=31;
	public const int NEG=32;
	public const int NEWLINE=33;
	public const int OCTAL_ESC=34;
	public const int POP=35;
	public const int POW=36;
	public const int PUSH=37;
	public const int RET=38;
	public const int SADD=39;
	public const int SCNT=40;
	public const int SDIV=41;
	public const int SMOD=42;
	public const int SMUL=43;
	public const int SSUB=44;
	public const int STRING=45;
	public const int SUB=46;
	public const int T=47;
	public const int UNICODE_ESC=48;
	public const int WS=49;

	public ASMParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ASMParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ASMParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Git\\NPortugol\\src\\grammar\\ASM.g"; } }


		public bool DebugInfo { get; set; }
	        public Dictionary<string, int> _labels = new Dictionary<string, int>();
	        public List<Instruction> _instructions = new List<Instruction>();
	        public FunctionTable _functionTable = new FunctionTable();
	        public int _index = 0;


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:8: public script returns [IList<Instruction> value] : ( func ( instructions )+ )* ;
	[GrammarRule("script")]
	public IList<Instruction> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		IList<Instruction> value = default(IList<Instruction>);


		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(53, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:49: ( ( func ( instructions )+ )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:51: ( func ( instructions )+ )*
			{
			DebugLocation(53, 51);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:51: ( func ( instructions )+ )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==ID))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:52: func ( instructions )+
					{
					DebugLocation(53, 52);
					PushFollow(Follow._func_in_script387);
					func();
					PopFollow();
					if (state.failed) return value;
					DebugLocation(53, 57);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:57: ( instructions )+
					int cnt1=0;
					try { DebugEnterSubRule(1);
					while (true)
					{
						int alt1=2;
						try { DebugEnterDecision(1, false);
						int LA1_0 = input.LA(1);

						if ((LA1_0==ID))
						{
							int LA1_2 = input.LA(2);

							if ((LA1_2==51))
							{
								int LA1_4 = input.LA(3);

								if ((LA1_4==NEWLINE))
								{
									int LA1_5 = input.LA(4);

									if ((EvaluatePredicate(synpred1_ASM_fragment)))
									{
										alt1 = 1;
									}


								}


							}


						}
						else if (((LA1_0>=ADD && LA1_0<=CNT)||(LA1_0>=DCL && LA1_0<=EMP)||LA1_0==EXIT||LA1_0==HOST||LA1_0==INC||(LA1_0>=JE && LA1_0<=NEG)||(LA1_0>=POP && LA1_0<=SSUB)||LA1_0==SUB||LA1_0==50))
						{
							alt1 = 1;
						}


						} finally { DebugExitDecision(1); }
						switch (alt1)
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:57: instructions
							{
							DebugLocation(53, 57);
							PushFollow(Follow._instructions_in_script389);
							instructions();
							PopFollow();
							if (state.failed) return value;

							}
							break;

						default:
							if (cnt1 >= 1)
								goto loop1;

							if (state.backtracking>0) {state.failed=true; return value;}
							EarlyExitException eee1 = new EarlyExitException( 1, input );
							DebugRecognitionException(eee1);
							throw eee1;
						}
						cnt1++;
					}
					loop1:
						;

					} finally { DebugExitSubRule(1); }


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(53, 72);
			if (state.backtracking == 0)
			{


				            foreach (Instruction inst in _instructions)
				            {
				                if (inst.OpCode.ToString().StartsWith("J"))
				                {
				                   inst.Operands[0].Value = _labels[inst.Operands[0].Value.ToString()];
				                   inst.Operands[0].Type = OperandType.InstructionRef;
				                }
				            }
				            
				            value = _instructions;

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(65, 1);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return value;

	}
	// $ANTLR end "script"

	partial void EnterRule_func();
	partial void LeaveRule_func();

	// $ANTLR start "func"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:68:1: func : ID ':' NEWLINE ;
	[GrammarRule("func")]
	private void func()
	{
		EnterRule_func();
		EnterRule("func", 2);
		TraceIn("func", 2);
		IToken ID1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "func");
		DebugLocation(68, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:68:6: ( ID ':' NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:68:8: ID ':' NEWLINE
			{
			DebugLocation(68, 8);
			ID1=(IToken)Match(input,ID,Follow._ID_in_func402); if (state.failed) return;
			DebugLocation(68, 11);
			Match(input,51,Follow._51_in_func404); if (state.failed) return;
			DebugLocation(68, 15);
			Match(input,NEWLINE,Follow._NEWLINE_in_func406); if (state.failed) return;
			DebugLocation(68, 22);
			if (state.backtracking == 0)
			{

				            var _function = new Function((ID1!=null?ID1.Text:null), _index );
				            _functionTable.Add(_function.Name, _function);
				            
				            if (DebugInfo)
				            {
				              var _instruction = new Instruction(OpCode.EMP, _index);
				              _index++;
				              _instructions.Add(_instruction);            
				            }

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("func", 2);
			LeaveRule("func", 2);
			LeaveRule_func();
		}
		DebugLocation(78, 1);
		} finally { DebugExitRule(GrammarFileName, "func"); }
		return;

	}
	// $ANTLR end "func"

	partial void EnterRule_instructions();
	partial void LeaveRule_instructions();

	// $ANTLR start "instructions"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:80:1: instructions : ( func | inst_no_op | inst_one_op | inst_two_op | inst_n_op | label );
	[GrammarRule("instructions")]
	private void instructions()
	{
		EnterRule_instructions();
		EnterRule("instructions", 3);
		TraceIn("instructions", 3);
		try { DebugEnterRule(GrammarFileName, "instructions");
		DebugLocation(80, 14);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:81:2: ( func | inst_no_op | inst_one_op | inst_two_op | inst_n_op | label )
			int alt3=6;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt3 = 1;
				}
				break;
			case EMP:
			case EXIT:
			case RET:
			case SADD:
			case SCNT:
			case SDIV:
			case SMOD:
			case SMUL:
			case SSUB:
				{
				alt3 = 2;
				}
				break;
			case CALL:
			case DCL:
			case DEC:
			case INC:
			case JE:
			case JG:
			case JGE:
			case JL:
			case JLE:
			case JMP:
			case JNE:
			case NEG:
			case POP:
			case PUSH:
				{
				alt3 = 3;
				}
				break;
			case ADD:
			case CNT:
			case DIV:
			case MOD:
			case MOV:
			case MUL:
			case POW:
			case SUB:
				{
				alt3 = 4;
				}
				break;
			case HOST:
				{
				alt3 = 5;
				}
				break;
			case 50:
				{
				alt3 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:81:4: func
				{
				DebugLocation(81, 4);
				PushFollow(Follow._func_in_instructions417);
				func();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:82:10: inst_no_op
				{
				DebugLocation(82, 10);
				PushFollow(Follow._inst_no_op_in_instructions428);
				inst_no_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:83:10: inst_one_op
				{
				DebugLocation(83, 10);
				PushFollow(Follow._inst_one_op_in_instructions439);
				inst_one_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:84:10: inst_two_op
				{
				DebugLocation(84, 10);
				PushFollow(Follow._inst_two_op_in_instructions450);
				inst_two_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:85:10: inst_n_op
				{
				DebugLocation(85, 10);
				PushFollow(Follow._inst_n_op_in_instructions461);
				inst_n_op();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:86:10: label
				{
				DebugLocation(86, 10);
				PushFollow(Follow._label_in_instructions472);
				label();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("instructions", 3);
			LeaveRule("instructions", 3);
			LeaveRule_instructions();
		}
		DebugLocation(86, 14);
		} finally { DebugExitRule(GrammarFileName, "instructions"); }
		return;

	}
	// $ANTLR end "instructions"

	partial void EnterRule_label();
	partial void LeaveRule_label();

	// $ANTLR start "label"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:88:1: label : '.' ID NEWLINE ;
	[GrammarRule("label")]
	private void label()
	{
		EnterRule_label();
		EnterRule("label", 4);
		TraceIn("label", 4);
		IToken ID2 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "label");
		DebugLocation(88, 2);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:88:7: ( '.' ID NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:88:9: '.' ID NEWLINE
			{
			DebugLocation(88, 9);
			Match(input,50,Follow._50_in_label481); if (state.failed) return;
			DebugLocation(88, 13);
			ID2=(IToken)Match(input,ID,Follow._ID_in_label483); if (state.failed) return;
			DebugLocation(88, 16);
			Match(input,NEWLINE,Follow._NEWLINE_in_label485); if (state.failed) return;
			DebugLocation(88, 24);
			if (state.backtracking == 0)
			{
				 
					_labels.Add((ID2!=null?ID2.Text:null), _index);
					if (DebugInfo)
				        {
				            var _instruction = new Instruction(OpCode.EMP, _index);
				            _index++;
				            _instructions.Add(_instruction);	
				        }

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("label", 4);
			LeaveRule("label", 4);
			LeaveRule_label();
		}
		DebugLocation(96, 2);
		} finally { DebugExitRule(GrammarFileName, "label"); }
		return;

	}
	// $ANTLR end "label"

	partial void EnterRule_inst_no_op();
	partial void LeaveRule_inst_no_op();

	// $ANTLR start "inst_no_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:98:1: inst_no_op : e= opcode_no_op ( NEWLINE )* ;
	[GrammarRule("inst_no_op")]
	private void inst_no_op()
	{
		EnterRule_inst_no_op();
		EnterRule("inst_no_op", 5);
		TraceIn("inst_no_op", 5);
		OpCode e = default(OpCode);

		try { DebugEnterRule(GrammarFileName, "inst_no_op");
		DebugLocation(98, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:98:12: (e= opcode_no_op ( NEWLINE )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:98:14: e= opcode_no_op ( NEWLINE )*
			{
			DebugLocation(98, 15);
			PushFollow(Follow._opcode_no_op_in_inst_no_op498);
			e=opcode_no_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(98, 29);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:98:29: ( NEWLINE )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==NEWLINE))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:98:29: NEWLINE
					{
					DebugLocation(98, 29);
					Match(input,NEWLINE,Follow._NEWLINE_in_inst_no_op500); if (state.failed) return;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(98, 37);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new Operand[0]);
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_no_op", 5);
			LeaveRule("inst_no_op", 5);
			LeaveRule_inst_no_op();
		}
		DebugLocation(102, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_no_op"); }
		return;

	}
	// $ANTLR end "inst_no_op"

	partial void EnterRule_inst_one_op();
	partial void LeaveRule_inst_one_op();

	// $ANTLR start "inst_one_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:104:1: inst_one_op : e= opcode_one_op o= operand NEWLINE ;
	[GrammarRule("inst_one_op")]
	private void inst_one_op()
	{
		EnterRule_inst_one_op();
		EnterRule("inst_one_op", 6);
		TraceIn("inst_one_op", 6);
		OpCode e = default(OpCode);
		Operand o = default(Operand);

		try { DebugEnterRule(GrammarFileName, "inst_one_op");
		DebugLocation(104, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:104:13: (e= opcode_one_op o= operand NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:104:15: e= opcode_one_op o= operand NEWLINE
			{
			DebugLocation(104, 16);
			PushFollow(Follow._opcode_one_op_in_inst_one_op512);
			e=opcode_one_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(104, 32);
			PushFollow(Follow._operand_in_inst_one_op516);
			o=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(104, 41);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_one_op518); if (state.failed) return;
			DebugLocation(104, 48);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new []{o});
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_one_op", 6);
			LeaveRule("inst_one_op", 6);
			LeaveRule_inst_one_op();
		}
		DebugLocation(108, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_one_op"); }
		return;

	}
	// $ANTLR end "inst_one_op"

	partial void EnterRule_inst_two_op();
	partial void LeaveRule_inst_two_op();

	// $ANTLR start "inst_two_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:110:1: inst_two_op : e= opcode_two_op o= operand ';' p= operand NEWLINE ;
	[GrammarRule("inst_two_op")]
	private void inst_two_op()
	{
		EnterRule_inst_two_op();
		EnterRule("inst_two_op", 7);
		TraceIn("inst_two_op", 7);
		OpCode e = default(OpCode);
		Operand o = default(Operand);
		Operand p = default(Operand);

		try { DebugEnterRule(GrammarFileName, "inst_two_op");
		DebugLocation(110, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:110:13: (e= opcode_two_op o= operand ';' p= operand NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:110:15: e= opcode_two_op o= operand ';' p= operand NEWLINE
			{
			DebugLocation(110, 16);
			PushFollow(Follow._opcode_two_op_in_inst_two_op529);
			e=opcode_two_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(110, 32);
			PushFollow(Follow._operand_in_inst_two_op533);
			o=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(110, 41);
			Match(input,52,Follow._52_in_inst_two_op535); if (state.failed) return;
			DebugLocation(110, 46);
			PushFollow(Follow._operand_in_inst_two_op539);
			p=operand();
			PopFollow();
			if (state.failed) return;
			DebugLocation(110, 55);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_two_op541); if (state.failed) return;
			DebugLocation(110, 62);
			if (state.backtracking == 0)
			{

				            var _instruction = new Instruction(e, _index, new []{o, p});
				            _index++;
				            _instructions.Add(_instruction);

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_two_op", 7);
			LeaveRule("inst_two_op", 7);
			LeaveRule_inst_two_op();
		}
		DebugLocation(114, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_two_op"); }
		return;

	}
	// $ANTLR end "inst_two_op"

	partial void EnterRule_inst_n_op();
	partial void LeaveRule_inst_n_op();

	// $ANTLR start "inst_n_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:116:1: inst_n_op : e= opcode_n_op o+= ID ( ';' o+= ID )* NEWLINE ;
	[GrammarRule("inst_n_op")]
	private void inst_n_op()
	{
		EnterRule_inst_n_op();
		EnterRule("inst_n_op", 8);
		TraceIn("inst_n_op", 8);
		IToken o = default(IToken);
		List<IToken> list_o = null;
		OpCode e = default(OpCode);

		try { DebugEnterRule(GrammarFileName, "inst_n_op");
		DebugLocation(116, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:116:11: (e= opcode_n_op o+= ID ( ';' o+= ID )* NEWLINE )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:116:13: e= opcode_n_op o+= ID ( ';' o+= ID )* NEWLINE
			{
			DebugLocation(116, 14);
			PushFollow(Follow._opcode_n_op_in_inst_n_op552);
			e=opcode_n_op();
			PopFollow();
			if (state.failed) return;
			DebugLocation(116, 28);
			o=(IToken)Match(input,ID,Follow._ID_in_inst_n_op556); if (state.failed) return;
			if (list_o==null) list_o=new List<IToken>();
			list_o.Add(o);

			DebugLocation(116, 33);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:116:33: ( ';' o+= ID )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==52))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:116:34: ';' o+= ID
					{
					DebugLocation(116, 34);
					Match(input,52,Follow._52_in_inst_n_op559); if (state.failed) return;
					DebugLocation(116, 39);
					o=(IToken)Match(input,ID,Follow._ID_in_inst_n_op563); if (state.failed) return;
					if (list_o==null) list_o=new List<IToken>();
					list_o.Add(o);


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(116, 46);
			Match(input,NEWLINE,Follow._NEWLINE_in_inst_n_op567); if (state.failed) return;
			DebugLocation(116, 53);
			if (state.backtracking == 0)
			{


					    var plist = new List<Operand>();
								            
				            foreach(var item in list_o)
				            {
				            	plist.Add(new Operand(OperandType.HostObjectRef, item.Text));
				            }
				            
					    var _instruction = new Instruction(e, _index, plist.ToArray());
				            _index++;
				            _instructions.Add(_instruction);                          

			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inst_n_op", 8);
			LeaveRule("inst_n_op", 8);
			LeaveRule_inst_n_op();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "inst_n_op"); }
		return;

	}
	// $ANTLR end "inst_n_op"

	partial void EnterRule_opcode_two_op();
	partial void LeaveRule_opcode_two_op();

	// $ANTLR start "opcode_two_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:130:1: opcode_two_op returns [OpCode value] : ( MOV | ADD | SUB | MUL | DIV | MOD | POW | CNT );
	[GrammarRule("opcode_two_op")]
	private OpCode opcode_two_op()
	{
		EnterRule_opcode_two_op();
		EnterRule("opcode_two_op", 9);
		TraceIn("opcode_two_op", 9);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_two_op");
		DebugLocation(130, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:131:2: ( MOV | ADD | SUB | MUL | DIV | MOD | POW | CNT )
			int alt6=8;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case MOV:
				{
				alt6 = 1;
				}
				break;
			case ADD:
				{
				alt6 = 2;
				}
				break;
			case SUB:
				{
				alt6 = 3;
				}
				break;
			case MUL:
				{
				alt6 = 4;
				}
				break;
			case DIV:
				{
				alt6 = 5;
				}
				break;
			case MOD:
				{
				alt6 = 6;
				}
				break;
			case POW:
				{
				alt6 = 7;
				}
				break;
			case CNT:
				{
				alt6 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:131:4: MOV
				{
				DebugLocation(131, 4);
				Match(input,MOV,Follow._MOV_in_opcode_two_op582); if (state.failed) return value;
				DebugLocation(131, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MOV;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:132:4: ADD
				{
				DebugLocation(132, 4);
				Match(input,ADD,Follow._ADD_in_opcode_two_op589); if (state.failed) return value;
				DebugLocation(132, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.ADD;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:133:4: SUB
				{
				DebugLocation(133, 4);
				Match(input,SUB,Follow._SUB_in_opcode_two_op596); if (state.failed) return value;
				DebugLocation(133, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.SUB;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:134:4: MUL
				{
				DebugLocation(134, 4);
				Match(input,MUL,Follow._MUL_in_opcode_two_op603); if (state.failed) return value;
				DebugLocation(134, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MUL;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:135:4: DIV
				{
				DebugLocation(135, 4);
				Match(input,DIV,Follow._DIV_in_opcode_two_op610); if (state.failed) return value;
				DebugLocation(135, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DIV;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:136:4: MOD
				{
				DebugLocation(136, 4);
				Match(input,MOD,Follow._MOD_in_opcode_two_op617); if (state.failed) return value;
				DebugLocation(136, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.MOD;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:137:4: POW
				{
				DebugLocation(137, 4);
				Match(input,POW,Follow._POW_in_opcode_two_op624); if (state.failed) return value;
				DebugLocation(137, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.POW;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:138:4: CNT
				{
				DebugLocation(138, 4);
				Match(input,CNT,Follow._CNT_in_opcode_two_op631); if (state.failed) return value;
				DebugLocation(138, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.CNT;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_two_op", 9);
			LeaveRule("opcode_two_op", 9);
			LeaveRule_opcode_two_op();
		}
		DebugLocation(139, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_two_op"); }
		return value;

	}
	// $ANTLR end "opcode_two_op"

	partial void EnterRule_opcode_one_op();
	partial void LeaveRule_opcode_one_op();

	// $ANTLR start "opcode_one_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:141:1: opcode_one_op returns [OpCode value] : ( DCL | NEG | INC | DEC | JMP | PUSH | POP | JE | JNE | JG | JL | JGE | JLE | CALL );
	[GrammarRule("opcode_one_op")]
	private OpCode opcode_one_op()
	{
		EnterRule_opcode_one_op();
		EnterRule("opcode_one_op", 10);
		TraceIn("opcode_one_op", 10);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_one_op");
		DebugLocation(141, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:142:2: ( DCL | NEG | INC | DEC | JMP | PUSH | POP | JE | JNE | JG | JL | JGE | JLE | CALL )
			int alt7=14;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case DCL:
				{
				alt7 = 1;
				}
				break;
			case NEG:
				{
				alt7 = 2;
				}
				break;
			case INC:
				{
				alt7 = 3;
				}
				break;
			case DEC:
				{
				alt7 = 4;
				}
				break;
			case JMP:
				{
				alt7 = 5;
				}
				break;
			case PUSH:
				{
				alt7 = 6;
				}
				break;
			case POP:
				{
				alt7 = 7;
				}
				break;
			case JE:
				{
				alt7 = 8;
				}
				break;
			case JNE:
				{
				alt7 = 9;
				}
				break;
			case JG:
				{
				alt7 = 10;
				}
				break;
			case JL:
				{
				alt7 = 11;
				}
				break;
			case JGE:
				{
				alt7 = 12;
				}
				break;
			case JLE:
				{
				alt7 = 13;
				}
				break;
			case CALL:
				{
				alt7 = 14;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:142:4: DCL
				{
				DebugLocation(142, 4);
				Match(input,DCL,Follow._DCL_in_opcode_one_op651); if (state.failed) return value;
				DebugLocation(142, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DCL;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:143:4: NEG
				{
				DebugLocation(143, 4);
				Match(input,NEG,Follow._NEG_in_opcode_one_op658); if (state.failed) return value;
				DebugLocation(143, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.NEG;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:144:4: INC
				{
				DebugLocation(144, 4);
				Match(input,INC,Follow._INC_in_opcode_one_op665); if (state.failed) return value;
				DebugLocation(144, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.INC;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:145:4: DEC
				{
				DebugLocation(145, 4);
				Match(input,DEC,Follow._DEC_in_opcode_one_op672); if (state.failed) return value;
				DebugLocation(145, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.DEC;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:146:4: JMP
				{
				DebugLocation(146, 4);
				Match(input,JMP,Follow._JMP_in_opcode_one_op679); if (state.failed) return value;
				DebugLocation(146, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JMP;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:147:4: PUSH
				{
				DebugLocation(147, 4);
				Match(input,PUSH,Follow._PUSH_in_opcode_one_op686); if (state.failed) return value;
				DebugLocation(147, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.PUSH;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:148:4: POP
				{
				DebugLocation(148, 4);
				Match(input,POP,Follow._POP_in_opcode_one_op693); if (state.failed) return value;
				DebugLocation(148, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.POP;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:149:4: JE
				{
				DebugLocation(149, 4);
				Match(input,JE,Follow._JE_in_opcode_one_op700); if (state.failed) return value;
				DebugLocation(149, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JE;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:150:4: JNE
				{
				DebugLocation(150, 4);
				Match(input,JNE,Follow._JNE_in_opcode_one_op707); if (state.failed) return value;
				DebugLocation(150, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JNE;
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:151:4: JG
				{
				DebugLocation(151, 4);
				Match(input,JG,Follow._JG_in_opcode_one_op714); if (state.failed) return value;
				DebugLocation(151, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JG;
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:152:4: JL
				{
				DebugLocation(152, 4);
				Match(input,JL,Follow._JL_in_opcode_one_op721); if (state.failed) return value;
				DebugLocation(152, 7);
				if (state.backtracking == 0)
				{
					value = OpCode.JL;
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:153:4: JGE
				{
				DebugLocation(153, 4);
				Match(input,JGE,Follow._JGE_in_opcode_one_op728); if (state.failed) return value;
				DebugLocation(153, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JGE;
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:154:4: JLE
				{
				DebugLocation(154, 4);
				Match(input,JLE,Follow._JLE_in_opcode_one_op735); if (state.failed) return value;
				DebugLocation(154, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.JLE;
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:155:4: CALL
				{
				DebugLocation(155, 4);
				Match(input,CALL,Follow._CALL_in_opcode_one_op743); if (state.failed) return value;
				DebugLocation(155, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.CALL;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_one_op", 10);
			LeaveRule("opcode_one_op", 10);
			LeaveRule_opcode_one_op();
		}
		DebugLocation(156, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_one_op"); }
		return value;

	}
	// $ANTLR end "opcode_one_op"

	partial void EnterRule_opcode_n_op();
	partial void LeaveRule_opcode_n_op();

	// $ANTLR start "opcode_n_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:158:1: opcode_n_op returns [OpCode value] : HOST ;
	[GrammarRule("opcode_n_op")]
	private OpCode opcode_n_op()
	{
		EnterRule_opcode_n_op();
		EnterRule("opcode_n_op", 11);
		TraceIn("opcode_n_op", 11);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_n_op");
		DebugLocation(158, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:159:2: ( HOST )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:159:4: HOST
			{
			DebugLocation(159, 4);
			Match(input,HOST,Follow._HOST_in_opcode_n_op762); if (state.failed) return value;
			DebugLocation(159, 9);
			if (state.backtracking == 0)
			{
				value = OpCode.HOST;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_n_op", 11);
			LeaveRule("opcode_n_op", 11);
			LeaveRule_opcode_n_op();
		}
		DebugLocation(160, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_n_op"); }
		return value;

	}
	// $ANTLR end "opcode_n_op"

	partial void EnterRule_opcode_no_op();
	partial void LeaveRule_opcode_no_op();

	// $ANTLR start "opcode_no_op"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:162:1: opcode_no_op returns [OpCode value] : ( EXIT | RET | SADD | SSUB | SMUL | SDIV | SMOD | SCNT | EMP );
	[GrammarRule("opcode_no_op")]
	private OpCode opcode_no_op()
	{
		EnterRule_opcode_no_op();
		EnterRule("opcode_no_op", 12);
		TraceIn("opcode_no_op", 12);
		OpCode value = default(OpCode);


		try { DebugEnterRule(GrammarFileName, "opcode_no_op");
		DebugLocation(162, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:163:2: ( EXIT | RET | SADD | SSUB | SMUL | SDIV | SMOD | SCNT | EMP )
			int alt8=9;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case EXIT:
				{
				alt8 = 1;
				}
				break;
			case RET:
				{
				alt8 = 2;
				}
				break;
			case SADD:
				{
				alt8 = 3;
				}
				break;
			case SSUB:
				{
				alt8 = 4;
				}
				break;
			case SMUL:
				{
				alt8 = 5;
				}
				break;
			case SDIV:
				{
				alt8 = 6;
				}
				break;
			case SMOD:
				{
				alt8 = 7;
				}
				break;
			case SCNT:
				{
				alt8 = 8;
				}
				break;
			case EMP:
				{
				alt8 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:163:4: EXIT
				{
				DebugLocation(163, 4);
				Match(input,EXIT,Follow._EXIT_in_opcode_no_op781); if (state.failed) return value;
				DebugLocation(163, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.EXIT;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:164:4: RET
				{
				DebugLocation(164, 4);
				Match(input,RET,Follow._RET_in_opcode_no_op788); if (state.failed) return value;
				DebugLocation(164, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.RET;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:165:4: SADD
				{
				DebugLocation(165, 4);
				Match(input,SADD,Follow._SADD_in_opcode_no_op795); if (state.failed) return value;
				DebugLocation(165, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SADD;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:166:4: SSUB
				{
				DebugLocation(166, 4);
				Match(input,SSUB,Follow._SSUB_in_opcode_no_op802); if (state.failed) return value;
				DebugLocation(166, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SSUB;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:167:4: SMUL
				{
				DebugLocation(167, 4);
				Match(input,SMUL,Follow._SMUL_in_opcode_no_op809); if (state.failed) return value;
				DebugLocation(167, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SMUL;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:168:4: SDIV
				{
				DebugLocation(168, 4);
				Match(input,SDIV,Follow._SDIV_in_opcode_no_op816); if (state.failed) return value;
				DebugLocation(168, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SDIV;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:169:4: SMOD
				{
				DebugLocation(169, 4);
				Match(input,SMOD,Follow._SMOD_in_opcode_no_op826); if (state.failed) return value;
				DebugLocation(169, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SMOD;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:170:4: SCNT
				{
				DebugLocation(170, 4);
				Match(input,SCNT,Follow._SCNT_in_opcode_no_op836); if (state.failed) return value;
				DebugLocation(170, 9);
				if (state.backtracking == 0)
				{
					value = OpCode.SCNT;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:171:4: EMP
				{
				DebugLocation(171, 4);
				Match(input,EMP,Follow._EMP_in_opcode_no_op844); if (state.failed) return value;
				DebugLocation(171, 8);
				if (state.backtracking == 0)
				{
					value = OpCode.EMP;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("opcode_no_op", 12);
			LeaveRule("opcode_no_op", 12);
			LeaveRule_opcode_no_op();
		}
		DebugLocation(172, 1);
		} finally { DebugExitRule(GrammarFileName, "opcode_no_op"); }
		return value;

	}
	// $ANTLR end "opcode_no_op"

	partial void EnterRule_operand();
	partial void LeaveRule_operand();

	// $ANTLR start "operand"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:174:1: operand returns [Operand value] : ( ID ( ':' i= index )? | INT | T | F | FLOAT | STRING );
	[GrammarRule("operand")]
	private Operand operand()
	{
		EnterRule_operand();
		EnterRule("operand", 13);
		TraceIn("operand", 13);
		Operand value = default(Operand);


		IToken ID3 = default(IToken);
		IToken INT4 = default(IToken);
		IToken FLOAT5 = default(IToken);
		IToken STRING6 = default(IToken);
		object i = default(object);

		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(174, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:175:9: ( ID ( ':' i= index )? | INT | T | F | FLOAT | STRING )
			int alt10=6;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt10 = 1;
				}
				break;
			case INT:
				{
				alt10 = 2;
				}
				break;
			case T:
				{
				alt10 = 3;
				}
				break;
			case F:
				{
				alt10 = 4;
				}
				break;
			case FLOAT:
				{
				alt10 = 5;
				}
				break;
			case STRING:
				{
				alt10 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:175:11: ID ( ':' i= index )?
				{
				DebugLocation(175, 11);
				ID3=(IToken)Match(input,ID,Follow._ID_in_operand872); if (state.failed) return value;
				DebugLocation(175, 14);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:175:14: ( ':' i= index )?
				int alt9=2;
				try { DebugEnterSubRule(9);
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==51))
				{
					alt9 = 1;
				}
				} finally { DebugExitDecision(9); }
				switch (alt9)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:175:15: ':' i= index
					{
					DebugLocation(175, 15);
					Match(input,51,Follow._51_in_operand875); if (state.failed) return value;
					DebugLocation(175, 20);
					PushFollow(Follow._index_in_operand879);
					i=index();
					PopFollow();
					if (state.failed) return value;

					}
					break;

				}
				} finally { DebugExitSubRule(9); }

				DebugLocation(175, 29);
				if (state.backtracking == 0)
				{

					        value = i==null? new Operand(OperandType.Variable, (ID3!=null?ID3.Text:null)): new Operand(OperandType.Variable, (ID3!=null?ID3.Text:null), i);
					        
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:178:4: INT
				{
				DebugLocation(178, 4);
				INT4=(IToken)Match(input,INT,Follow._INT_in_operand888); if (state.failed) return value;
				DebugLocation(178, 8);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, int.Parse((INT4!=null?INT4.Text:null)));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:179:4: T
				{
				DebugLocation(179, 4);
				Match(input,T,Follow._T_in_operand895); if (state.failed) return value;
				DebugLocation(179, 7);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, true);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:180:4: F
				{
				DebugLocation(180, 4);
				Match(input,F,Follow._F_in_operand903); if (state.failed) return value;
				DebugLocation(180, 7);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, false);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:181:4: FLOAT
				{
				DebugLocation(181, 4);
				FLOAT5=(IToken)Match(input,FLOAT,Follow._FLOAT_in_operand911); if (state.failed) return value;
				DebugLocation(181, 10);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, float.Parse((FLOAT5!=null?FLOAT5.Text:null)));
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:182:4: STRING
				{
				DebugLocation(182, 4);
				STRING6=(IToken)Match(input,STRING,Follow._STRING_in_operand918); if (state.failed) return value;
				DebugLocation(182, 11);
				if (state.backtracking == 0)
				{
					value = new Operand(OperandType.Literal, (STRING6!=null?STRING6.Text:null).Substring(1, STRING6.Text.Length-2));
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("operand", 13);
			LeaveRule("operand", 13);
			LeaveRule_operand();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		return value;

	}
	// $ANTLR end "operand"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:185:1: index returns [object value] : ( INT | ID );
	[GrammarRule("index")]
	private object index()
	{
		EnterRule_index();
		EnterRule("index", 14);
		TraceIn("index", 14);
		object value = default(object);


		IToken INT7 = default(IToken);
		IToken ID8 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(185, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:186:2: ( INT | ID )
			int alt11=2;
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==INT))
			{
				alt11 = 1;
			}
			else if ((LA11_0==ID))
			{
				alt11 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return value;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:186:4: INT
				{
				DebugLocation(186, 4);
				INT7=(IToken)Match(input,INT,Follow._INT_in_index935); if (state.failed) return value;
				DebugLocation(186, 8);
				if (state.backtracking == 0)
				{
					value = int.Parse((INT7!=null?INT7.Text:null));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:187:4: ID
				{
				DebugLocation(187, 4);
				ID8=(IToken)Match(input,ID,Follow._ID_in_index942); if (state.failed) return value;
				DebugLocation(187, 8);
				if (state.backtracking == 0)
				{
					value = (ID8!=null?ID8.Text:null);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("index", 14);
			LeaveRule("index", 14);
			LeaveRule_index();
		}
		DebugLocation(188, 1);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return value;

	}
	// $ANTLR end "index"

	partial void EnterRule_synpred1_ASM_fragment();
	partial void LeaveRule_synpred1_ASM_fragment();

	// $ANTLR start synpred1_ASM
	public void synpred1_ASM_fragment()
	{
		EnterRule_synpred1_ASM_fragment();
		EnterRule("synpred1_ASM_fragment", 15);
		TraceIn("synpred1_ASM_fragment", 15);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:57: ( instructions )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\ASM.g:53:57: instructions
			{
			DebugLocation(53, 57);
			PushFollow(Follow._instructions_in_synpred1_ASM389);
			instructions();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_ASM_fragment", 15);
			LeaveRule("synpred1_ASM_fragment", 15);
			LeaveRule_synpred1_ASM_fragment();
		}
	}
	// $ANTLR end synpred1_ASM
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _func_in_script387 = new BitSet(new ulong[]{0x45FF9FFDC2F70UL});
		public static readonly BitSet _instructions_in_script389 = new BitSet(new ulong[]{0x45FF9FFDC2F72UL});
		public static readonly BitSet _ID_in_func402 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_func404 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _NEWLINE_in_func406 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _func_in_instructions417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_no_op_in_instructions428 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_one_op_in_instructions439 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_two_op_in_instructions450 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _inst_n_op_in_instructions461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _label_in_instructions472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _50_in_label481 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_label483 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _NEWLINE_in_label485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_no_op_in_inst_no_op498 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _NEWLINE_in_inst_no_op500 = new BitSet(new ulong[]{0x200000002UL});
		public static readonly BitSet _opcode_one_op_in_inst_one_op512 = new BitSet(new ulong[]{0xA00000298000UL});
		public static readonly BitSet _operand_in_inst_one_op516 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _NEWLINE_in_inst_one_op518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_two_op_in_inst_two_op529 = new BitSet(new ulong[]{0xA00000298000UL});
		public static readonly BitSet _operand_in_inst_two_op533 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _52_in_inst_two_op535 = new BitSet(new ulong[]{0xA00000298000UL});
		public static readonly BitSet _operand_in_inst_two_op539 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _NEWLINE_in_inst_two_op541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _opcode_n_op_in_inst_n_op552 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_inst_n_op556 = new BitSet(new ulong[]{0x10000200000000UL});
		public static readonly BitSet _52_in_inst_n_op559 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_inst_n_op563 = new BitSet(new ulong[]{0x10000200000000UL});
		public static readonly BitSet _NEWLINE_in_inst_n_op567 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MOV_in_opcode_two_op582 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_opcode_two_op589 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_opcode_two_op596 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MUL_in_opcode_two_op603 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DIV_in_opcode_two_op610 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MOD_in_opcode_two_op617 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POW_in_opcode_two_op624 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CNT_in_opcode_two_op631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DCL_in_opcode_one_op651 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_opcode_one_op658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_opcode_one_op665 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_opcode_one_op672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JMP_in_opcode_one_op679 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PUSH_in_opcode_one_op686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POP_in_opcode_one_op693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JE_in_opcode_one_op700 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JNE_in_opcode_one_op707 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JG_in_opcode_one_op714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JL_in_opcode_one_op721 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JGE_in_opcode_one_op728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _JLE_in_opcode_one_op735 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CALL_in_opcode_one_op743 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HOST_in_opcode_n_op762 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXIT_in_opcode_no_op781 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RET_in_opcode_no_op788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SADD_in_opcode_no_op795 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SSUB_in_opcode_no_op802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SMUL_in_opcode_no_op809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SDIV_in_opcode_no_op816 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SMOD_in_opcode_no_op826 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SCNT_in_opcode_no_op836 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EMP_in_opcode_no_op844 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_operand872 = new BitSet(new ulong[]{0x8000000000002UL});
		public static readonly BitSet _51_in_operand875 = new BitSet(new ulong[]{0x280000UL});
		public static readonly BitSet _index_in_operand879 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_operand888 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _T_in_operand895 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_operand903 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_operand911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_operand918 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_index935 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_index942 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _instructions_in_synpred1_ASM389 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol.Runtime.Asm
