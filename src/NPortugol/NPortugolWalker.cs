//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g 2014-04-24 13:03:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

using System.Collections;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "ASM", "CALL", "CASE", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "F", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SEL", "SJMP", "SLIST", "STRING", "T", "UNICODE_ESC", "VAR", "WS", "'!='", "'#'", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "':'", "';'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'até'", "'caso'", "'decrescente'", "'e'", "'enquanto'", "'então'", "'fim'", "'função'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'selecione'", "'senão'", "'variável'", "'{'", "'}'", "'falso'", "'nulo'", "'verdadeiro'"
	};
	public const int EOF=-1;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int ASM=7;
	public const int CALL=8;
	public const int CASE=9;
	public const int CHAR=10;
	public const int DEC=11;
	public const int ESC_SEQ=12;
	public const int EXP=13;
	public const int EXPONENT=14;
	public const int F=15;
	public const int FLOAT=16;
	public const int FUNC=17;
	public const int HEX_DIGIT=18;
	public const int ID=19;
	public const int ILIST=20;
	public const int INDEX=21;
	public const int INIT=22;
	public const int INT=23;
	public const int JMP=24;
	public const int LEXP=25;
	public const int LOOP=26;
	public const int MCALL=27;
	public const int NEWLINE=28;
	public const int OCTAL_ESC=29;
	public const int PARAM=30;
	public const int PCALL=31;
	public const int RET=32;
	public const int SEL=33;
	public const int SJMP=34;
	public const int SLIST=35;
	public const int STRING=36;
	public const int T=37;
	public const int UNICODE_ESC=38;
	public const int VAR=39;
	public const int WS=40;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;

	public NPortugolWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return NPortugolWalker.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g"; } }


		Emissor emitter = new Emissor();
		
		bool inExpression;
		
		bool invertExp = true;
		
		public Dictionary<int, int> SourceMap { get { return emitter.SourceMap; } }
		
		public bool DebugInfo {get {return emitter.DebugInfo;} set{emitter.DebugInfo = value;} }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:27:8: public script returns [IList<string> scriptLines] : ( declare_function )* ;
	[GrammarRule("script")]
	public IList<string> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		IList<string> scriptLines = default(IList<string>);


		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(27, 0);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:27:50: ( ( declare_function )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:27:52: ( declare_function )*
			{
			DebugLocation(27, 52);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:27:52: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==FUNC))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:27:52: declare_function
					{
					DebugLocation(27, 52);
					PushFollow(Follow._declare_function_in_script62);
					declare_function();
					PopFollow();
					if (state.failed) return scriptLines;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(28, 2);
			if (state.backtracking == 0)
			{
				 return emitter.ScriptLines;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(29, 0);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return scriptLines;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:1: declare_function : ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private void declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		CommonTree ID1 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(31, 0);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:18: ( ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:20: ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
			DebugLocation(31, 20);
			DebugLocation(31, 22);
			Match(input,FUNC,Follow._FUNC_in_declare_function76); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(31, 27);
			ID1=(CommonTree)Match(input,ID,Follow._ID_in_declare_function78); if (state.failed) return;
			DebugLocation(31, 30);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:30: ( function_param_list )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==PARAM))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:30: function_param_list
					{
					DebugLocation(31, 30);
					PushFollow(Follow._function_param_list_in_declare_function80);
					function_param_list();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(31, 51);
			DebugLocation(31, 53);
			Match(input,SLIST,Follow._SLIST_in_declare_function84); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(31, 59);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:59: ( statement )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if (((LA3_0>=ASGN && LA3_0<=CALL)||LA3_0==JMP||LA3_0==LOOP||(LA3_0>=RET && LA3_0<=SJMP)||LA3_0==VAR))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:31:59: statement
						{
						DebugLocation(31, 59);
						PushFollow(Follow._statement_in_declare_function86);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(32, 2);
			if (state.backtracking == 0)
			{
				emitter.EmitFunction(ID1.Token);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(33, 0);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:35:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | select_stat | function_call | assign_var | return_stat | asm_code );
	[GrammarRule("statement")]
	private void statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(35, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:35:10: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | select_stat | function_call | assign_var | return_stat | asm_code )
			int alt4=10;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case VAR:
				{
				alt4 = 1;
				}
				break;
			case JMP:
			case SJMP:
				{
				alt4 = 2;
				}
				break;
			case LOOP:
				{
				int LA4_4 = input.LA(2);

				if ((LA4_4==DOWN))
				{
					switch (input.LA(3))
					{
					case ASGN:
					case DEC:
						{
						alt4 = 3;
						}
						break;
					case LEXP:
						{
						alt4 = 4;
						}
						break;
					case SLIST:
						{
						alt4 = 5;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 4, 10, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 4, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SEL:
				{
				alt4 = 6;
				}
				break;
			case CALL:
				{
				alt4 = 7;
				}
				break;
			case ASGN:
				{
				alt4 = 8;
				}
				break;
			case RET:
				{
				alt4 = 9;
				}
				break;
			case ASM:
				{
				alt4 = 10;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:35:12: declare_local
				{
				DebugLocation(35, 12);
				PushFollow(Follow._declare_local_in_statement103);
				declare_local();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:36:4: if_stat
				{
				DebugLocation(36, 4);
				PushFollow(Follow._if_stat_in_statement108);
				if_stat();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:37:4: for_stat
				{
				DebugLocation(37, 4);
				PushFollow(Follow._for_stat_in_statement114);
				for_stat();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:38:4: while_stat
				{
				DebugLocation(38, 4);
				PushFollow(Follow._while_stat_in_statement119);
				while_stat();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:39:4: repeat_stat
				{
				DebugLocation(39, 4);
				PushFollow(Follow._repeat_stat_in_statement124);
				repeat_stat();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:40:4: select_stat
				{
				DebugLocation(40, 4);
				PushFollow(Follow._select_stat_in_statement129);
				select_stat();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:41:4: function_call
				{
				DebugLocation(41, 4);
				PushFollow(Follow._function_call_in_statement135);
				function_call();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:42:4: assign_var
				{
				DebugLocation(42, 4);
				PushFollow(Follow._assign_var_in_statement141);
				assign_var();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:43:4: return_stat
				{
				DebugLocation(43, 4);
				PushFollow(Follow._return_stat_in_statement146);
				return_stat();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:44:4: asm_code
				{
				DebugLocation(44, 4);
				PushFollow(Follow._asm_code_in_statement151);
				asm_code();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(45, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:48:1: function_param_list : ^( PARAM (p+= ID )* ) ;
	[GrammarRule("function_param_list")]
	private void function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		CommonTree p = default(CommonTree);
		List<CommonTree> list_p = null;

		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(48, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:49:2: ( ^( PARAM (p+= ID )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:49:5: ^( PARAM (p+= ID )* )
			{
			DebugLocation(49, 5);
			DebugLocation(49, 7);
			Match(input,PARAM,Follow._PARAM_in_function_param_list171); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(49, 14);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:49:14: (p+= ID )*
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0==ID))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch ( alt5 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:49:14: p+= ID
						{
						DebugLocation(49, 14);
						p=(CommonTree)Match(input,ID,Follow._ID_in_function_param_list175); if (state.failed) return;
						if (list_p==null) list_p=new List<CommonTree>();
						list_p.Add(p);


						}
						break;

					default:
						goto loop5;
					}
				}

				loop5:
					;

				} finally { DebugExitSubRule(5); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}

			DebugLocation(49, 21);
			if (state.backtracking == 0)
			{
				 foreach(var item in list_p) emitter.AddParam(item.Text); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(50, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:52:1: declare_local : ^( VAR (i+= ID )* ) ;
	[GrammarRule("declare_local")]
	private void declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 5);
		TraceIn("declare_local", 5);
		CommonTree i = default(CommonTree);
		List<CommonTree> list_i = null;

		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(52, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:53:2: ( ^( VAR (i+= ID )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:53:5: ^( VAR (i+= ID )* )
			{
			DebugLocation(53, 5);
			DebugLocation(53, 7);
			Match(input,VAR,Follow._VAR_in_declare_local194); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(53, 12);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:53:12: (i+= ID )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==ID))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:53:12: i+= ID
						{
						DebugLocation(53, 12);
						i=(CommonTree)Match(input,ID,Follow._ID_in_declare_local198); if (state.failed) return;
						if (list_i==null) list_i=new List<CommonTree>();
						list_i.Add(i);


						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}

			DebugLocation(53, 20);
			if (state.backtracking == 0)
			{
				 foreach(var item in list_i) emitter.EmitVar(item.Token); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declare_local", 5);
			LeaveRule("declare_local", 5);
			LeaveRule_declare_local();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:56:1: if_stat : ( ^( SJMP ^( LEXP logic_expression ) ^( SLIST ( statement )* senao_stat ) ) | ^( JMP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) );
	[GrammarRule("if_stat")]
	private void if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 6);
		TraceIn("if_stat", 6);
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(56, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:57:2: ( ^( SJMP ^( LEXP logic_expression ) ^( SLIST ( statement )* senao_stat ) ) | ^( JMP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==SJMP))
			{
				alt9 = 1;
			}
			else if ((LA9_0==JMP))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:57:5: ^( SJMP ^( LEXP logic_expression ) ^( SLIST ( statement )* senao_stat ) )
				{
				DebugLocation(57, 5);
				DebugLocation(57, 7);
				Match(input,SJMP,Follow._SJMP_in_if_stat216); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(57, 12);
				DebugLocation(57, 14);
				Match(input,LEXP,Follow._LEXP_in_if_stat219); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(57, 19);
				PushFollow(Follow._logic_expression_in_if_stat221);
				logic_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(57, 37);
				DebugLocation(57, 39);
				Match(input,SLIST,Follow._SLIST_in_if_stat225); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(57, 45);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:57:45: ( statement )*
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if (((LA7_0>=ASGN && LA7_0<=CALL)||LA7_0==JMP||LA7_0==LOOP||(LA7_0>=RET && LA7_0<=SJMP)||LA7_0==VAR))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch ( alt7 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:57:45: statement
						{
						DebugLocation(57, 45);
						PushFollow(Follow._statement_in_if_stat227);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop7;
					}
				}

				loop7:
					;

				} finally { DebugExitSubRule(7); }

				DebugLocation(57, 56);
				if (state.backtracking == 0)
				{
					emitter.EmitIf(true);
				}
				DebugLocation(57, 80);
				PushFollow(Follow._senao_stat_in_if_stat232);
				senao_stat();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:58:5: ^( JMP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				DebugLocation(58, 5);
				DebugLocation(58, 7);
				Match(input,JMP,Follow._JMP_in_if_stat241); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(58, 11);
				DebugLocation(58, 13);
				Match(input,LEXP,Follow._LEXP_in_if_stat244); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(58, 18);
				PushFollow(Follow._logic_expression_in_if_stat246);
				logic_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(58, 36);
				DebugLocation(58, 38);
				Match(input,SLIST,Follow._SLIST_in_if_stat250); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(58, 44);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:58:44: ( statement )*
					try { DebugEnterSubRule(8);
					while (true)
					{
						int alt8=2;
						try { DebugEnterDecision(8, false);
						int LA8_0 = input.LA(1);

						if (((LA8_0>=ASGN && LA8_0<=CALL)||LA8_0==JMP||LA8_0==LOOP||(LA8_0>=RET && LA8_0<=SJMP)||LA8_0==VAR))
						{
							alt8 = 1;
						}


						} finally { DebugExitDecision(8); }
						switch ( alt8 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:58:44: statement
							{
							DebugLocation(58, 44);
							PushFollow(Follow._statement_in_if_stat252);
							statement();
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop8;
						}
					}

					loop8:
						;

					} finally { DebugExitSubRule(8); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(59, 2);
				if (state.backtracking == 0)
				{
					emitter.EmitIf(false);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("if_stat", 6);
			LeaveRule("if_stat", 6);
			LeaveRule_if_stat();
		}
		DebugLocation(60, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:62:1: senao_stat : ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private void senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 7);
		TraceIn("senao_stat", 7);
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(62, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:63:2: ( ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:63:4: ^( SLIST ( statement )* )
			{
			DebugLocation(63, 4);
			DebugLocation(63, 6);
			Match(input,SLIST,Follow._SLIST_in_senao_stat271); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(63, 12);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:63:12: ( statement )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if (((LA10_0>=ASGN && LA10_0<=CALL)||LA10_0==JMP||LA10_0==LOOP||(LA10_0>=RET && LA10_0<=SJMP)||LA10_0==VAR))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:63:12: statement
						{
						DebugLocation(63, 12);
						PushFollow(Follow._statement_in_senao_stat273);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}

			DebugLocation(64, 5);
			if (state.backtracking == 0)
			{
				emitter.EmitElse();
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("senao_stat", 7);
			LeaveRule("senao_stat", 7);
			LeaveRule_senao_stat();
		}
		DebugLocation(65, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:68:1: for_stat : ( ^( LOOP a= assign_var i= INT ^( SLIST ( statement )* ) ) | ^( LOOP DEC a= assign_var i= INT ^( SLIST ( statement )* ) ) | ^( LOOP a= assign_var i= ID ^( SLIST ( statement )* ) ) | ^( LOOP DEC a= assign_var i= ID ^( SLIST ( statement )* ) ) );
	[GrammarRule("for_stat")]
	private void for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 8);
		TraceIn("for_stat", 8);
		CommonTree i = default(CommonTree);
		string a = default(string);

		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(68, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:3: ( ^( LOOP a= assign_var i= INT ^( SLIST ( statement )* ) ) | ^( LOOP DEC a= assign_var i= INT ^( SLIST ( statement )* ) ) | ^( LOOP a= assign_var i= ID ^( SLIST ( statement )* ) ) | ^( LOOP DEC a= assign_var i= ID ^( SLIST ( statement )* ) ) )
			int alt15=4;
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==LOOP))
			{
				int LA15_1 = input.LA(2);

				if ((LA15_1==DOWN))
				{
					int LA15_2 = input.LA(3);

					if ((LA15_2==DEC))
					{
						int LA15_3 = input.LA(4);

						if ((EvaluatePredicate(synpred22_NPortugolWalker_fragment)))
						{
							alt15 = 2;
						}
						else if ((true))
						{
							alt15 = 4;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 15, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA15_2==ASGN))
					{
						int LA15_4 = input.LA(4);

						if ((EvaluatePredicate(synpred20_NPortugolWalker_fragment)))
						{
							alt15 = 1;
						}
						else if ((EvaluatePredicate(synpred24_NPortugolWalker_fragment)))
						{
							alt15 = 3;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 15, 4, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 15, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:3: ^( LOOP a= assign_var i= INT ^( SLIST ( statement )* ) )
				{
				DebugLocation(69, 3);
				DebugLocation(69, 5);
				Match(input,LOOP,Follow._LOOP_in_for_stat297); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(69, 11);
				PushFollow(Follow._assign_var_in_for_stat301);
				a=assign_var();
				PopFollow();
				if (state.failed) return;
				DebugLocation(69, 23);
				if (state.backtracking == 0)
				{
					 emitter.SetForInc(a); 
				}
				DebugLocation(69, 50);
				i=(CommonTree)Match(input,INT,Follow._INT_in_for_stat307); if (state.failed) return;
				DebugLocation(69, 55);
				DebugLocation(69, 57);
				Match(input,SLIST,Follow._SLIST_in_for_stat310); if (state.failed) return;

				DebugLocation(69, 64);
				if (state.backtracking == 0)
				{
					emitter.EmitInitFor(i.Token, true);
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(69, 103);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:103: ( statement )*
					try { DebugEnterSubRule(11);
					while (true)
					{
						int alt11=2;
						try { DebugEnterDecision(11, false);
						int LA11_0 = input.LA(1);

						if (((LA11_0>=ASGN && LA11_0<=CALL)||LA11_0==JMP||LA11_0==LOOP||(LA11_0>=RET && LA11_0<=SJMP)||LA11_0==VAR))
						{
							alt11 = 1;
						}


						} finally { DebugExitDecision(11); }
						switch ( alt11 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:103: statement
							{
							DebugLocation(69, 103);
							PushFollow(Follow._statement_in_for_stat315);
							statement();
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop11;
						}
					}

					loop11:
						;

					} finally { DebugExitSubRule(11); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(69, 118);
				if (state.backtracking == 0)
				{
					emitter.EmitEndFor(i.Token, true);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:4: ^( LOOP DEC a= assign_var i= INT ^( SLIST ( statement )* ) )
				{
				DebugLocation(70, 4);
				DebugLocation(70, 6);
				Match(input,LOOP,Follow._LOOP_in_for_stat328); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(70, 11);
				Match(input,DEC,Follow._DEC_in_for_stat330); if (state.failed) return;
				DebugLocation(70, 16);
				PushFollow(Follow._assign_var_in_for_stat334);
				a=assign_var();
				PopFollow();
				if (state.failed) return;
				DebugLocation(70, 28);
				if (state.backtracking == 0)
				{
					 emitter.SetForInc(a); 
				}
				DebugLocation(70, 55);
				i=(CommonTree)Match(input,INT,Follow._INT_in_for_stat340); if (state.failed) return;
				DebugLocation(70, 60);
				DebugLocation(70, 62);
				Match(input,SLIST,Follow._SLIST_in_for_stat343); if (state.failed) return;

				DebugLocation(70, 68);
				if (state.backtracking == 0)
				{
					emitter.EmitInitFor(i.Token, false);
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(70, 108);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:108: ( statement )*
					try { DebugEnterSubRule(12);
					while (true)
					{
						int alt12=2;
						try { DebugEnterDecision(12, false);
						int LA12_0 = input.LA(1);

						if (((LA12_0>=ASGN && LA12_0<=CALL)||LA12_0==JMP||LA12_0==LOOP||(LA12_0>=RET && LA12_0<=SJMP)||LA12_0==VAR))
						{
							alt12 = 1;
						}


						} finally { DebugExitDecision(12); }
						switch ( alt12 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:108: statement
							{
							DebugLocation(70, 108);
							PushFollow(Follow._statement_in_for_stat347);
							statement();
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop12;
						}
					}

					loop12:
						;

					} finally { DebugExitSubRule(12); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(70, 122);
				if (state.backtracking == 0)
				{
					emitter.EmitEndFor(i.Token, false);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:4: ^( LOOP a= assign_var i= ID ^( SLIST ( statement )* ) )
				{
				DebugLocation(71, 4);
				DebugLocation(71, 6);
				Match(input,LOOP,Follow._LOOP_in_for_stat359); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(71, 12);
				PushFollow(Follow._assign_var_in_for_stat363);
				a=assign_var();
				PopFollow();
				if (state.failed) return;
				DebugLocation(71, 24);
				if (state.backtracking == 0)
				{
					 emitter.SetForInc(a); 
				}
				DebugLocation(71, 51);
				i=(CommonTree)Match(input,ID,Follow._ID_in_for_stat369); if (state.failed) return;
				DebugLocation(71, 55);
				DebugLocation(71, 57);
				Match(input,SLIST,Follow._SLIST_in_for_stat372); if (state.failed) return;

				DebugLocation(71, 64);
				if (state.backtracking == 0)
				{
					emitter.EmitInitFor(i.Token, true);
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(71, 103);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:103: ( statement )*
					try { DebugEnterSubRule(13);
					while (true)
					{
						int alt13=2;
						try { DebugEnterDecision(13, false);
						int LA13_0 = input.LA(1);

						if (((LA13_0>=ASGN && LA13_0<=CALL)||LA13_0==JMP||LA13_0==LOOP||(LA13_0>=RET && LA13_0<=SJMP)||LA13_0==VAR))
						{
							alt13 = 1;
						}


						} finally { DebugExitDecision(13); }
						switch ( alt13 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:103: statement
							{
							DebugLocation(71, 103);
							PushFollow(Follow._statement_in_for_stat377);
							statement();
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop13;
						}
					}

					loop13:
						;

					} finally { DebugExitSubRule(13); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(71, 118);
				if (state.backtracking == 0)
				{
					emitter.EmitEndFor(i.Token, true);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:72:4: ^( LOOP DEC a= assign_var i= ID ^( SLIST ( statement )* ) )
				{
				DebugLocation(72, 4);
				DebugLocation(72, 6);
				Match(input,LOOP,Follow._LOOP_in_for_stat390); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(72, 11);
				Match(input,DEC,Follow._DEC_in_for_stat392); if (state.failed) return;
				DebugLocation(72, 16);
				PushFollow(Follow._assign_var_in_for_stat396);
				a=assign_var();
				PopFollow();
				if (state.failed) return;
				DebugLocation(72, 28);
				if (state.backtracking == 0)
				{
					 emitter.SetForInc(a); 
				}
				DebugLocation(72, 55);
				i=(CommonTree)Match(input,ID,Follow._ID_in_for_stat402); if (state.failed) return;
				DebugLocation(72, 59);
				DebugLocation(72, 61);
				Match(input,SLIST,Follow._SLIST_in_for_stat405); if (state.failed) return;

				DebugLocation(72, 67);
				if (state.backtracking == 0)
				{
					emitter.EmitInitFor(i.Token, false);
				}

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(72, 107);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:72:107: ( statement )*
					try { DebugEnterSubRule(14);
					while (true)
					{
						int alt14=2;
						try { DebugEnterDecision(14, false);
						int LA14_0 = input.LA(1);

						if (((LA14_0>=ASGN && LA14_0<=CALL)||LA14_0==JMP||LA14_0==LOOP||(LA14_0>=RET && LA14_0<=SJMP)||LA14_0==VAR))
						{
							alt14 = 1;
						}


						} finally { DebugExitDecision(14); }
						switch ( alt14 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:72:107: statement
							{
							DebugLocation(72, 107);
							PushFollow(Follow._statement_in_for_stat409);
							statement();
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							goto loop14;
						}
					}

					loop14:
						;

					} finally { DebugExitSubRule(14); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(72, 121);
				if (state.backtracking == 0)
				{
					emitter.EmitEndFor(i.Token, false);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("for_stat", 8);
			LeaveRule("for_stat", 8);
			LeaveRule_for_stat();
		}
		DebugLocation(73, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:76:1: while_stat : ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private void while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 9);
		TraceIn("while_stat", 9);
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(76, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:77:2: ( ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:77:5: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
			DebugLocation(77, 5);
			DebugLocation(77, 7);
			Match(input,LOOP,Follow._LOOP_in_while_stat431); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(77, 12);
			DebugLocation(77, 14);
			Match(input,LEXP,Follow._LEXP_in_while_stat434); if (state.failed) return;

			DebugLocation(77, 19);
			if (state.backtracking == 0)
			{
				emitter.EmitInitWhile();
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(77, 46);
			PushFollow(Follow._logic_expression_in_while_stat438);
			logic_expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(77, 64);
			DebugLocation(77, 66);
			Match(input,SLIST,Follow._SLIST_in_while_stat442); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(77, 73);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:77:73: ( statement )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_0 = input.LA(1);

					if (((LA16_0>=ASGN && LA16_0<=CALL)||LA16_0==JMP||LA16_0==LOOP||(LA16_0>=RET && LA16_0<=SJMP)||LA16_0==VAR))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:77:73: statement
						{
						DebugLocation(77, 73);
						PushFollow(Follow._statement_in_while_stat445);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(77, 86);
			if (state.backtracking == 0)
			{
				emitter.EmitEndWhile();
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("while_stat", 9);
			LeaveRule("while_stat", 9);
			LeaveRule_while_stat();
		}
		DebugLocation(79, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:81:1: repeat_stat : ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private void repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 10);
		TraceIn("repeat_stat", 10);
		 invertExp = false; 
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(81, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:84:2: ( ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:84:4: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
			DebugLocation(84, 4);
			DebugLocation(84, 6);
			Match(input,LOOP,Follow._LOOP_in_repeat_stat479); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(84, 11);
			DebugLocation(84, 13);
			Match(input,SLIST,Follow._SLIST_in_repeat_stat482); if (state.failed) return;

			DebugLocation(84, 19);
			if (state.backtracking == 0)
			{
				emitter.EmitInitRepeat();
			}

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(84, 47);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:84:47: ( statement )*
				try { DebugEnterSubRule(17);
				while (true)
				{
					int alt17=2;
					try { DebugEnterDecision(17, false);
					int LA17_0 = input.LA(1);

					if (((LA17_0>=ASGN && LA17_0<=CALL)||LA17_0==JMP||LA17_0==LOOP||(LA17_0>=RET && LA17_0<=SJMP)||LA17_0==VAR))
					{
						alt17 = 1;
					}


					} finally { DebugExitDecision(17); }
					switch ( alt17 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:84:47: statement
						{
						DebugLocation(84, 47);
						PushFollow(Follow._statement_in_repeat_stat486);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop17;
					}
				}

				loop17:
					;

				} finally { DebugExitSubRule(17); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}

			DebugLocation(84, 59);
			DebugLocation(84, 61);
			Match(input,LEXP,Follow._LEXP_in_repeat_stat491); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(84, 66);
			PushFollow(Follow._logic_expression_in_repeat_stat493);
			logic_expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(84, 85);
			if (state.backtracking == 0)
			{
				emitter.EmitEndRepeat();
			}

			}

			if (state.backtracking == 0)
			{
				 invertExp = true; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("repeat_stat", 10);
			LeaveRule("repeat_stat", 10);
			LeaveRule_repeat_stat();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_select_stat();
	partial void LeaveRule_select_stat();

	// $ANTLR start "select_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:88:1: select_stat : ^( SEL a= atom ( select_case )+ ) ;
	[GrammarRule("select_stat")]
	private void select_stat()
	{
		EnterRule_select_stat();
		EnterRule("select_stat", 11);
		TraceIn("select_stat", 11);
		object a = default(object);

		try { DebugEnterRule(GrammarFileName, "select_stat");
		DebugLocation(88, 84);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:89:2: ( ^( SEL a= atom ( select_case )+ ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:89:4: ^( SEL a= atom ( select_case )+ )
			{
			DebugLocation(89, 4);
			DebugLocation(89, 6);
			Match(input,SEL,Follow._SEL_in_select_stat511); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(89, 12);
			PushFollow(Follow._atom_in_select_stat516);
			a=atom();
			PopFollow();
			if (state.failed) return;
			DebugLocation(89, 18);
			if (state.backtracking == 0)
			{
				emitter.EmitInitSel(a); 
			}
			DebugLocation(89, 45);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:89:45: ( select_case )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==CASE))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:89:45: select_case
					{
					DebugLocation(89, 45);
					PushFollow(Follow._select_case_in_select_stat520);
					select_case();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(89, 60);
			if (state.backtracking == 0)
			{
				emitter.EmitEndSel(a); 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("select_stat", 11);
			LeaveRule("select_stat", 11);
			LeaveRule_select_stat();
		}
		DebugLocation(89, 84);
		} finally { DebugExitRule(GrammarFileName, "select_stat"); }
		return;

	}
	// $ANTLR end "select_stat"

	partial void EnterRule_select_case();
	partial void LeaveRule_select_case();

	// $ANTLR start "select_case"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:91:1: select_case : ^( CASE a= atom ( statement )* ) ;
	[GrammarRule("select_case")]
	private void select_case()
	{
		EnterRule_select_case();
		EnterRule("select_case", 12);
		TraceIn("select_case", 12);
		object a = default(object);

		try { DebugEnterRule(GrammarFileName, "select_case");
		DebugLocation(91, 82);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:92:2: ( ^( CASE a= atom ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:92:4: ^( CASE a= atom ( statement )* )
			{
			DebugLocation(92, 4);
			DebugLocation(92, 6);
			Match(input,CASE,Follow._CASE_in_select_case536); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(92, 13);
			PushFollow(Follow._atom_in_select_case541);
			a=atom();
			PopFollow();
			if (state.failed) return;
			DebugLocation(92, 19);
			if (state.backtracking == 0)
			{
				emitter.EmitCase(a); 
			}
			DebugLocation(92, 43);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:92:43: ( statement )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if (((LA19_0>=ASGN && LA19_0<=CALL)||LA19_0==JMP||LA19_0==LOOP||(LA19_0>=RET && LA19_0<=SJMP)||LA19_0==VAR))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:92:43: statement
					{
					DebugLocation(92, 43);
					PushFollow(Follow._statement_in_select_case545);
					statement();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(92, 54);
			if (state.backtracking == 0)
			{
				emitter.EmitEndCase(a); 
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("select_case", 12);
			LeaveRule("select_case", 12);
			LeaveRule_select_case();
		}
		DebugLocation(92, 82);
		} finally { DebugExitRule(GrammarFileName, "select_case"); }
		return;

	}
	// $ANTLR end "select_case"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:95:1: function_call : ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private void function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 13);
		TraceIn("function_call", 13);
		CommonTree ID2 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(95, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:96:2: ( ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:96:5: ^( CALL ID ( function_arg_list )* )
			{
			DebugLocation(96, 5);
			DebugLocation(96, 7);
			Match(input,CALL,Follow._CALL_in_function_call566); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(96, 12);
			ID2=(CommonTree)Match(input,ID,Follow._ID_in_function_call568); if (state.failed) return;
			DebugLocation(96, 15);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:96:15: ( function_arg_list )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==ARG))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:96:15: function_arg_list
					{
					DebugLocation(96, 15);
					PushFollow(Follow._function_arg_list_in_function_call570);
					function_arg_list();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(97, 3);
			if (state.backtracking == 0)
			{
				emitter.EmitCall(ID2.Token);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("function_call", 13);
			LeaveRule("function_call", 13);
			LeaveRule_function_call();
		}
		DebugLocation(98, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:100:1: property_call : ^( PCALL o= ID p= ID ) ;
	[GrammarRule("property_call")]
	private void property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 14);
		TraceIn("property_call", 14);
		CommonTree o = default(CommonTree);
		CommonTree p = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(100, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:101:2: ( ^( PCALL o= ID p= ID ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:101:5: ^( PCALL o= ID p= ID )
			{
			DebugLocation(101, 5);
			DebugLocation(101, 7);
			Match(input,PCALL,Follow._PCALL_in_property_call591); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(101, 14);
			o=(CommonTree)Match(input,ID,Follow._ID_in_property_call595); if (state.failed) return;
			DebugLocation(101, 19);
			p=(CommonTree)Match(input,ID,Follow._ID_in_property_call599); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(102, 3);
			if (state.backtracking == 0)
			{
				emitter.EmitPropCall(o.Token, p.Token);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("property_call", 14);
			LeaveRule("property_call", 14);
			LeaveRule_property_call();
		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:105:1: method_call : ^( MCALL o= ID p= ID ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private void method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 15);
		TraceIn("method_call", 15);
		CommonTree o = default(CommonTree);
		CommonTree p = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(105, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:106:2: ( ^( MCALL o= ID p= ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:106:5: ^( MCALL o= ID p= ID ( function_arg_list )* )
			{
			DebugLocation(106, 5);
			DebugLocation(106, 7);
			Match(input,MCALL,Follow._MCALL_in_method_call624); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(106, 14);
			o=(CommonTree)Match(input,ID,Follow._ID_in_method_call628); if (state.failed) return;
			DebugLocation(106, 19);
			p=(CommonTree)Match(input,ID,Follow._ID_in_method_call632); if (state.failed) return;
			DebugLocation(106, 23);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:106:23: ( function_arg_list )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==ARG))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:106:23: function_arg_list
					{
					DebugLocation(106, 23);
					PushFollow(Follow._function_arg_list_in_method_call634);
					function_arg_list();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(107, 3);
			if (state.backtracking == 0)
			{
				emitter.EmitMethodCall(o.Token, p.Token);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("method_call", 15);
			LeaveRule("method_call", 15);
			LeaveRule_method_call();
		}
		DebugLocation(108, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:110:1: function_arg_list : ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private void function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 16);
		TraceIn("function_arg_list", 16);
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(110, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:112:2: ( ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:112:4: ^( ARG ( plus_expression )* )
			{
			DebugLocation(112, 4);
			DebugLocation(112, 6);
			Match(input,ARG,Follow._ARG_in_function_arg_list661); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(112, 10);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:112:10: ( plus_expression )*
				try { DebugEnterSubRule(22);
				while (true)
				{
					int alt22=2;
					try { DebugEnterDecision(22, false);
					int LA22_0 = input.LA(1);

					if ((LA22_0==CALL||(LA22_0>=F && LA22_0<=FLOAT)||LA22_0==ID||LA22_0==INDEX||LA22_0==INT||LA22_0==MCALL||LA22_0==PCALL||(LA22_0>=STRING && LA22_0<=T)||LA22_0==43||(LA22_0>=46 && LA22_0<=47)||LA22_0==49||LA22_0==52))
					{
						alt22 = 1;
					}


					} finally { DebugExitDecision(22); }
					switch ( alt22 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:112:10: plus_expression
						{
						DebugLocation(112, 10);
						PushFollow(Follow._plus_expression_in_function_arg_list663);
						plus_expression();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop22;
					}
				}

				loop22:
					;

				} finally { DebugExitSubRule(22); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("function_arg_list", 16);
			LeaveRule("function_arg_list", 16);
			LeaveRule_function_arg_list();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_asm_code();
	partial void LeaveRule_asm_code();

	// $ANTLR start "asm_code"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:116:1: asm_code : ^( ASM (s+= STRING )* ) ;
	[GrammarRule("asm_code")]
	private void asm_code()
	{
		EnterRule_asm_code();
		EnterRule("asm_code", 17);
		TraceIn("asm_code", 17);
		CommonTree s = default(CommonTree);
		List<CommonTree> list_s = null;

		try { DebugEnterRule(GrammarFileName, "asm_code");
		DebugLocation(116, 8);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:116:9: ( ^( ASM (s+= STRING )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:116:11: ^( ASM (s+= STRING )* )
			{
			DebugLocation(116, 11);
			DebugLocation(116, 13);
			Match(input,ASM,Follow._ASM_in_asm_code679); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(116, 18);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:116:18: (s+= STRING )*
				try { DebugEnterSubRule(23);
				while (true)
				{
					int alt23=2;
					try { DebugEnterDecision(23, false);
					int LA23_0 = input.LA(1);

					if ((LA23_0==STRING))
					{
						alt23 = 1;
					}


					} finally { DebugExitDecision(23); }
					switch ( alt23 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:116:18: s+= STRING
						{
						DebugLocation(116, 18);
						s=(CommonTree)Match(input,STRING,Follow._STRING_in_asm_code683); if (state.failed) return;
						if (list_s==null) list_s=new List<CommonTree>();
						list_s.Add(s);


						}
						break;

					default:
						goto loop23;
					}
				}

				loop23:
					;

				} finally { DebugExitSubRule(23); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}

			DebugLocation(117, 3);
			if (state.backtracking == 0)
			{
				emitter.EmitAsmCode(list_s);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("asm_code", 17);
			LeaveRule("asm_code", 17);
			LeaveRule_asm_code();
		}
		DebugLocation(118, 8);
		} finally { DebugExitRule(GrammarFileName, "asm_code"); }
		return;

	}
	// $ANTLR end "asm_code"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:121:1: assign_var returns [string id] : ( ^( ASGN ID a= atom ) | ^( ASGN ^( AR INT ) ID plus_expression ) | ^( ASGN ^( AR i= ID ) p= ID plus_expression ) | ^( ASGN ID plus_expression ) | ^( ASGN ID 'nulo' ) | ^( ASGN ID 'falso' ) | ^( ASGN ID 'verdadeiro' ) | ^( ASGN ID l= INT r= INT ) | ^( ASGN ID ^( ILIST (i= INT )* ) ) );
	[GrammarRule("assign_var")]
	private string assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 18);
		TraceIn("assign_var", 18);
		string id = default(string);


		CommonTree i = default(CommonTree);
		CommonTree p = default(CommonTree);
		CommonTree l = default(CommonTree);
		CommonTree r = default(CommonTree);
		CommonTree ID3 = default(CommonTree);
		CommonTree ID4 = default(CommonTree);
		CommonTree INT5 = default(CommonTree);
		CommonTree ID6 = default(CommonTree);
		CommonTree ID7 = default(CommonTree);
		CommonTree ID8 = default(CommonTree);
		CommonTree ID9 = default(CommonTree);
		CommonTree ID10 = default(CommonTree);
		CommonTree ID11 = default(CommonTree);
		object a = default(object);

		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(121, 4);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:122:5: ( ^( ASGN ID a= atom ) | ^( ASGN ^( AR INT ) ID plus_expression ) | ^( ASGN ^( AR i= ID ) p= ID plus_expression ) | ^( ASGN ID plus_expression ) | ^( ASGN ID 'nulo' ) | ^( ASGN ID 'falso' ) | ^( ASGN ID 'verdadeiro' ) | ^( ASGN ID l= INT r= INT ) | ^( ASGN ID ^( ILIST (i= INT )* ) ) )
			int alt25=9;
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==ASGN))
			{
				int LA25_1 = input.LA(2);

				if ((LA25_1==DOWN))
				{
					int LA25_2 = input.LA(3);

					if ((LA25_2==ID))
					{
						int LA25_3 = input.LA(4);

						if ((EvaluatePredicate(synpred34_NPortugolWalker_fragment)))
						{
							alt25 = 1;
						}
						else if ((EvaluatePredicate(synpred37_NPortugolWalker_fragment)))
						{
							alt25 = 4;
						}
						else if ((EvaluatePredicate(synpred38_NPortugolWalker_fragment)))
						{
							alt25 = 5;
						}
						else if ((EvaluatePredicate(synpred39_NPortugolWalker_fragment)))
						{
							alt25 = 6;
						}
						else if ((EvaluatePredicate(synpred40_NPortugolWalker_fragment)))
						{
							alt25 = 7;
						}
						else if ((EvaluatePredicate(synpred41_NPortugolWalker_fragment)))
						{
							alt25 = 8;
						}
						else if ((true))
						{
							alt25 = 9;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return id;}
							NoViableAltException nvae = new NoViableAltException("", 25, 3, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA25_2==AR))
					{
						int LA25_4 = input.LA(4);

						if ((EvaluatePredicate(synpred35_NPortugolWalker_fragment)))
						{
							alt25 = 2;
						}
						else if ((EvaluatePredicate(synpred36_NPortugolWalker_fragment)))
						{
							alt25 = 3;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return id;}
							NoViableAltException nvae = new NoViableAltException("", 25, 4, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return id;}
						NoViableAltException nvae = new NoViableAltException("", 25, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return id;}
					NoViableAltException nvae = new NoViableAltException("", 25, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return id;}
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:123:7: ^( ASGN ID a= atom )
				{
				DebugLocation(123, 7);
				DebugLocation(123, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var724); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(123, 14);
				ID3=(CommonTree)Match(input,ID,Follow._ID_in_assign_var726); if (state.failed) return id;
				DebugLocation(123, 18);
				PushFollow(Follow._atom_in_assign_var730);
				a=atom();
				PopFollow();
				if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(123, 25);
				if (state.backtracking == 0)
				{
					id = (ID3!=null?ID3.Text:null); emitter.EmitAssign(ID3.Token, a);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:124:7: ^( ASGN ^( AR INT ) ID plus_expression )
				{
				DebugLocation(124, 7);
				DebugLocation(124, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var742); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(124, 14);
				DebugLocation(124, 16);
				Match(input,AR,Follow._AR_in_assign_var745); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(124, 19);
				INT5=(CommonTree)Match(input,INT,Follow._INT_in_assign_var747); if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(124, 24);
				ID4=(CommonTree)Match(input,ID,Follow._ID_in_assign_var750); if (state.failed) return id;
				DebugLocation(124, 27);
				PushFollow(Follow._plus_expression_in_assign_var752);
				plus_expression();
				PopFollow();
				if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(124, 44);
				if (state.backtracking == 0)
				{
					emitter.EmitPop(ID4.Token, int.Parse((INT5!=null?INT5.Text:null)));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:125:7: ^( ASGN ^( AR i= ID ) p= ID plus_expression )
				{
				DebugLocation(125, 7);
				DebugLocation(125, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var770); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(125, 14);
				DebugLocation(125, 16);
				Match(input,AR,Follow._AR_in_assign_var773); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(125, 20);
				i=(CommonTree)Match(input,ID,Follow._ID_in_assign_var777); if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(125, 26);
				p=(CommonTree)Match(input,ID,Follow._ID_in_assign_var782); if (state.failed) return id;
				DebugLocation(125, 30);
				PushFollow(Follow._plus_expression_in_assign_var784);
				plus_expression();
				PopFollow();
				if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(125, 47);
				if (state.backtracking == 0)
				{
					emitter.EmitPop(p.Token, (i!=null?i.Text:null));
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:126:7: ^( ASGN ID plus_expression )
				{
				DebugLocation(126, 7);
				DebugLocation(126, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var806); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(126, 14);
				ID6=(CommonTree)Match(input,ID,Follow._ID_in_assign_var808); if (state.failed) return id;
				DebugLocation(126, 17);
				PushFollow(Follow._plus_expression_in_assign_var810);
				plus_expression();
				PopFollow();
				if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(126, 34);
				if (state.backtracking == 0)
				{
					emitter.EmitPop(ID6.Token);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:127:7: ^( ASGN ID 'nulo' )
				{
				DebugLocation(127, 7);
				DebugLocation(127, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var823); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(127, 14);
				ID7=(CommonTree)Match(input,ID,Follow._ID_in_assign_var825); if (state.failed) return id;
				DebugLocation(127, 17);
				Match(input,82,Follow._82_in_assign_var827); if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(127, 25);
				if (state.backtracking == 0)
				{
					emitter.EmitAssign(ID7.Token, null);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:128:7: ^( ASGN ID 'falso' )
				{
				DebugLocation(128, 7);
				DebugLocation(128, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var840); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(128, 14);
				ID8=(CommonTree)Match(input,ID,Follow._ID_in_assign_var842); if (state.failed) return id;
				DebugLocation(128, 17);
				Match(input,81,Follow._81_in_assign_var844); if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(128, 26);
				if (state.backtracking == 0)
				{
					emitter.EmitAssign(ID8.Token, false);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:129:7: ^( ASGN ID 'verdadeiro' )
				{
				DebugLocation(129, 7);
				DebugLocation(129, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var857); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(129, 14);
				ID9=(CommonTree)Match(input,ID,Follow._ID_in_assign_var859); if (state.failed) return id;
				DebugLocation(129, 17);
				Match(input,83,Follow._83_in_assign_var861); if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(129, 31);
				if (state.backtracking == 0)
				{
					emitter.EmitAssign(ID9.Token, true);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:130:7: ^( ASGN ID l= INT r= INT )
				{
				DebugLocation(130, 7);
				DebugLocation(130, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var882); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(130, 14);
				ID10=(CommonTree)Match(input,ID,Follow._ID_in_assign_var884); if (state.failed) return id;
				DebugLocation(130, 18);
				l=(CommonTree)Match(input,INT,Follow._INT_in_assign_var888); if (state.failed) return id;
				DebugLocation(130, 24);
				r=(CommonTree)Match(input,INT,Follow._INT_in_assign_var892); if (state.failed) return id;

				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(130, 30);
				if (state.backtracking == 0)
				{
					emitter.EmitAssign(ID10.Token, int.Parse((l!=null?l.Text:null)), int.Parse((r!=null?r.Text:null)));
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:131:7: ^( ASGN ID ^( ILIST (i= INT )* ) )
				{
				DebugLocation(131, 7);
				DebugLocation(131, 9);
				Match(input,ASGN,Follow._ASGN_in_assign_var904); if (state.failed) return id;

				Match(input, TokenTypes.Down, null); if (state.failed) return id;
				DebugLocation(131, 14);
				ID11=(CommonTree)Match(input,ID,Follow._ID_in_assign_var906); if (state.failed) return id;
				DebugLocation(131, 17);
				DebugLocation(131, 19);
				Match(input,ILIST,Follow._ILIST_in_assign_var909); if (state.failed) return id;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return id;
					DebugLocation(131, 26);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:131:26: (i= INT )*
					try { DebugEnterSubRule(24);
					while (true)
					{
						int alt24=2;
						try { DebugEnterDecision(24, false);
						int LA24_0 = input.LA(1);

						if ((LA24_0==INT))
						{
							alt24 = 1;
						}


						} finally { DebugExitDecision(24); }
						switch ( alt24 )
						{
						case 1:
							DebugEnterAlt(1);
							// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:131:26: i= INT
							{
							DebugLocation(131, 26);
							i=(CommonTree)Match(input,INT,Follow._INT_in_assign_var913); if (state.failed) return id;

							}
							break;

						default:
							goto loop24;
						}
					}

					loop24:
						;

					} finally { DebugExitSubRule(24); }


					Match(input, TokenTypes.Up, null); if (state.failed) return id;
				}


				Match(input, TokenTypes.Up, null); if (state.failed) return id;

				DebugLocation(131, 34);
				if (state.backtracking == 0)
				{
					emitter.EmitAssignArray(ID11.Token, i);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assign_var", 18);
			LeaveRule("assign_var", 18);
			LeaveRule_assign_var();
		}
		DebugLocation(132, 4);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return id;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:134:1: return_stat : ^( RET plus_expression ) ;
	[GrammarRule("return_stat")]
	private void return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 19);
		TraceIn("return_stat", 19);
		CommonTree RET12 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(134, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:135:2: ( ^( RET plus_expression ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:135:5: ^( RET plus_expression )
			{
			DebugLocation(135, 5);
			DebugLocation(135, 7);
			RET12=(CommonTree)Match(input,RET,Follow._RET_in_return_stat936); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(135, 11);
			PushFollow(Follow._plus_expression_in_return_stat938);
			plus_expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(135, 27);
			if (state.backtracking == 0)
			{
				emitter.EmitRet(RET12.Token);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("return_stat", 19);
			LeaveRule("return_stat", 19);
			LeaveRule_return_stat();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:140:1: plus_expression : ( ^( '+' plus_expression plus_expression ) | ^( '-' plus_expression plus_expression ) | ^( '*' plus_expression plus_expression ) | ^( '/' plus_expression plus_expression ) | ^( '%' plus_expression plus_expression ) | ^( INDEX INT ) ID | ^( INDEX i2= ID ) i1= ID | function_call | method_call | property_call | atom );
	[GrammarRule("plus_expression")]
	private void plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 20);
		TraceIn("plus_expression", 20);
		CommonTree i2 = default(CommonTree);
		CommonTree i1 = default(CommonTree);
		CommonTree ID13 = default(CommonTree);
		CommonTree INT14 = default(CommonTree);

		 inExpression = true; 
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(140, 0);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:143:3: ( ^( '+' plus_expression plus_expression ) | ^( '-' plus_expression plus_expression ) | ^( '*' plus_expression plus_expression ) | ^( '/' plus_expression plus_expression ) | ^( '%' plus_expression plus_expression ) | ^( INDEX INT ) ID | ^( INDEX i2= ID ) i1= ID | function_call | method_call | property_call | atom )
			int alt26=11;
			try { DebugEnterDecision(26, false);
			switch (input.LA(1))
			{
			case 47:
				{
				alt26 = 1;
				}
				break;
			case 49:
				{
				alt26 = 2;
				}
				break;
			case 46:
				{
				alt26 = 3;
				}
				break;
			case 52:
				{
				alt26 = 4;
				}
				break;
			case 43:
				{
				alt26 = 5;
				}
				break;
			case INDEX:
				{
				int LA26_6 = input.LA(2);

				if ((LA26_6==DOWN))
				{
					int LA26_16 = input.LA(3);

					if ((LA26_16==INT))
					{
						alt26 = 6;
					}
					else if ((LA26_16==ID))
					{
						alt26 = 7;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 26, 16, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 26, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CALL:
				{
				alt26 = 8;
				}
				break;
			case MCALL:
				{
				alt26 = 9;
				}
				break;
			case PCALL:
				{
				alt26 = 10;
				}
				break;
			case F:
			case FLOAT:
			case ID:
			case INT:
			case STRING:
			case T:
				{
				alt26 = 11;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:143:3: ^( '+' plus_expression plus_expression )
				{
				DebugLocation(143, 3);
				DebugLocation(143, 5);
				Match(input,47,Follow._47_in_plus_expression963); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(143, 9);
				PushFollow(Follow._plus_expression_in_plus_expression965);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(143, 25);
				PushFollow(Follow._plus_expression_in_plus_expression967);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(143, 42);
				if (state.backtracking == 0)
				{
					emitter.EmitStackAdd();
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:144:3: ^( '-' plus_expression plus_expression )
				{
				DebugLocation(144, 3);
				DebugLocation(144, 5);
				Match(input,49,Follow._49_in_plus_expression975); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(144, 9);
				PushFollow(Follow._plus_expression_in_plus_expression977);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(144, 25);
				PushFollow(Follow._plus_expression_in_plus_expression979);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(144, 42);
				if (state.backtracking == 0)
				{
					emitter.EmitStackSub();
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:145:3: ^( '*' plus_expression plus_expression )
				{
				DebugLocation(145, 3);
				DebugLocation(145, 5);
				Match(input,46,Follow._46_in_plus_expression987); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(145, 9);
				PushFollow(Follow._plus_expression_in_plus_expression989);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(145, 25);
				PushFollow(Follow._plus_expression_in_plus_expression991);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(145, 42);
				if (state.backtracking == 0)
				{
					emitter.EmitStackPlus();
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:146:3: ^( '/' plus_expression plus_expression )
				{
				DebugLocation(146, 3);
				DebugLocation(146, 5);
				Match(input,52,Follow._52_in_plus_expression999); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(146, 9);
				PushFollow(Follow._plus_expression_in_plus_expression1001);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(146, 25);
				PushFollow(Follow._plus_expression_in_plus_expression1003);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(146, 42);
				if (state.backtracking == 0)
				{
					emitter.EmitStackDiv();
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:147:3: ^( '%' plus_expression plus_expression )
				{
				DebugLocation(147, 3);
				DebugLocation(147, 5);
				Match(input,43,Follow._43_in_plus_expression1011); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(147, 9);
				PushFollow(Follow._plus_expression_in_plus_expression1013);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(147, 25);
				PushFollow(Follow._plus_expression_in_plus_expression1015);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(147, 42);
				if (state.backtracking == 0)
				{
					emitter.EmitStackMod();
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:148:3: ^( INDEX INT ) ID
				{
				DebugLocation(148, 3);
				DebugLocation(148, 5);
				Match(input,INDEX,Follow._INDEX_in_plus_expression1023); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(148, 11);
				INT14=(CommonTree)Match(input,INT,Follow._INT_in_plus_expression1025); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(148, 16);
				ID13=(CommonTree)Match(input,ID,Follow._ID_in_plus_expression1028); if (state.failed) return;
				DebugLocation(148, 19);
				if (state.backtracking == 0)
				{
					emitter.EmitPush((ID13!=null?ID13.Text:null), int.Parse((INT14!=null?INT14.Text:null)));
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:149:3: ^( INDEX i2= ID ) i1= ID
				{
				DebugLocation(149, 3);
				DebugLocation(149, 5);
				Match(input,INDEX,Follow._INDEX_in_plus_expression1035); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(149, 13);
				i2=(CommonTree)Match(input,ID,Follow._ID_in_plus_expression1039); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(149, 20);
				i1=(CommonTree)Match(input,ID,Follow._ID_in_plus_expression1044); if (state.failed) return;
				DebugLocation(149, 24);
				if (state.backtracking == 0)
				{
					emitter.EmitPush((i1!=null?i1.Text:null), (i2!=null?i2.Text:null));
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:150:3: function_call
				{
				DebugLocation(150, 3);
				PushFollow(Follow._function_call_in_plus_expression1050);
				function_call();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:151:3: method_call
				{
				DebugLocation(151, 3);
				PushFollow(Follow._method_call_in_plus_expression1054);
				method_call();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:152:3: property_call
				{
				DebugLocation(152, 3);
				PushFollow(Follow._property_call_in_plus_expression1058);
				property_call();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:153:3: atom
				{
				DebugLocation(153, 3);
				PushFollow(Follow._atom_in_plus_expression1062);
				atom();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			if (state.backtracking == 0)
			{
				 inExpression = false; 
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("plus_expression", 20);
			LeaveRule("plus_expression", 20);
			LeaveRule_plus_expression();
		}
		DebugLocation(154, 0);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:156:1: logic_expression : ( ^( '<' plus_expression plus_expression ) | ^( '>' plus_expression plus_expression ) | ^( '<=' plus_expression plus_expression ) | ^( '>=' plus_expression plus_expression ) | ^( '==' plus_expression plus_expression ) | ^( '!=' plus_expression plus_expression ) | ^( 'e' plus_expression plus_expression ) | ^( 'ou' plus_expression plus_expression ) | plus_expression );
	[GrammarRule("logic_expression")]
	private void logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 21);
		TraceIn("logic_expression", 21);
		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(156, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:157:2: ( ^( '<' plus_expression plus_expression ) | ^( '>' plus_expression plus_expression ) | ^( '<=' plus_expression plus_expression ) | ^( '>=' plus_expression plus_expression ) | ^( '==' plus_expression plus_expression ) | ^( '!=' plus_expression plus_expression ) | ^( 'e' plus_expression plus_expression ) | ^( 'ou' plus_expression plus_expression ) | plus_expression )
			int alt27=9;
			try { DebugEnterDecision(27, false);
			switch (input.LA(1))
			{
			case 55:
				{
				alt27 = 1;
				}
				break;
			case 59:
				{
				alt27 = 2;
				}
				break;
			case 56:
				{
				alt27 = 3;
				}
				break;
			case 60:
				{
				alt27 = 4;
				}
				break;
			case 58:
				{
				alt27 = 5;
				}
				break;
			case 41:
				{
				alt27 = 6;
				}
				break;
			case 66:
				{
				alt27 = 7;
				}
				break;
			case 71:
				{
				alt27 = 8;
				}
				break;
			case CALL:
			case F:
			case FLOAT:
			case ID:
			case INDEX:
			case INT:
			case MCALL:
			case PCALL:
			case STRING:
			case T:
			case 43:
			case 46:
			case 47:
			case 49:
			case 52:
				{
				alt27 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:157:6: ^( '<' plus_expression plus_expression )
				{
				DebugLocation(157, 6);
				DebugLocation(157, 8);
				Match(input,55,Follow._55_in_logic_expression1075); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(157, 12);
				PushFollow(Follow._plus_expression_in_logic_expression1077);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(157, 28);
				PushFollow(Follow._plus_expression_in_logic_expression1079);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(157, 45);
				if (state.backtracking == 0)
				{
					emitter.EmitLessExp(invertExp);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:158:6: ^( '>' plus_expression plus_expression )
				{
				DebugLocation(158, 6);
				DebugLocation(158, 8);
				Match(input,59,Follow._59_in_logic_expression1090); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(158, 12);
				PushFollow(Follow._plus_expression_in_logic_expression1092);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(158, 28);
				PushFollow(Follow._plus_expression_in_logic_expression1094);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(158, 45);
				if (state.backtracking == 0)
				{
					emitter.EmitGreaterExp(invertExp);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:159:6: ^( '<=' plus_expression plus_expression )
				{
				DebugLocation(159, 6);
				DebugLocation(159, 8);
				Match(input,56,Follow._56_in_logic_expression1105); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(159, 13);
				PushFollow(Follow._plus_expression_in_logic_expression1107);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(159, 29);
				PushFollow(Follow._plus_expression_in_logic_expression1109);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(159, 46);
				if (state.backtracking == 0)
				{
					emitter.EmitLessEqExp(invertExp);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:160:6: ^( '>=' plus_expression plus_expression )
				{
				DebugLocation(160, 6);
				DebugLocation(160, 8);
				Match(input,60,Follow._60_in_logic_expression1120); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(160, 13);
				PushFollow(Follow._plus_expression_in_logic_expression1122);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(160, 29);
				PushFollow(Follow._plus_expression_in_logic_expression1124);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(160, 46);
				if (state.backtracking == 0)
				{
					emitter.EmitGreaterEqExp(invertExp);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:161:6: ^( '==' plus_expression plus_expression )
				{
				DebugLocation(161, 6);
				DebugLocation(161, 8);
				Match(input,58,Follow._58_in_logic_expression1135); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(161, 13);
				PushFollow(Follow._plus_expression_in_logic_expression1137);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(161, 29);
				PushFollow(Follow._plus_expression_in_logic_expression1139);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(161, 46);
				if (state.backtracking == 0)
				{
					emitter.EmitEqualsExp(invertExp);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:162:6: ^( '!=' plus_expression plus_expression )
				{
				DebugLocation(162, 6);
				DebugLocation(162, 8);
				Match(input,41,Follow._41_in_logic_expression1150); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(162, 13);
				PushFollow(Follow._plus_expression_in_logic_expression1152);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(162, 29);
				PushFollow(Follow._plus_expression_in_logic_expression1154);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(162, 46);
				if (state.backtracking == 0)
				{
					emitter.EmitNotEqExp(invertExp);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:163:6: ^( 'e' plus_expression plus_expression )
				{
				DebugLocation(163, 6);
				DebugLocation(163, 8);
				Match(input,66,Follow._66_in_logic_expression1165); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(163, 12);
				PushFollow(Follow._plus_expression_in_logic_expression1167);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(163, 28);
				PushFollow(Follow._plus_expression_in_logic_expression1169);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:164:6: ^( 'ou' plus_expression plus_expression )
				{
				DebugLocation(164, 6);
				DebugLocation(164, 8);
				Match(input,71,Follow._71_in_logic_expression1178); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(164, 13);
				PushFollow(Follow._plus_expression_in_logic_expression1180);
				plus_expression();
				PopFollow();
				if (state.failed) return;
				DebugLocation(164, 29);
				PushFollow(Follow._plus_expression_in_logic_expression1182);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:165:4: plus_expression
				{
				DebugLocation(165, 4);
				PushFollow(Follow._plus_expression_in_logic_expression1194);
				plus_expression();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logic_expression", 21);
			LeaveRule("logic_expression", 21);
			LeaveRule_logic_expression();
		}
		DebugLocation(166, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:170:1: atom returns [object value] : (a= ID |a= INT |a= FLOAT |a= STRING |a= T |a= F );
	[GrammarRule("atom")]
	private object atom()
	{
		EnterRule_atom();
		EnterRule("atom", 22);
		TraceIn("atom", 22);
		object value = default(object);


		CommonTree a = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(170, 4);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:170:27: (a= ID |a= INT |a= FLOAT |a= STRING |a= T |a= F )
			int alt28=6;
			try { DebugEnterDecision(28, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt28 = 1;
				}
				break;
			case INT:
				{
				alt28 = 2;
				}
				break;
			case FLOAT:
				{
				alt28 = 3;
				}
				break;
			case STRING:
				{
				alt28 = 4;
				}
				break;
			case T:
				{
				alt28 = 5;
				}
				break;
			case F:
				{
				alt28 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return value;}
					NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:171:7: a= ID
				{
				DebugLocation(171, 8);
				a=(CommonTree)Match(input,ID,Follow._ID_in_atom1222); if (state.failed) return value;
				DebugLocation(171, 12);
				if (state.backtracking == 0)
				{
					value = (a!=null?a.Text:null); emitter.EmitPush(value, a.Token);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:172:7: a= INT
				{
				DebugLocation(172, 8);
				a=(CommonTree)Match(input,INT,Follow._INT_in_atom1234); if (state.failed) return value;
				DebugLocation(172, 12);
				if (state.backtracking == 0)
				{
					value = int.Parse((a!=null?a.Text:null));  emitter.EmitPush(value, a.Token);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:173:7: a= FLOAT
				{
				DebugLocation(173, 8);
				a=(CommonTree)Match(input,FLOAT,Follow._FLOAT_in_atom1245); if (state.failed) return value;
				DebugLocation(173, 14);
				if (state.backtracking == 0)
				{
					value = float.Parse((a!=null?a.Text:null).Replace(".",","));  emitter.EmitPush(value, a.Token);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:174:7: a= STRING
				{
				DebugLocation(174, 8);
				a=(CommonTree)Match(input,STRING,Follow._STRING_in_atom1256); if (state.failed) return value;
				DebugLocation(174, 15);
				if (state.backtracking == 0)
				{
					value = (a!=null?a.Text:null);  emitter.EmitPush(value, a.Token);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:175:7: a= T
				{
				DebugLocation(175, 8);
				a=(CommonTree)Match(input,T,Follow._T_in_atom1267); if (state.failed) return value;
				DebugLocation(175, 10);
				if (state.backtracking == 0)
				{
					value = (a!=null?a.Text:null);  emitter.EmitPush(true, a.Token);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:176:7: a= F
				{
				DebugLocation(176, 8);
				a=(CommonTree)Match(input,F,Follow._F_in_atom1282); if (state.failed) return value;
				DebugLocation(176, 10);
				if (state.backtracking == 0)
				{
					value = (a!=null?a.Text:null);  emitter.EmitPush(false, a.Token);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 22);
			LeaveRule("atom", 22);
			LeaveRule_atom();
		}
		DebugLocation(177, 4);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return value;

	}
	// $ANTLR end "atom"

	partial void EnterRule_synpred20_NPortugolWalker_fragment();
	partial void LeaveRule_synpred20_NPortugolWalker_fragment();

	// $ANTLR start synpred20_NPortugolWalker
	public void synpred20_NPortugolWalker_fragment()
	{
		CommonTree i = default(CommonTree);
		string a = default(string);

		EnterRule_synpred20_NPortugolWalker_fragment();
		EnterRule("synpred20_NPortugolWalker_fragment", 42);
		TraceIn("synpred20_NPortugolWalker_fragment", 42);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:3: ( ^( LOOP a= assign_var i= INT ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:3: ^( LOOP a= assign_var i= INT ^( SLIST ( statement )* ) )
			{
			DebugLocation(69, 3);
			DebugLocation(69, 5);
			Match(input,LOOP,Follow._LOOP_in_synpred20_NPortugolWalker297); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(69, 11);
			PushFollow(Follow._assign_var_in_synpred20_NPortugolWalker301);
			a=assign_var();
			PopFollow();
			if (state.failed) return;
			DebugLocation(69, 50);
			i=(CommonTree)Match(input,INT,Follow._INT_in_synpred20_NPortugolWalker307); if (state.failed) return;
			DebugLocation(69, 55);
			DebugLocation(69, 57);
			Match(input,SLIST,Follow._SLIST_in_synpred20_NPortugolWalker310); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(69, 103);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:103: ( statement )*
				try { DebugEnterSubRule(30);
				while (true)
				{
					int alt30=2;
					try { DebugEnterDecision(30, false);
					int LA30_0 = input.LA(1);

					if (((LA30_0>=ASGN && LA30_0<=CALL)||LA30_0==JMP||LA30_0==LOOP||(LA30_0>=RET && LA30_0<=SJMP)||LA30_0==VAR))
					{
						alt30 = 1;
					}


					} finally { DebugExitDecision(30); }
					switch ( alt30 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:69:103: statement
						{
						DebugLocation(69, 103);
						PushFollow(Follow._statement_in_synpred20_NPortugolWalker315);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop30;
					}
				}

				loop30:
					;

				} finally { DebugExitSubRule(30); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred20_NPortugolWalker_fragment", 42);
			LeaveRule("synpred20_NPortugolWalker_fragment", 42);
			LeaveRule_synpred20_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred20_NPortugolWalker

	partial void EnterRule_synpred22_NPortugolWalker_fragment();
	partial void LeaveRule_synpred22_NPortugolWalker_fragment();

	// $ANTLR start synpred22_NPortugolWalker
	public void synpred22_NPortugolWalker_fragment()
	{
		CommonTree i = default(CommonTree);
		string a = default(string);

		EnterRule_synpred22_NPortugolWalker_fragment();
		EnterRule("synpred22_NPortugolWalker_fragment", 44);
		TraceIn("synpred22_NPortugolWalker_fragment", 44);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:4: ( ^( LOOP DEC a= assign_var i= INT ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:4: ^( LOOP DEC a= assign_var i= INT ^( SLIST ( statement )* ) )
			{
			DebugLocation(70, 4);
			DebugLocation(70, 6);
			Match(input,LOOP,Follow._LOOP_in_synpred22_NPortugolWalker328); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(70, 11);
			Match(input,DEC,Follow._DEC_in_synpred22_NPortugolWalker330); if (state.failed) return;
			DebugLocation(70, 16);
			PushFollow(Follow._assign_var_in_synpred22_NPortugolWalker334);
			a=assign_var();
			PopFollow();
			if (state.failed) return;
			DebugLocation(70, 55);
			i=(CommonTree)Match(input,INT,Follow._INT_in_synpred22_NPortugolWalker340); if (state.failed) return;
			DebugLocation(70, 60);
			DebugLocation(70, 62);
			Match(input,SLIST,Follow._SLIST_in_synpred22_NPortugolWalker343); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(70, 108);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:108: ( statement )*
				try { DebugEnterSubRule(31);
				while (true)
				{
					int alt31=2;
					try { DebugEnterDecision(31, false);
					int LA31_0 = input.LA(1);

					if (((LA31_0>=ASGN && LA31_0<=CALL)||LA31_0==JMP||LA31_0==LOOP||(LA31_0>=RET && LA31_0<=SJMP)||LA31_0==VAR))
					{
						alt31 = 1;
					}


					} finally { DebugExitDecision(31); }
					switch ( alt31 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:70:108: statement
						{
						DebugLocation(70, 108);
						PushFollow(Follow._statement_in_synpred22_NPortugolWalker347);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop31;
					}
				}

				loop31:
					;

				} finally { DebugExitSubRule(31); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred22_NPortugolWalker_fragment", 44);
			LeaveRule("synpred22_NPortugolWalker_fragment", 44);
			LeaveRule_synpred22_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred22_NPortugolWalker

	partial void EnterRule_synpred24_NPortugolWalker_fragment();
	partial void LeaveRule_synpred24_NPortugolWalker_fragment();

	// $ANTLR start synpred24_NPortugolWalker
	public void synpred24_NPortugolWalker_fragment()
	{
		CommonTree i = default(CommonTree);
		string a = default(string);

		EnterRule_synpred24_NPortugolWalker_fragment();
		EnterRule("synpred24_NPortugolWalker_fragment", 46);
		TraceIn("synpred24_NPortugolWalker_fragment", 46);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:4: ( ^( LOOP a= assign_var i= ID ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:4: ^( LOOP a= assign_var i= ID ^( SLIST ( statement )* ) )
			{
			DebugLocation(71, 4);
			DebugLocation(71, 6);
			Match(input,LOOP,Follow._LOOP_in_synpred24_NPortugolWalker359); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(71, 12);
			PushFollow(Follow._assign_var_in_synpred24_NPortugolWalker363);
			a=assign_var();
			PopFollow();
			if (state.failed) return;
			DebugLocation(71, 51);
			i=(CommonTree)Match(input,ID,Follow._ID_in_synpred24_NPortugolWalker369); if (state.failed) return;
			DebugLocation(71, 55);
			DebugLocation(71, 57);
			Match(input,SLIST,Follow._SLIST_in_synpred24_NPortugolWalker372); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(71, 103);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:103: ( statement )*
				try { DebugEnterSubRule(32);
				while (true)
				{
					int alt32=2;
					try { DebugEnterDecision(32, false);
					int LA32_0 = input.LA(1);

					if (((LA32_0>=ASGN && LA32_0<=CALL)||LA32_0==JMP||LA32_0==LOOP||(LA32_0>=RET && LA32_0<=SJMP)||LA32_0==VAR))
					{
						alt32 = 1;
					}


					} finally { DebugExitDecision(32); }
					switch ( alt32 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:71:103: statement
						{
						DebugLocation(71, 103);
						PushFollow(Follow._statement_in_synpred24_NPortugolWalker377);
						statement();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop32;
					}
				}

				loop32:
					;

				} finally { DebugExitSubRule(32); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred24_NPortugolWalker_fragment", 46);
			LeaveRule("synpred24_NPortugolWalker_fragment", 46);
			LeaveRule_synpred24_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred24_NPortugolWalker

	partial void EnterRule_synpred34_NPortugolWalker_fragment();
	partial void LeaveRule_synpred34_NPortugolWalker_fragment();

	// $ANTLR start synpred34_NPortugolWalker
	public void synpred34_NPortugolWalker_fragment()
	{
		object a = default(object);

		EnterRule_synpred34_NPortugolWalker_fragment();
		EnterRule("synpred34_NPortugolWalker_fragment", 56);
		TraceIn("synpred34_NPortugolWalker_fragment", 56);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:123:7: ( ^( ASGN ID a= atom ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:123:7: ^( ASGN ID a= atom )
			{
			DebugLocation(123, 7);
			DebugLocation(123, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred34_NPortugolWalker724); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(123, 14);
			Match(input,ID,Follow._ID_in_synpred34_NPortugolWalker726); if (state.failed) return;
			DebugLocation(123, 18);
			PushFollow(Follow._atom_in_synpred34_NPortugolWalker730);
			a=atom();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred34_NPortugolWalker_fragment", 56);
			LeaveRule("synpred34_NPortugolWalker_fragment", 56);
			LeaveRule_synpred34_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred34_NPortugolWalker

	partial void EnterRule_synpred35_NPortugolWalker_fragment();
	partial void LeaveRule_synpred35_NPortugolWalker_fragment();

	// $ANTLR start synpred35_NPortugolWalker
	public void synpred35_NPortugolWalker_fragment()
	{
		EnterRule_synpred35_NPortugolWalker_fragment();
		EnterRule("synpred35_NPortugolWalker_fragment", 57);
		TraceIn("synpred35_NPortugolWalker_fragment", 57);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:124:7: ( ^( ASGN ^( AR INT ) ID plus_expression ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:124:7: ^( ASGN ^( AR INT ) ID plus_expression )
			{
			DebugLocation(124, 7);
			DebugLocation(124, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred35_NPortugolWalker742); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(124, 14);
			DebugLocation(124, 16);
			Match(input,AR,Follow._AR_in_synpred35_NPortugolWalker745); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(124, 19);
			Match(input,INT,Follow._INT_in_synpred35_NPortugolWalker747); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(124, 24);
			Match(input,ID,Follow._ID_in_synpred35_NPortugolWalker750); if (state.failed) return;
			DebugLocation(124, 27);
			PushFollow(Follow._plus_expression_in_synpred35_NPortugolWalker752);
			plus_expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred35_NPortugolWalker_fragment", 57);
			LeaveRule("synpred35_NPortugolWalker_fragment", 57);
			LeaveRule_synpred35_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred35_NPortugolWalker

	partial void EnterRule_synpred36_NPortugolWalker_fragment();
	partial void LeaveRule_synpred36_NPortugolWalker_fragment();

	// $ANTLR start synpred36_NPortugolWalker
	public void synpred36_NPortugolWalker_fragment()
	{
		CommonTree i = default(CommonTree);
		CommonTree p = default(CommonTree);

		EnterRule_synpred36_NPortugolWalker_fragment();
		EnterRule("synpred36_NPortugolWalker_fragment", 58);
		TraceIn("synpred36_NPortugolWalker_fragment", 58);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:125:7: ( ^( ASGN ^( AR i= ID ) p= ID plus_expression ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:125:7: ^( ASGN ^( AR i= ID ) p= ID plus_expression )
			{
			DebugLocation(125, 7);
			DebugLocation(125, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred36_NPortugolWalker770); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(125, 14);
			DebugLocation(125, 16);
			Match(input,AR,Follow._AR_in_synpred36_NPortugolWalker773); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(125, 20);
			i=(CommonTree)Match(input,ID,Follow._ID_in_synpred36_NPortugolWalker777); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(125, 26);
			p=(CommonTree)Match(input,ID,Follow._ID_in_synpred36_NPortugolWalker782); if (state.failed) return;
			DebugLocation(125, 30);
			PushFollow(Follow._plus_expression_in_synpred36_NPortugolWalker784);
			plus_expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred36_NPortugolWalker_fragment", 58);
			LeaveRule("synpred36_NPortugolWalker_fragment", 58);
			LeaveRule_synpred36_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred36_NPortugolWalker

	partial void EnterRule_synpred37_NPortugolWalker_fragment();
	partial void LeaveRule_synpred37_NPortugolWalker_fragment();

	// $ANTLR start synpred37_NPortugolWalker
	public void synpred37_NPortugolWalker_fragment()
	{
		EnterRule_synpred37_NPortugolWalker_fragment();
		EnterRule("synpred37_NPortugolWalker_fragment", 59);
		TraceIn("synpred37_NPortugolWalker_fragment", 59);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:126:7: ( ^( ASGN ID plus_expression ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:126:7: ^( ASGN ID plus_expression )
			{
			DebugLocation(126, 7);
			DebugLocation(126, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred37_NPortugolWalker806); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(126, 14);
			Match(input,ID,Follow._ID_in_synpred37_NPortugolWalker808); if (state.failed) return;
			DebugLocation(126, 17);
			PushFollow(Follow._plus_expression_in_synpred37_NPortugolWalker810);
			plus_expression();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred37_NPortugolWalker_fragment", 59);
			LeaveRule("synpred37_NPortugolWalker_fragment", 59);
			LeaveRule_synpred37_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred37_NPortugolWalker

	partial void EnterRule_synpred38_NPortugolWalker_fragment();
	partial void LeaveRule_synpred38_NPortugolWalker_fragment();

	// $ANTLR start synpred38_NPortugolWalker
	public void synpred38_NPortugolWalker_fragment()
	{
		EnterRule_synpred38_NPortugolWalker_fragment();
		EnterRule("synpred38_NPortugolWalker_fragment", 60);
		TraceIn("synpred38_NPortugolWalker_fragment", 60);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:127:7: ( ^( ASGN ID 'nulo' ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:127:7: ^( ASGN ID 'nulo' )
			{
			DebugLocation(127, 7);
			DebugLocation(127, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred38_NPortugolWalker823); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(127, 14);
			Match(input,ID,Follow._ID_in_synpred38_NPortugolWalker825); if (state.failed) return;
			DebugLocation(127, 17);
			Match(input,82,Follow._82_in_synpred38_NPortugolWalker827); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred38_NPortugolWalker_fragment", 60);
			LeaveRule("synpred38_NPortugolWalker_fragment", 60);
			LeaveRule_synpred38_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred38_NPortugolWalker

	partial void EnterRule_synpred39_NPortugolWalker_fragment();
	partial void LeaveRule_synpred39_NPortugolWalker_fragment();

	// $ANTLR start synpred39_NPortugolWalker
	public void synpred39_NPortugolWalker_fragment()
	{
		EnterRule_synpred39_NPortugolWalker_fragment();
		EnterRule("synpred39_NPortugolWalker_fragment", 61);
		TraceIn("synpred39_NPortugolWalker_fragment", 61);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:128:7: ( ^( ASGN ID 'falso' ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:128:7: ^( ASGN ID 'falso' )
			{
			DebugLocation(128, 7);
			DebugLocation(128, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred39_NPortugolWalker840); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(128, 14);
			Match(input,ID,Follow._ID_in_synpred39_NPortugolWalker842); if (state.failed) return;
			DebugLocation(128, 17);
			Match(input,81,Follow._81_in_synpred39_NPortugolWalker844); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred39_NPortugolWalker_fragment", 61);
			LeaveRule("synpred39_NPortugolWalker_fragment", 61);
			LeaveRule_synpred39_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred39_NPortugolWalker

	partial void EnterRule_synpred40_NPortugolWalker_fragment();
	partial void LeaveRule_synpred40_NPortugolWalker_fragment();

	// $ANTLR start synpred40_NPortugolWalker
	public void synpred40_NPortugolWalker_fragment()
	{
		EnterRule_synpred40_NPortugolWalker_fragment();
		EnterRule("synpred40_NPortugolWalker_fragment", 62);
		TraceIn("synpred40_NPortugolWalker_fragment", 62);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:129:7: ( ^( ASGN ID 'verdadeiro' ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:129:7: ^( ASGN ID 'verdadeiro' )
			{
			DebugLocation(129, 7);
			DebugLocation(129, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred40_NPortugolWalker857); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(129, 14);
			Match(input,ID,Follow._ID_in_synpred40_NPortugolWalker859); if (state.failed) return;
			DebugLocation(129, 17);
			Match(input,83,Follow._83_in_synpred40_NPortugolWalker861); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred40_NPortugolWalker_fragment", 62);
			LeaveRule("synpred40_NPortugolWalker_fragment", 62);
			LeaveRule_synpred40_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred40_NPortugolWalker

	partial void EnterRule_synpred41_NPortugolWalker_fragment();
	partial void LeaveRule_synpred41_NPortugolWalker_fragment();

	// $ANTLR start synpred41_NPortugolWalker
	public void synpred41_NPortugolWalker_fragment()
	{
		CommonTree l = default(CommonTree);
		CommonTree r = default(CommonTree);

		EnterRule_synpred41_NPortugolWalker_fragment();
		EnterRule("synpred41_NPortugolWalker_fragment", 63);
		TraceIn("synpred41_NPortugolWalker_fragment", 63);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:130:7: ( ^( ASGN ID l= INT r= INT ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugolWalker.g:130:7: ^( ASGN ID l= INT r= INT )
			{
			DebugLocation(130, 7);
			DebugLocation(130, 9);
			Match(input,ASGN,Follow._ASGN_in_synpred41_NPortugolWalker882); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(130, 14);
			Match(input,ID,Follow._ID_in_synpred41_NPortugolWalker884); if (state.failed) return;
			DebugLocation(130, 18);
			l=(CommonTree)Match(input,INT,Follow._INT_in_synpred41_NPortugolWalker888); if (state.failed) return;
			DebugLocation(130, 24);
			r=(CommonTree)Match(input,INT,Follow._INT_in_synpred41_NPortugolWalker892); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred41_NPortugolWalker_fragment", 63);
			LeaveRule("synpred41_NPortugolWalker_fragment", 63);
			LeaveRule_synpred41_NPortugolWalker_fragment();
		}
	}
	// $ANTLR end synpred41_NPortugolWalker
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script62 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _FUNC_in_declare_function76 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_declare_function78 = new BitSet(new ulong[]{0x840000000UL});
		public static readonly BitSet _function_param_list_in_declare_function80 = new BitSet(new ulong[]{0x840000000UL});
		public static readonly BitSet _SLIST_in_declare_function84 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_declare_function86 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _declare_local_in_statement103 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement124 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _select_stat_in_statement129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement141 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement146 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _asm_code_in_statement151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARAM_in_function_param_list171 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_function_param_list175 = new BitSet(new ulong[]{0x80008UL});
		public static readonly BitSet _VAR_in_declare_local194 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_declare_local198 = new BitSet(new ulong[]{0x80008UL});
		public static readonly BitSet _SJMP_in_if_stat216 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _LEXP_in_if_stat219 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _logic_expression_in_if_stat221 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SLIST_in_if_stat225 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_if_stat227 = new BitSet(new ulong[]{0x8F050001C0UL});
		public static readonly BitSet _senao_stat_in_if_stat232 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _JMP_in_if_stat241 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _LEXP_in_if_stat244 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _logic_expression_in_if_stat246 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SLIST_in_if_stat250 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_if_stat252 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _SLIST_in_senao_stat271 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_senao_stat273 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_for_stat297 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _assign_var_in_for_stat301 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_for_stat307 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_for_stat310 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_for_stat315 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_for_stat328 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _DEC_in_for_stat330 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assign_var_in_for_stat334 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_for_stat340 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_for_stat343 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_for_stat347 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_for_stat359 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _assign_var_in_for_stat363 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_for_stat369 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_for_stat372 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_for_stat377 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_for_stat390 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _DEC_in_for_stat392 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assign_var_in_for_stat396 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_for_stat402 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_for_stat405 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_for_stat409 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_while_stat431 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _LEXP_in_while_stat434 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _logic_expression_in_while_stat438 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SLIST_in_while_stat442 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_while_stat445 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_repeat_stat479 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SLIST_in_repeat_stat482 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_repeat_stat486 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LEXP_in_repeat_stat491 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _logic_expression_in_repeat_stat493 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SEL_in_select_stat511 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _atom_in_select_stat516 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _select_case_in_select_stat520 = new BitSet(new ulong[]{0x208UL});
		public static readonly BitSet _CASE_in_select_case536 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _atom_in_select_case541 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _statement_in_select_case545 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _CALL_in_function_call566 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_function_call568 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _function_arg_list_in_function_call570 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _PCALL_in_property_call591 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_property_call595 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_property_call599 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MCALL_in_method_call624 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_method_call628 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_method_call632 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _function_arg_list_in_method_call634 = new BitSet(new ulong[]{0x28UL});
		public static readonly BitSet _ARG_in_function_arg_list661 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_function_arg_list663 = new BitSet(new ulong[]{0x12C83088A98108UL});
		public static readonly BitSet _ASM_in_asm_code679 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _STRING_in_asm_code683 = new BitSet(new ulong[]{0x1000000008UL});
		public static readonly BitSet _ASGN_in_assign_var724 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var726 = new BitSet(new ulong[]{0x3000898000UL});
		public static readonly BitSet _atom_in_assign_var730 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var742 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AR_in_assign_var745 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INT_in_assign_var747 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_assign_var750 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_assign_var752 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var770 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AR_in_assign_var773 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var777 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_assign_var782 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_assign_var784 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var806 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var808 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_assign_var810 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var823 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var825 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_assign_var827 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var840 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var842 = new BitSet(new ulong[]{0x0UL,0x20000UL});
		public static readonly BitSet _81_in_assign_var844 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var857 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var859 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_assign_var861 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var882 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var884 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_assign_var888 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_assign_var892 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_assign_var904 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_assign_var906 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _ILIST_in_assign_var909 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INT_in_assign_var913 = new BitSet(new ulong[]{0x800008UL});
		public static readonly BitSet _RET_in_return_stat936 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_return_stat938 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _47_in_plus_expression963 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_plus_expression965 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_plus_expression967 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _49_in_plus_expression975 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_plus_expression977 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_plus_expression979 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _46_in_plus_expression987 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_plus_expression989 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_plus_expression991 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _52_in_plus_expression999 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_plus_expression1001 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_plus_expression1003 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _43_in_plus_expression1011 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_plus_expression1013 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_plus_expression1015 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INDEX_in_plus_expression1023 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INT_in_plus_expression1025 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_plus_expression1028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INDEX_in_plus_expression1035 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_plus_expression1039 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_plus_expression1044 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_plus_expression1050 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_plus_expression1054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_plus_expression1058 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_plus_expression1062 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _55_in_logic_expression1075 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1077 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1079 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _59_in_logic_expression1090 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1092 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1094 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _56_in_logic_expression1105 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1107 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1109 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _60_in_logic_expression1120 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1122 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1124 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _58_in_logic_expression1135 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1137 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1139 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _41_in_logic_expression1150 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1152 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1154 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _66_in_logic_expression1165 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1167 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1169 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _71_in_logic_expression1178 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _plus_expression_in_logic_expression1180 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_logic_expression1182 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _plus_expression_in_logic_expression1194 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1222 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_atom1234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_atom1245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_atom1256 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _T_in_atom1267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_atom1282 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LOOP_in_synpred20_NPortugolWalker297 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _assign_var_in_synpred20_NPortugolWalker301 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred20_NPortugolWalker307 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_synpred20_NPortugolWalker310 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_synpred20_NPortugolWalker315 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_synpred22_NPortugolWalker328 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _DEC_in_synpred22_NPortugolWalker330 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assign_var_in_synpred22_NPortugolWalker334 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred22_NPortugolWalker340 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_synpred22_NPortugolWalker343 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_synpred22_NPortugolWalker347 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _LOOP_in_synpred24_NPortugolWalker359 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _assign_var_in_synpred24_NPortugolWalker363 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_synpred24_NPortugolWalker369 = new BitSet(new ulong[]{0x800000000UL});
		public static readonly BitSet _SLIST_in_synpred24_NPortugolWalker372 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _statement_in_synpred24_NPortugolWalker377 = new BitSet(new ulong[]{0x87050001C8UL});
		public static readonly BitSet _ASGN_in_synpred34_NPortugolWalker724 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred34_NPortugolWalker726 = new BitSet(new ulong[]{0x3000898000UL});
		public static readonly BitSet _atom_in_synpred34_NPortugolWalker730 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred35_NPortugolWalker742 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AR_in_synpred35_NPortugolWalker745 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _INT_in_synpred35_NPortugolWalker747 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_synpred35_NPortugolWalker750 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_synpred35_NPortugolWalker752 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred36_NPortugolWalker770 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AR_in_synpred36_NPortugolWalker773 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred36_NPortugolWalker777 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_synpred36_NPortugolWalker782 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_synpred36_NPortugolWalker784 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred37_NPortugolWalker806 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred37_NPortugolWalker808 = new BitSet(new ulong[]{0x12C83088A98100UL});
		public static readonly BitSet _plus_expression_in_synpred37_NPortugolWalker810 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred38_NPortugolWalker823 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred38_NPortugolWalker825 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _82_in_synpred38_NPortugolWalker827 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred39_NPortugolWalker840 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred39_NPortugolWalker842 = new BitSet(new ulong[]{0x0UL,0x20000UL});
		public static readonly BitSet _81_in_synpred39_NPortugolWalker844 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred40_NPortugolWalker857 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred40_NPortugolWalker859 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _83_in_synpred40_NPortugolWalker861 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASGN_in_synpred41_NPortugolWalker882 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_synpred41_NPortugolWalker884 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred41_NPortugolWalker888 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred41_NPortugolWalker892 = new BitSet(new ulong[]{0x8UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol
