//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g 2012-05-09 10:49:31

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

using System.Collections;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "CALL", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SJMP", "SLIST", "STRING", "UNICODE_ESC", "VAR", "WS", "'!='", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'ate'", "'dec'", "'e'", "'enquanto'", "'entao'", "'fim'", "'funcao'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'senao'", "'variavel'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__36=36;
	public const int T__37=37;
	public const int T__38=38;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int CALL=7;
	public const int CHAR=8;
	public const int DEC=9;
	public const int ESC_SEQ=10;
	public const int EXP=11;
	public const int EXPONENT=12;
	public const int FLOAT=13;
	public const int FUNC=14;
	public const int HEX_DIGIT=15;
	public const int ID=16;
	public const int ILIST=17;
	public const int INDEX=18;
	public const int INIT=19;
	public const int INT=20;
	public const int JMP=21;
	public const int LEXP=22;
	public const int LOOP=23;
	public const int MCALL=24;
	public const int NEWLINE=25;
	public const int OCTAL_ESC=26;
	public const int PARAM=27;
	public const int PCALL=28;
	public const int RET=29;
	public const int SJMP=30;
	public const int SLIST=31;
	public const int STRING=32;
	public const int UNICODE_ESC=33;
	public const int VAR=34;
	public const int WS=35;

	public NPortugolParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NPortugolParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g"; } }



		Stack<string> paraphrases = new Stack<string>();
		
	        public string GetErrorMessage(RecognitionException e)
	        {
	            string msg = "Erro na linha {0} posição {1}: '{2}'";
		    msg = string.Format(msg, e.Line, e.CharPositionInLine, e.Token.Text);
	            if (paraphrases.Count > 0){
	                string paraphrase = (string)paraphrases.Pop();
	                msg = msg + " " + paraphrase;
	            }
	            return msg;
	        }
		protected void mismatch(IIntStream input, int ttype, BitSet follow)	{
			throw new MismatchedTokenException(ttype, input);
		}
		public void recoverFromMismatchedSet(IIntStream input,RecognitionException e, BitSet follow) {
			throw e;
		}

		public List<string> Functions = new List<string>();
		public List<string> Symbols = new List<string>();	
		public bool IsDefinedID(string id){    return Symbols.Contains(id);}
		public bool IsDefined(string name) { return Functions.Contains(name); }
		public void DefineID(IList<IToken> ids){ foreach(var id in ids) { Symbols.Add(id.Text); }}
		public void DefineFunction(string name){ Functions.Add(name);}	


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:72:8: public script : ( declare_function )* ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<object, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_function1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(72, 33);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:72:15: ( ( declare_function )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:72:17: ( declare_function )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(72, 17);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:72:17: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==61))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:72:17: declare_function
					{
					DebugLocation(72, 17);
					PushFollow(Follow._declare_function_in_script144);
					declare_function1=declare_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declare_function1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(72, 33);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:74:1: declare_function : 'funcao' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private AstParserRuleReturnScope<object, IToken> declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken i = default(IToken);
		IToken string_literal2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken string_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_param_list4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);

		object i_tree = default(object);
		object string_literal2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal5_tree = default(object);
		object string_literal7_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_function_param_list=new RewriteRuleSubtreeStream(adaptor,"rule function_param_list");
		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(74, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:75:2: ( 'funcao' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:75:4: 'funcao' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim'
			{
			DebugLocation(75, 4);
			string_literal2=(IToken)Match(input,61,Follow._61_in_declare_function154); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_61.Add(string_literal2);

			DebugLocation(75, 14);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_function158); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			DebugLocation(75, 18);
			char_literal3=(IToken)Match(input,38,Follow._38_in_declare_function160); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_38.Add(char_literal3);

			DebugLocation(75, 22);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:75:22: ( function_param_list )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==ID))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:75:22: function_param_list
					{
					DebugLocation(75, 22);
					PushFollow(Follow._function_param_list_in_declare_function162);
					function_param_list4=function_param_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_param_list.Add(function_param_list4.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(75, 43);
			char_literal5=(IToken)Match(input,39,Follow._39_in_declare_function165); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal5);

			DebugLocation(75, 47);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:75:47: ( statement )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==ID||LA3_0==58||(LA3_0>=63 && LA3_0<=66)||LA3_0==68))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:75:47: statement
					{
					DebugLocation(75, 47);
					PushFollow(Follow._statement_in_declare_function167);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(75, 58);
			string_literal7=(IToken)Match(input,60,Follow._60_in_declare_function170); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_60.Add(string_literal7);

			DebugLocation(76, 3);
			if (state.backtracking == 0)
			{
				DefineFunction((i!=null?i.Text:null));
			}


			{
			// AST REWRITE
			// elements: function_param_list, statement, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 77:3: -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
				DebugLocation(77, 6);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:6: ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(77, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(77, 13);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(77, 16);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:16: ( function_param_list )*
				while ( stream_function_param_list.HasNext )
				{
					DebugLocation(77, 16);
					adaptor.AddChild(root_1, stream_function_param_list.NextTree());

				}
				stream_function_param_list.Reset();
				DebugLocation(77, 37);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:37: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(77, 39);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(77, 45);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:45: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(77, 45);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(78, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return retval;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_local8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_stat9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_stat10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> repeat_stat12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_call13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_var14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_stat15 = default(AstParserRuleReturnScope<object, IToken>);

		 paraphrases.Push("na sentença"); 
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(80, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:2: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat )
			int alt4=8;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case 68:
				{
				alt4 = 1;
				}
				break;
			case 66:
				{
				alt4 = 2;
				}
				break;
			case 63:
				{
				alt4 = 3;
				}
				break;
			case 58:
				{
				alt4 = 4;
				}
				break;
			case 64:
				{
				alt4 = 5;
				}
				break;
			case ID:
				{
				int LA4_6 = input.LA(2);

				if ((LA4_6==38))
				{
					alt4 = 6;
				}
				else if ((LA4_6==49||LA4_6==53))
				{
					alt4 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 65:
				{
				alt4 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:4: declare_local
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(82, 4);
				PushFollow(Follow._declare_local_in_statement217);
				declare_local8=declare_local();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declare_local8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:83:4: if_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._if_stat_in_statement223);
				if_stat9=if_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_stat9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:84:4: for_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._for_stat_in_statement229);
				for_stat10=for_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_stat10.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:85:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(85, 4);
				PushFollow(Follow._while_stat_in_statement234);
				while_stat11=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat11.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:86:4: repeat_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(86, 4);
				PushFollow(Follow._repeat_stat_in_statement239);
				repeat_stat12=repeat_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, repeat_stat12.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:87:4: function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._function_call_in_statement245);
				function_call13=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call13.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:88:4: assign_var
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._assign_var_in_statement251);
				assign_var14=assign_var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assign_var14.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:89:4: return_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._return_stat_in_statement257);
				return_stat15=return_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_stat15.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(90, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:92:1: function_param_list : ID ( ',' ID )* -> ^( PARAM ( ID )* ) ;
	[GrammarRule("function_param_list")]
	private AstParserRuleReturnScope<object, IToken> function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID16 = default(IToken);
		IToken char_literal17 = default(IToken);
		IToken ID18 = default(IToken);

		object ID16_tree = default(object);
		object char_literal17_tree = default(object);
		object ID18_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na lista de parâmetros"); 
		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(92, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:2: ( ID ( ',' ID )* -> ^( PARAM ( ID )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:4: ID ( ',' ID )*
			{
			DebugLocation(93, 4);
			ID16=(IToken)Match(input,ID,Follow._ID_in_function_param_list285); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID16);

			DebugLocation(93, 7);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:7: ( ',' ID )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==42))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:8: ',' ID
					{
					DebugLocation(93, 8);
					char_literal17=(IToken)Match(input,42,Follow._42_in_function_param_list288); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(char_literal17);

					DebugLocation(93, 12);
					ID18=(IToken)Match(input,ID,Follow._ID_in_function_param_list290); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID18);


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 93:17: -> ^( PARAM ( ID )* )
			{
				DebugLocation(93, 20);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:20: ^( PARAM ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(93, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(93, 28);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:28: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(93, 28);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return retval;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:103:1: declare_local : 'variavel' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) ;
	[GrammarRule("declare_local")]
	private AstParserRuleReturnScope<object, IToken> declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 5);
		TraceIn("declare_local", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal19 = default(IToken);
		IToken char_literal20 = default(IToken);
		IToken i = default(IToken);
		List<IToken> list_i = null;

		object string_literal19_tree = default(object);
		object char_literal20_tree = default(object);
		object i_tree = default(object);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na definição de variável"); 
		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(103, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:104:2: ( 'variavel' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:104:4: 'variavel' i+= ID ( ',' i+= ID )*
			{
			DebugLocation(104, 4);
			string_literal19=(IToken)Match(input,68,Follow._68_in_declare_local338); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(string_literal19);

			DebugLocation(104, 16);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_local342); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			if (list_i==null) list_i=new List<IToken>();
			list_i.Add(i);

			DebugLocation(104, 21);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:104:21: ( ',' i+= ID )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==42))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:104:22: ',' i+= ID
					{
					DebugLocation(104, 22);
					char_literal20=(IToken)Match(input,42,Follow._42_in_declare_local345); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(char_literal20);

					DebugLocation(104, 27);
					i=(IToken)Match(input,ID,Follow._ID_in_declare_local349); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(i);

					if (list_i==null) list_i=new List<IToken>();
					list_i.Add(i);


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(105, 4);
			if (state.backtracking == 0)
			{
				DefineID(list_i);
			}


			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 106:2: -> ^( VAR ( ID )* )
			{
				DebugLocation(106, 5);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:106:5: ^( VAR ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(106, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(106, 11);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:106:11: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(106, 11);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("declare_local", 5);
			LeaveRule("declare_local", 5);
			LeaveRule_declare_local();
		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return retval;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:114:1: if_stat : 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) ;
	[GrammarRule("if_stat")]
	private AstParserRuleReturnScope<object, IToken> if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 6);
		TraceIn("if_stat", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal21 = default(IToken);
		IToken string_literal22 = default(IToken);
		IToken string_literal23 = default(IToken);
		List<object> list_s1 = null;
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s1 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal21_tree = default(object);
		object string_literal22_tree = default(object);
		object string_literal23_tree = default(object);
		RewriteRuleITokenStream stream_66=new RewriteRuleITokenStream(adaptor,"token 66");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		RewriteRuleSubtreeStream stream_senao_stat=new RewriteRuleSubtreeStream(adaptor,"rule senao_stat");
		 paraphrases.Push("se"); 
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(114, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:116:2: ( 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:116:4: 'se' p= logic_expression 'entao' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			{
			DebugLocation(116, 4);
			string_literal21=(IToken)Match(input,66,Follow._66_in_if_stat395); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_66.Add(string_literal21);

			DebugLocation(116, 10);
			PushFollow(Follow._logic_expression_in_if_stat399);
			p=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(p.Tree);
			DebugLocation(116, 28);
			string_literal22=(IToken)Match(input,59,Follow._59_in_if_stat401); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(string_literal22);

			DebugLocation(116, 38);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:116:38: (s1+= statement )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ID||LA7_0==58||(LA7_0>=63 && LA7_0<=66)||LA7_0==68))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:116:38: s1+= statement
					{
					DebugLocation(116, 38);
					PushFollow(Follow._statement_in_if_stat405);
					s1=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s1.Tree);
					if (list_s1==null) list_s1=new List<object>();
					list_s1.Add(s1.Tree);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(117, 2);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:117:2: (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==67))
			{
				alt8 = 1;
			}
			else if ((LA8_0==60))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:117:4: s2= senao_stat
				{
				DebugLocation(117, 6);
				PushFollow(Follow._senao_stat_in_if_stat413);
				s2=senao_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_senao_stat.Add(s2.Tree);


				{
				// AST REWRITE
				// elements: s1, p, s2
				// token labels: 
				// rule labels: retval, s2, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s2=new RewriteRuleSubtreeStream(adaptor,"rule s2",s2!=null?s2.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 117:18: -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
				{
					DebugLocation(117, 21);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:117:21: ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(117, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SJMP, "SJMP"), root_1);

					DebugLocation(117, 28);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:117:28: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(117, 30);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(117, 36);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(117, 39);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:117:39: ^( SLIST $s1 $s2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(117, 41);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(117, 48);
					adaptor.AddChild(root_2, stream_s1.NextTree());
					DebugLocation(117, 52);
					adaptor.AddChild(root_2, stream_s2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:118:4: 'fim'
				{
				DebugLocation(118, 4);
				string_literal23=(IToken)Match(input,60,Follow._60_in_if_stat441); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_60.Add(string_literal23);



				{
				// AST REWRITE
				// elements: s1, p
				// token labels: 
				// rule labels: retval, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 118:10: -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
				{
					DebugLocation(118, 13);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:118:13: ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(118, 15);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(JMP, "JMP"), root_1);

					DebugLocation(118, 19);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:118:19: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(118, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(118, 27);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(118, 30);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:118:30: ^( SLIST ( $s1)* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(118, 32);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(118, 39);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:118:39: ( $s1)*
					while ( stream_s1.HasNext )
					{
						DebugLocation(118, 39);
						adaptor.AddChild(root_2, stream_s1.NextTree());

					}
					stream_s1.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("if_stat", 6);
			LeaveRule("if_stat", 6);
			LeaveRule_if_stat();
		}
		DebugLocation(120, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return retval;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:122:1: senao_stat : 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private AstParserRuleReturnScope<object, IToken> senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 7);
		TraceIn("senao_stat", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal24 = default(IToken);
		IToken string_literal25 = default(IToken);
		List<object> list_s2 = null;
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal24_tree = default(object);
		object string_literal25_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(122, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:2: ( 'senao' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:4: 'senao' (s2+= statement )* 'fim'
			{
			DebugLocation(123, 4);
			string_literal24=(IToken)Match(input,67,Follow._67_in_senao_stat477); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal24);

			DebugLocation(123, 14);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:14: (s2+= statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==ID||LA9_0==58||(LA9_0>=63 && LA9_0<=66)||LA9_0==68))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:14: s2+= statement
					{
					DebugLocation(123, 14);
					PushFollow(Follow._statement_in_senao_stat481);
					s2=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s2.Tree);
					if (list_s2==null) list_s2=new List<object>();
					list_s2.Add(s2.Tree);


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(123, 27);
			string_literal25=(IToken)Match(input,60,Follow._60_in_senao_stat484); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_60.Add(string_literal25);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 123:33: -> ^( SLIST ( statement )* )
			{
				DebugLocation(123, 36);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:36: ^( SLIST ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(123, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_1);

				DebugLocation(123, 44);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:44: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(123, 44);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("senao_stat", 7);
			LeaveRule("senao_stat", 7);
			LeaveRule_senao_stat();
		}
		DebugLocation(124, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return retval;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:1: for_stat : 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) ;
	[GrammarRule("for_stat")]
	private AstParserRuleReturnScope<object, IToken> for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 8);
		TraceIn("for_stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal26 = default(IToken);
		IToken string_literal28 = default(IToken);
		IToken string_literal30 = default(IToken);
		IToken string_literal32 = default(IToken);
		IToken string_literal34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_var27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement33 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal26_tree = default(object);
		object string_literal28_tree = default(object);
		object string_literal30_tree = default(object);
		object string_literal32_tree = default(object);
		object string_literal34_tree = default(object);
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		RewriteRuleSubtreeStream stream_assign_var=new RewriteRuleSubtreeStream(adaptor,"rule assign_var");
		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(126, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:9: ( 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:11: 'para' assign_var 'ate' index ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			{
			DebugLocation(126, 11);
			string_literal26=(IToken)Match(input,63,Follow._63_in_for_stat504); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal26);

			DebugLocation(126, 18);
			PushFollow(Follow._assign_var_in_for_stat506);
			assign_var27=assign_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_var.Add(assign_var27.Tree);
			DebugLocation(126, 29);
			string_literal28=(IToken)Match(input,55,Follow._55_in_for_stat508); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_55.Add(string_literal28);

			DebugLocation(126, 35);
			PushFollow(Follow._index_in_for_stat510);
			index29=index();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index.Add(index29.Tree);
			DebugLocation(128, 3);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:3: ( 'dec' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==56))
			{
				alt12 = 1;
			}
			else if ((LA12_0==ID||LA12_0==58||LA12_0==60||(LA12_0>=63 && LA12_0<=66)||LA12_0==68))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:5: 'dec' ( statement )* 'fim'
				{
				DebugLocation(128, 5);
				string_literal30=(IToken)Match(input,56,Follow._56_in_for_stat518); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_56.Add(string_literal30);

				DebugLocation(128, 11);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:11: ( statement )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if ((LA10_0==ID||LA10_0==58||(LA10_0>=63 && LA10_0<=66)||LA10_0==68))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:11: statement
						{
						DebugLocation(128, 11);
						PushFollow(Follow._statement_in_for_stat520);
						statement31=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement31.Tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(128, 22);
				string_literal32=(IToken)Match(input,60,Follow._60_in_for_stat523); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_60.Add(string_literal32);



				{
				// AST REWRITE
				// elements: index, assign_var, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 128:28: -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(128, 31);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:31: ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(128, 33);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(128, 38);
					adaptor.AddChild(root_1, (object)adaptor.Create(DEC, "DEC"));
					DebugLocation(128, 42);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(128, 53);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(128, 59);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:59: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(128, 61);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(128, 67);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:67: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(128, 67);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:5: ( statement )* 'fim'
				{
				DebugLocation(129, 5);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:5: ( statement )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==ID||LA11_0==58||(LA11_0>=63 && LA11_0<=66)||LA11_0==68))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:5: statement
						{
						DebugLocation(129, 5);
						PushFollow(Follow._statement_in_for_stat548);
						statement33=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement33.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(129, 16);
				string_literal34=(IToken)Match(input,60,Follow._60_in_for_stat551); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_60.Add(string_literal34);



				{
				// AST REWRITE
				// elements: index, assign_var, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 129:22: -> ^( LOOP assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(129, 25);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:25: ^( LOOP assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(129, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(129, 32);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(129, 43);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(129, 49);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:49: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(129, 51);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(129, 57);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:57: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(129, 57);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("for_stat", 8);
			LeaveRule("for_stat", 8);
			LeaveRule_for_stat();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return retval;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:133:1: while_stat : 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 9);
		TraceIn("while_stat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal35 = default(IToken);
		IToken string_literal38 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_expression36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement37 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal35_tree = default(object);
		object string_literal38_tree = default(object);
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(133, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:2: ( 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:4: 'enquanto' logic_expression ( statement )* 'fim'
			{
			DebugLocation(134, 4);
			string_literal35=(IToken)Match(input,58,Follow._58_in_while_stat584); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_58.Add(string_literal35);

			DebugLocation(134, 15);
			PushFollow(Follow._logic_expression_in_while_stat586);
			logic_expression36=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression36.Tree);
			DebugLocation(134, 32);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:32: ( statement )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==ID||LA13_0==58||(LA13_0>=63 && LA13_0<=66)||LA13_0==68))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:32: statement
					{
					DebugLocation(134, 32);
					PushFollow(Follow._statement_in_while_stat588);
					statement37=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement37.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(134, 43);
			string_literal38=(IToken)Match(input,60,Follow._60_in_while_stat591); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_60.Add(string_literal38);



			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 135:3: -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
				DebugLocation(135, 6);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:6: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(135, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(135, 13);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:13: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(135, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(135, 20);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(135, 38);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:38: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(135, 40);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(135, 46);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:46: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(135, 46);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("while_stat", 9);
			LeaveRule("while_stat", 9);
			LeaveRule_while_stat();
		}
		DebugLocation(136, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:138:1: repeat_stat : 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private AstParserRuleReturnScope<object, IToken> repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 10);
		TraceIn("repeat_stat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal39 = default(IToken);
		IToken string_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement40 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_expression42 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal39_tree = default(object);
		object string_literal41_tree = default(object);
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(138, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:138:13: ( 'repita' ( statement )* 'ate' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:138:15: 'repita' ( statement )* 'ate' logic_expression
			{
			DebugLocation(138, 15);
			string_literal39=(IToken)Match(input,64,Follow._64_in_repeat_stat623); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal39);

			DebugLocation(138, 24);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:138:24: ( statement )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ID||LA14_0==58||(LA14_0>=63 && LA14_0<=66)||LA14_0==68))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:138:24: statement
					{
					DebugLocation(138, 24);
					PushFollow(Follow._statement_in_repeat_stat625);
					statement40=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement40.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(138, 35);
			string_literal41=(IToken)Match(input,55,Follow._55_in_repeat_stat628); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_55.Add(string_literal41);

			DebugLocation(138, 41);
			PushFollow(Follow._logic_expression_in_repeat_stat630);
			logic_expression42=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression42.Tree);


			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 139:3: -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
				DebugLocation(139, 6);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:139:6: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(139, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(139, 13);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:139:13: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(139, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(139, 21);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:139:21: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(139, 21);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(139, 33);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:139:33: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(139, 35);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(139, 40);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("repeat_stat", 10);
			LeaveRule("repeat_stat", 10);
			LeaveRule_repeat_stat();
		}
		DebugLocation(140, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return retval;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:142:1: function_call : ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private AstParserRuleReturnScope<object, IToken> function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 11);
		TraceIn("function_call", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID43 = default(IToken);
		IToken char_literal44 = default(IToken);
		IToken char_literal46 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list45 = default(AstParserRuleReturnScope<object, IToken>);

		object ID43_tree = default(object);
		object char_literal44_tree = default(object);
		object char_literal46_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de função"); 
		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(142, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:2: ( ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:4: ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(143, 4);
			ID43=(IToken)Match(input,ID,Follow._ID_in_function_call678); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID43);

			DebugLocation(143, 7);
			char_literal44=(IToken)Match(input,38,Follow._38_in_function_call680); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_38.Add(char_literal44);

			DebugLocation(143, 11);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:11: ( function_arg_list )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==FLOAT||LA15_0==ID||LA15_0==INT||LA15_0==STRING||LA15_0==38))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:11: function_arg_list
					{
					DebugLocation(143, 11);
					PushFollow(Follow._function_arg_list_in_function_call682);
					function_arg_list45=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list45.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(143, 30);
			char_literal46=(IToken)Match(input,39,Follow._39_in_function_call685); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal46);



			{
			// AST REWRITE
			// elements: ID, function_arg_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 143:34: -> ^( CALL ID ( function_arg_list )* )
			{
				DebugLocation(143, 37);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:37: ^( CALL ID ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(143, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(143, 44);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(143, 47);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:47: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(143, 47);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_call", 11);
			LeaveRule("function_call", 11);
			LeaveRule_function_call();
		}
		DebugLocation(144, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return retval;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:1: property_call : o= ID '.' p= ID -> ^( PCALL $o $p) ;
	[GrammarRule("property_call")]
	private AstParserRuleReturnScope<object, IToken> property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 12);
		TraceIn("property_call", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal47 = default(IToken);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal47_tree = default(object);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(146, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:147:2: (o= ID '.' p= ID -> ^( PCALL $o $p) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:147:4: o= ID '.' p= ID
			{
			DebugLocation(147, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_property_call726); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(147, 8);
			char_literal47=(IToken)Match(input,44,Follow._44_in_property_call727); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_44.Add(char_literal47);

			DebugLocation(147, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_property_call730); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);



			{
			// AST REWRITE
			// elements: o, p
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 147:17: -> ^( PCALL $o $p)
			{
				DebugLocation(147, 20);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:147:20: ^( PCALL $o $p)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(147, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PCALL, "PCALL"), root_1);

				DebugLocation(147, 29);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(147, 32);
				adaptor.AddChild(root_1, stream_p.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("property_call", 12);
			LeaveRule("property_call", 12);
			LeaveRule_property_call();
		}
		DebugLocation(148, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return retval;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:150:1: method_call : o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private AstParserRuleReturnScope<object, IToken> method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 13);
		TraceIn("method_call", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal48 = default(IToken);
		IToken char_literal49 = default(IToken);
		IToken char_literal51 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list50 = default(AstParserRuleReturnScope<object, IToken>);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal48_tree = default(object);
		object char_literal49_tree = default(object);
		object char_literal51_tree = default(object);
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(150, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:2: (o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:4: o= ID '.' p= ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(151, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_method_call774); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(151, 8);
			char_literal48=(IToken)Match(input,44,Follow._44_in_method_call775); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_44.Add(char_literal48);

			DebugLocation(151, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_method_call778); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);

			DebugLocation(151, 16);
			char_literal49=(IToken)Match(input,38,Follow._38_in_method_call780); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_38.Add(char_literal49);

			DebugLocation(151, 20);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:20: ( function_arg_list )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==FLOAT||LA16_0==ID||LA16_0==INT||LA16_0==STRING||LA16_0==38))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:20: function_arg_list
					{
					DebugLocation(151, 20);
					PushFollow(Follow._function_arg_list_in_method_call782);
					function_arg_list50=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list50.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(151, 39);
			char_literal51=(IToken)Match(input,39,Follow._39_in_method_call785); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal51);



			{
			// AST REWRITE
			// elements: function_arg_list, p, o
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 151:43: -> ^( MCALL $o $p ( function_arg_list )* )
			{
				DebugLocation(151, 46);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:46: ^( MCALL $o $p ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(151, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(MCALL, "MCALL"), root_1);

				DebugLocation(151, 55);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(151, 58);
				adaptor.AddChild(root_1, stream_p.NextNode());
				DebugLocation(151, 60);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:60: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(151, 60);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("method_call", 13);
			LeaveRule("method_call", 13);
			LeaveRule_method_call();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return retval;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:154:1: function_arg_list : plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private AstParserRuleReturnScope<object, IToken> function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 14);
		TraceIn("function_arg_list", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression54 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal53_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		 paraphrases.Push("nos argumentos da função"); 
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(154, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:2: ( plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:4: plus_expression ( ',' plus_expression )*
			{
			DebugLocation(156, 4);
			PushFollow(Follow._plus_expression_in_function_arg_list830);
			plus_expression52=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression52.Tree);
			DebugLocation(156, 20);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:20: ( ',' plus_expression )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==42))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:21: ',' plus_expression
					{
					DebugLocation(156, 21);
					char_literal53=(IToken)Match(input,42,Follow._42_in_function_arg_list833); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(char_literal53);

					DebugLocation(156, 25);
					PushFollow(Follow._plus_expression_in_function_arg_list835);
					plus_expression54=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_plus_expression.Add(plus_expression54.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 156:43: -> ^( ARG ( plus_expression )* )
			{
				DebugLocation(156, 46);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:46: ^( ARG ( plus_expression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(156, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(156, 52);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:52: ( plus_expression )*
				while ( stream_plus_expression.HasNext )
				{
					DebugLocation(156, 52);
					adaptor.AddChild(root_1, stream_plus_expression.NextTree());

				}
				stream_plus_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("function_arg_list", 14);
			LeaveRule("function_arg_list", 14);
			LeaveRule_function_arg_list();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return retval;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:159:1: assign_var : ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) );
	[GrammarRule("assign_var")]
	private AstParserRuleReturnScope<object, IToken> assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 15);
		TraceIn("assign_var", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID55 = default(IToken);
		IToken char_literal56 = default(IToken);
		IToken char_literal57 = default(IToken);
		IToken INT58 = default(IToken);
		IToken string_literal59 = default(IToken);
		IToken INT60 = default(IToken);
		IToken char_literal61 = default(IToken);
		IToken ID62 = default(IToken);
		IToken char_literal63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken INT65 = default(IToken);
		IToken char_literal66 = default(IToken);
		IToken INT67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken ID69 = default(IToken);
		IToken char_literal70 = default(IToken);
		IToken char_literal72 = default(IToken);
		IToken char_literal73 = default(IToken);
		IToken ID75 = default(IToken);
		IToken char_literal76 = default(IToken);
		AstParserRuleReturnScope<object, IToken> index71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression77 = default(AstParserRuleReturnScope<object, IToken>);

		object ID55_tree = default(object);
		object char_literal56_tree = default(object);
		object char_literal57_tree = default(object);
		object INT58_tree = default(object);
		object string_literal59_tree = default(object);
		object INT60_tree = default(object);
		object char_literal61_tree = default(object);
		object ID62_tree = default(object);
		object char_literal63_tree = default(object);
		object char_literal64_tree = default(object);
		object INT65_tree = default(object);
		object char_literal66_tree = default(object);
		object INT67_tree = default(object);
		object char_literal68_tree = default(object);
		object ID69_tree = default(object);
		object char_literal70_tree = default(object);
		object char_literal72_tree = default(object);
		object char_literal73_tree = default(object);
		object ID75_tree = default(object);
		object char_literal76_tree = default(object);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		 paraphrases.Push("na atribuição de variável"); 
		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(159, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:160:2: ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) )
			int alt19=4;
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==ID))
			{
				int LA19_1 = input.LA(2);

				if ((LA19_1==49))
				{
					int LA19_2 = input.LA(3);

					if ((EvaluatePredicate(synpred24_NPortugol_fragment)))
					{
						alt19 = 1;
					}
					else if ((EvaluatePredicate(synpred26_NPortugol_fragment)))
					{
						alt19 = 2;
					}
					else if ((true))
					{
						alt19 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 19, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA19_1==53))
				{
					alt19 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 19, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:161:9: ID '=' '[' INT '..' INT ']'
				{
				DebugLocation(161, 9);
				ID55=(IToken)Match(input,ID,Follow._ID_in_assign_var887); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID55);

				DebugLocation(161, 12);
				char_literal56=(IToken)Match(input,49,Follow._49_in_assign_var889); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal56);

				DebugLocation(161, 16);
				char_literal57=(IToken)Match(input,53,Follow._53_in_assign_var891); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal57);

				DebugLocation(161, 20);
				INT58=(IToken)Match(input,INT,Follow._INT_in_assign_var893); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT58);

				DebugLocation(161, 24);
				string_literal59=(IToken)Match(input,45,Follow._45_in_assign_var895); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_45.Add(string_literal59);

				DebugLocation(161, 29);
				INT60=(IToken)Match(input,INT,Follow._INT_in_assign_var897); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT60);

				DebugLocation(161, 33);
				char_literal61=(IToken)Match(input,54,Follow._54_in_assign_var899); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_54.Add(char_literal61);



				{
				// AST REWRITE
				// elements: INT, INT, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 161:37: -> ^( ASGN ID INT INT )
				{
					DebugLocation(161, 40);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:161:40: ^( ASGN ID INT INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(161, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(161, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(161, 50);
					adaptor.AddChild(root_1, stream_INT.NextNode());
					DebugLocation(161, 54);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:10: ID '=' '{' INT ( ',' INT )* '}'
				{
				DebugLocation(162, 10);
				ID62=(IToken)Match(input,ID,Follow._ID_in_assign_var922); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID62);

				DebugLocation(162, 13);
				char_literal63=(IToken)Match(input,49,Follow._49_in_assign_var924); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal63);

				DebugLocation(162, 17);
				char_literal64=(IToken)Match(input,69,Follow._69_in_assign_var926); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(char_literal64);

				DebugLocation(162, 21);
				INT65=(IToken)Match(input,INT,Follow._INT_in_assign_var928); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT65);

				DebugLocation(162, 25);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:25: ( ',' INT )*
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_0 = input.LA(1);

					if ((LA18_0==42))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch ( alt18 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:26: ',' INT
						{
						DebugLocation(162, 26);
						char_literal66=(IToken)Match(input,42,Follow._42_in_assign_var931); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_42.Add(char_literal66);

						DebugLocation(162, 30);
						INT67=(IToken)Match(input,INT,Follow._INT_in_assign_var933); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT67);


						}
						break;

					default:
						goto loop18;
					}
				}

				loop18:
					;

				} finally { DebugExitSubRule(18); }

				DebugLocation(162, 36);
				char_literal68=(IToken)Match(input,70,Follow._70_in_assign_var937); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_70.Add(char_literal68);



				{
				// AST REWRITE
				// elements: ID, INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 162:40: -> ^( ASGN ID ^( ILIST ( INT )* ) )
				{
					DebugLocation(162, 43);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:43: ^( ASGN ID ^( ILIST ( INT )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(162, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(162, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(162, 53);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:53: ^( ILIST ( INT )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(162, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ILIST, "ILIST"), root_2);

					DebugLocation(162, 61);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:61: ( INT )*
					while ( stream_INT.HasNext )
					{
						DebugLocation(162, 61);
						adaptor.AddChild(root_2, stream_INT.NextNode());

					}
					stream_INT.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:163:4: ID '[' index ']' '=' assign_expression
				{
				DebugLocation(163, 4);
				ID69=(IToken)Match(input,ID,Follow._ID_in_assign_var957); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID69);

				DebugLocation(163, 7);
				char_literal70=(IToken)Match(input,53,Follow._53_in_assign_var959); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal70);

				DebugLocation(163, 11);
				PushFollow(Follow._index_in_assign_var961);
				index71=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index71.Tree);
				DebugLocation(163, 17);
				char_literal72=(IToken)Match(input,54,Follow._54_in_assign_var963); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_54.Add(char_literal72);

				DebugLocation(163, 21);
				char_literal73=(IToken)Match(input,49,Follow._49_in_assign_var965); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal73);

				DebugLocation(163, 25);
				PushFollow(Follow._assign_expression_in_assign_var967);
				assign_expression74=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression74.Tree);


				{
				// AST REWRITE
				// elements: assign_expression, ID, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 163:44: -> ^( ASGN ^( AR index ) ID assign_expression )
				{
					DebugLocation(163, 47);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:163:47: ^( ASGN ^( AR index ) ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(163, 49);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(163, 54);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:163:54: ^( AR index )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(163, 56);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(AR, "AR"), root_2);

					DebugLocation(163, 59);
					adaptor.AddChild(root_2, stream_index.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(163, 66);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(163, 69);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:164:11: ID '=' assign_expression
				{
				DebugLocation(164, 11);
				ID75=(IToken)Match(input,ID,Follow._ID_in_assign_var996); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID75);

				DebugLocation(164, 14);
				char_literal76=(IToken)Match(input,49,Follow._49_in_assign_var998); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal76);

				DebugLocation(164, 18);
				PushFollow(Follow._assign_expression_in_assign_var1000);
				assign_expression77=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression77.Tree);


				{
				// AST REWRITE
				// elements: assign_expression, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 164:37: -> ^( ASGN ID assign_expression )
				{
					DebugLocation(164, 40);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:164:40: ^( ASGN ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(164, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(164, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(164, 50);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_var", 15);
			LeaveRule("assign_var", 15);
			LeaveRule_assign_var();
		}
		DebugLocation(165, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return retval;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:172:1: return_stat : 'retorne' assign_expression -> ^( RET assign_expression ) ;
	[GrammarRule("return_stat")]
	private AstParserRuleReturnScope<object, IToken> return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 16);
		TraceIn("return_stat", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal78 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_expression79 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal78_tree = default(object);
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(172, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:173:2: ( 'retorne' assign_expression -> ^( RET assign_expression ) )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:173:4: 'retorne' assign_expression
			{
			DebugLocation(173, 4);
			string_literal78=(IToken)Match(input,65,Follow._65_in_return_stat1026); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_65.Add(string_literal78);

			DebugLocation(173, 14);
			PushFollow(Follow._assign_expression_in_return_stat1028);
			assign_expression79=assign_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_expression.Add(assign_expression79.Tree);


			{
			// AST REWRITE
			// elements: assign_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 173:33: -> ^( RET assign_expression )
			{
				DebugLocation(173, 36);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:173:36: ^( RET assign_expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(173, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RET, "RET"), root_1);

				DebugLocation(173, 42);
				adaptor.AddChild(root_1, stream_assign_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("return_stat", 16);
			LeaveRule("return_stat", 16);
			LeaveRule_return_stat();
		}
		DebugLocation(174, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return retval;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:180:1: logic_expression : ( plus_expression ) ( binop ^ plus_expression )* ;
	[GrammarRule("logic_expression")]
	private AstParserRuleReturnScope<object, IToken> logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 17);
		TraceIn("logic_expression", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binop81 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression82 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(180, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:181:2: ( ( plus_expression ) ( binop ^ plus_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:181:4: ( plus_expression ) ( binop ^ plus_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(181, 4);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:181:4: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:181:5: plus_expression
			{
			DebugLocation(181, 5);
			PushFollow(Follow._plus_expression_in_logic_expression1053);
			plus_expression80=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression80.Tree);

			}

			DebugLocation(181, 22);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:181:22: ( binop ^ plus_expression )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==36||(LA20_0>=47 && LA20_0<=48)||(LA20_0>=50 && LA20_0<=52)||LA20_0==57||LA20_0==62))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:181:23: binop ^ plus_expression
					{
					DebugLocation(181, 28);
					PushFollow(Follow._binop_in_logic_expression1057);
					binop81=binop();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(binop81.Tree, root_0);
					DebugLocation(181, 30);
					PushFollow(Follow._plus_expression_in_logic_expression1060);
					plus_expression82=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression82.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("logic_expression", 17);
			LeaveRule("logic_expression", 17);
			LeaveRule_logic_expression();
		}
		DebugLocation(182, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return retval;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_binop();
	partial void LeaveRule_binop();

	// $ANTLR start "binop"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:184:1: binop : ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' );
	[GrammarRule("binop")]
	private AstParserRuleReturnScope<object, IToken> binop()
	{
		EnterRule_binop();
		EnterRule("binop", 18);
		TraceIn("binop", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set83 = default(IToken);

		object set83_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binop");
		DebugLocation(184, 59);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:184:7: ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(184, 7);

			set83=(IToken)input.LT(1);
			if (input.LA(1)==36||(input.LA(1)>=47 && input.LA(1)<=48)||(input.LA(1)>=50 && input.LA(1)<=52)||input.LA(1)==57||input.LA(1)==62)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set83));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("binop", 18);
			LeaveRule("binop", 18);
			LeaveRule_binop();
		}
		DebugLocation(184, 59);
		} finally { DebugExitRule(GrammarFileName, "binop"); }
		return retval;

	}
	// $ANTLR end "binop"

	partial void EnterRule_assign_expression();
	partial void LeaveRule_assign_expression();

	// $ANTLR start "assign_expression"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:187:1: assign_expression options {k=3; } : plus_expression ;
	[GrammarRule("assign_expression")]
	private AstParserRuleReturnScope<object, IToken> assign_expression()
	{
		EnterRule_assign_expression();
		EnterRule("assign_expression", 19);
		TraceIn("assign_expression", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression84 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_expression");
		DebugLocation(187, 19);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:189:2: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:189:5: plus_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(189, 5);
			PushFollow(Follow._plus_expression_in_assign_expression1121);
			plus_expression84=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression84.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("assign_expression", 19);
			LeaveRule("assign_expression", 19);
			LeaveRule_assign_expression();
		}
		DebugLocation(189, 19);
		} finally { DebugExitRule(GrammarFileName, "assign_expression"); }
		return retval;

	}
	// $ANTLR end "assign_expression"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:191:1: plus_expression : ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* ;
	[GrammarRule("plus_expression")]
	private AstParserRuleReturnScope<object, IToken> plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 20);
		TraceIn("plus_expression", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal86 = default(IToken);
		IToken char_literal88 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expression85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression87 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression89 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal86_tree = default(object);
		object char_literal88_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(191, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:2: ( ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:4: ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(192, 4);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:4: ( mul_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:5: mul_expression
			{
			DebugLocation(192, 5);
			PushFollow(Follow._mul_expression_in_plus_expression1131);
			mul_expression85=mul_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression85.Tree);

			}

			DebugLocation(192, 21);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:21: ( '+' ^ mul_expression | '-' ^ mul_expression )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=3;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==41))
				{
					alt21 = 1;
				}
				else if ((LA21_0==43))
				{
					alt21 = 2;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:22: '+' ^ mul_expression
					{
					DebugLocation(192, 25);
					char_literal86=(IToken)Match(input,41,Follow._41_in_plus_expression1135); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal86_tree = (object)adaptor.Create(char_literal86);
					root_0 = (object)adaptor.BecomeRoot(char_literal86_tree, root_0);
					}
					DebugLocation(192, 27);
					PushFollow(Follow._mul_expression_in_plus_expression1138);
					mul_expression87=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression87.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:44: '-' ^ mul_expression
					{
					DebugLocation(192, 47);
					char_literal88=(IToken)Match(input,43,Follow._43_in_plus_expression1142); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal88_tree = (object)adaptor.Create(char_literal88);
					root_0 = (object)adaptor.BecomeRoot(char_literal88_tree, root_0);
					}
					DebugLocation(192, 49);
					PushFollow(Follow._mul_expression_in_plus_expression1145);
					mul_expression89=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression89.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("plus_expression", 20);
			LeaveRule("plus_expression", 20);
			LeaveRule_plus_expression();
		}
		DebugLocation(193, 1);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return retval;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_mul_expression();
	partial void LeaveRule_mul_expression();

	// $ANTLR start "mul_expression"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:195:1: mul_expression : ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* ;
	[GrammarRule("mul_expression")]
	private AstParserRuleReturnScope<object, IToken> mul_expression()
	{
		EnterRule_mul_expression();
		EnterRule("mul_expression", 21);
		TraceIn("mul_expression", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal91 = default(IToken);
		IToken char_literal93 = default(IToken);
		IToken char_literal95 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression90 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression92 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression94 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression96 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal91_tree = default(object);
		object char_literal93_tree = default(object);
		object char_literal95_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expression");
		DebugLocation(195, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:2: ( ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:4: ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(196, 4);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:4: ( primary_ar_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:5: primary_ar_expression
			{
			DebugLocation(196, 5);
			PushFollow(Follow._primary_ar_expression_in_mul_expression1160);
			primary_ar_expression90=primary_ar_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression90.Tree);

			}

			DebugLocation(196, 28);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:28: ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=4;
				try { DebugEnterDecision(22, false);
				switch (input.LA(1))
				{
				case 46:
					{
					alt22 = 1;
					}
					break;
				case 37:
					{
					alt22 = 2;
					}
					break;
				case 40:
					{
					alt22 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:30: '/' ^ primary_ar_expression
					{
					DebugLocation(196, 33);
					char_literal91=(IToken)Match(input,46,Follow._46_in_mul_expression1165); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal91_tree = (object)adaptor.Create(char_literal91);
					root_0 = (object)adaptor.BecomeRoot(char_literal91_tree, root_0);
					}
					DebugLocation(196, 35);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1168);
					primary_ar_expression92=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression92.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:59: '%' ^ primary_ar_expression
					{
					DebugLocation(196, 62);
					char_literal93=(IToken)Match(input,37,Follow._37_in_mul_expression1172); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal93_tree = (object)adaptor.Create(char_literal93);
					root_0 = (object)adaptor.BecomeRoot(char_literal93_tree, root_0);
					}
					DebugLocation(196, 64);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1175);
					primary_ar_expression94=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression94.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:88: '*' ^ primary_ar_expression
					{
					DebugLocation(196, 91);
					char_literal95=(IToken)Match(input,40,Follow._40_in_mul_expression1179); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal95_tree = (object)adaptor.Create(char_literal95);
					root_0 = (object)adaptor.BecomeRoot(char_literal95_tree, root_0);
					}
					DebugLocation(196, 93);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1182);
					primary_ar_expression96=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression96.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("mul_expression", 21);
			LeaveRule("mul_expression", 21);
			LeaveRule_mul_expression();
		}
		DebugLocation(197, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expression"); }
		return retval;

	}
	// $ANTLR end "mul_expression"

	partial void EnterRule_primary_ar_expression();
	partial void LeaveRule_primary_ar_expression();

	// $ANTLR start "primary_ar_expression"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:199:1: primary_ar_expression : ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression );
	[GrammarRule("primary_ar_expression")]
	private AstParserRuleReturnScope<object, IToken> primary_ar_expression()
	{
		EnterRule_primary_ar_expression();
		EnterRule("primary_ar_expression", 22);
		TraceIn("primary_ar_expression", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID98 = default(IToken);
		IToken ID99 = default(IToken);
		IToken char_literal100 = default(IToken);
		IToken char_literal102 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_call97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method_call103 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property_call104 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant105 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesisExpression106 = default(AstParserRuleReturnScope<object, IToken>);

		object ID98_tree = default(object);
		object ID99_tree = default(object);
		object char_literal100_tree = default(object);
		object char_literal102_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		try { DebugEnterRule(GrammarFileName, "primary_ar_expression");
		DebugLocation(199, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:200:2: ({...}? => function_call | ID | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression )
			int alt23=7;
			try { DebugEnterDecision(23, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case 38:
					{
					int LA23_4 = input.LA(3);

					if ((((( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )&&( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" ))&&EvaluatePredicate(synpred41_NPortugol_fragment))))
					{
						alt23 = 1;
					}
					else if ((EvaluatePredicate(synpred42_NPortugol_fragment)))
					{
						alt23 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 23, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 53:
					{
					alt23 = 3;
					}
					break;
				case 44:
					{
					int LA23_6 = input.LA(3);

					if ((EvaluatePredicate(synpred44_NPortugol_fragment)))
					{
						alt23 = 4;
					}
					else if ((EvaluatePredicate(synpred45_NPortugol_fragment)))
					{
						alt23 = 5;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 23, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case EOF:
				case FLOAT:
				case ID:
				case INT:
				case STRING:
				case 36:
				case 37:
				case 39:
				case 40:
				case 41:
				case 42:
				case 43:
				case 46:
				case 47:
				case 48:
				case 50:
				case 51:
				case 52:
				case 55:
				case 57:
				case 58:
				case 59:
				case 60:
				case 62:
				case 63:
				case 64:
				case 65:
				case 66:
				case 67:
				case 68:
					{
					alt23 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 23, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case FLOAT:
			case INT:
			case STRING:
				{
				alt23 = 6;
				}
				break;
			case 38:
				{
				alt23 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:200:4: {...}? => function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(200, 4);
				if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary_ar_expression", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
				}
				DebugLocation(200, 71);
				PushFollow(Follow._function_call_in_primary_ar_expression1200);
				function_call97=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call97.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(201, 4);
				ID98=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1205); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID98_tree = (object)adaptor.Create(ID98);
				adaptor.AddChild(root_0, ID98_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:202:4: ID '[' index ']'
				{
				DebugLocation(202, 4);
				ID99=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1210); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID99);

				DebugLocation(202, 7);
				char_literal100=(IToken)Match(input,53,Follow._53_in_primary_ar_expression1212); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal100);

				DebugLocation(202, 11);
				PushFollow(Follow._index_in_primary_ar_expression1214);
				index101=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index101.Tree);
				DebugLocation(202, 17);
				char_literal102=(IToken)Match(input,54,Follow._54_in_primary_ar_expression1216); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_54.Add(char_literal102);



				{
				// AST REWRITE
				// elements: ID, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 202:21: -> ^( INDEX index ) ID
				{
					DebugLocation(202, 24);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:202:24: ^( INDEX index )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(202, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_1);

					DebugLocation(202, 32);
					adaptor.AddChild(root_1, stream_index.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(202, 39);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:203:4: method_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(203, 4);
				PushFollow(Follow._method_call_in_primary_ar_expression1231);
				method_call103=method_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, method_call103.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:204:4: property_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(204, 4);
				PushFollow(Follow._property_call_in_primary_ar_expression1237);
				property_call104=property_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, property_call104.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(205, 4);
				PushFollow(Follow._constant_in_primary_ar_expression1242);
				constant105=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant105.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: parenthesisExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(206, 4);
				PushFollow(Follow._parenthesisExpression_in_primary_ar_expression1247);
				parenthesisExpression106=parenthesisExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parenthesisExpression106.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("primary_ar_expression", 22);
			LeaveRule("primary_ar_expression", 22);
			LeaveRule_primary_ar_expression();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_ar_expression"); }
		return retval;

	}
	// $ANTLR end "primary_ar_expression"

	partial void EnterRule_parenthesisExpression();
	partial void LeaveRule_parenthesisExpression();

	// $ANTLR start "parenthesisExpression"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:1: parenthesisExpression : '(' plus_expression ')' -> plus_expression ;
	[GrammarRule("parenthesisExpression")]
	private AstParserRuleReturnScope<object, IToken> parenthesisExpression()
	{
		EnterRule_parenthesisExpression();
		EnterRule("parenthesisExpression", 23);
		TraceIn("parenthesisExpression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal107 = default(IToken);
		IToken char_literal109 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression108 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal107_tree = default(object);
		object char_literal109_tree = default(object);
		RewriteRuleITokenStream stream_39=new RewriteRuleITokenStream(adaptor,"token 39");
		RewriteRuleITokenStream stream_38=new RewriteRuleITokenStream(adaptor,"token 38");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		try { DebugEnterRule(GrammarFileName, "parenthesisExpression");
		DebugLocation(209, 1);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:22: ( '(' plus_expression ')' -> plus_expression )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:24: '(' plus_expression ')'
			{
			DebugLocation(209, 24);
			char_literal107=(IToken)Match(input,38,Follow._38_in_parenthesisExpression1262); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_38.Add(char_literal107);

			DebugLocation(209, 28);
			PushFollow(Follow._plus_expression_in_parenthesisExpression1264);
			plus_expression108=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression108.Tree);
			DebugLocation(209, 44);
			char_literal109=(IToken)Match(input,39,Follow._39_in_parenthesisExpression1266); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_39.Add(char_literal109);



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 209:48: -> plus_expression
			{
				DebugLocation(209, 51);
				adaptor.AddChild(root_0, stream_plus_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("parenthesisExpression", 23);
			LeaveRule("parenthesisExpression", 23);
			LeaveRule_parenthesisExpression();
		}
		DebugLocation(210, 1);
		} finally { DebugExitRule(GrammarFileName, "parenthesisExpression"); }
		return retval;

	}
	// $ANTLR end "parenthesisExpression"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:212:1: constant : ( INT | FLOAT | STRING );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 24);
		TraceIn("constant", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set110 = default(IToken);

		object set110_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(212, 30);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:212:9: ( INT | FLOAT | STRING )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(212, 9);

			set110=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set110));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("constant", 24);
			LeaveRule("constant", 24);
			LeaveRule_constant();
		}
		DebugLocation(212, 30);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:214:1: atom : ( constant | ID );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 25);
		TraceIn("atom", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID112 = default(IToken);
		AstParserRuleReturnScope<object, IToken> constant111 = default(AstParserRuleReturnScope<object, IToken>);

		object ID112_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(214, 20);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:214:6: ( constant | ID )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==FLOAT||LA24_0==INT||LA24_0==STRING))
			{
				alt24 = 1;
			}
			else if ((LA24_0==ID))
			{
				alt24 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:214:8: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(214, 8);
				PushFollow(Follow._constant_in_atom1297);
				constant111=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant111.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:214:19: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(214, 19);
				ID112=(IToken)Match(input,ID,Follow._ID_in_atom1301); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID112_tree = (object)adaptor.Create(ID112);
				adaptor.AddChild(root_0, ID112_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("atom", 25);
			LeaveRule("atom", 25);
			LeaveRule_atom();
		}
		DebugLocation(214, 20);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:1: index : ( INT | ID );
	[GrammarRule("index")]
	private AstParserRuleReturnScope<object, IToken> index()
	{
		EnterRule_index();
		EnterRule("index", 26);
		TraceIn("index", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set113 = default(IToken);

		object set113_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(216, 16);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:7: ( INT | ID )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(216, 7);

			set113=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set113));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("index", 26);
			LeaveRule("index", 26);
			LeaveRule_index();
		}
		DebugLocation(216, 16);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return retval;

	}
	// $ANTLR end "index"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:218:1: number : ( INT | FLOAT );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<object, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 27);
		TraceIn("number", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set114 = default(IToken);

		object set114_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(218, 20);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:218:8: ( INT | FLOAT )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(218, 8);

			set114=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set114));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw e;
			}

		finally
		{
			TraceOut("number", 27);
			LeaveRule("number", 27);
			LeaveRule_number();
		}
		DebugLocation(218, 20);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_synpred21_NPortugol_fragment();
	partial void LeaveRule_synpred21_NPortugol_fragment();

	// $ANTLR start synpred21_NPortugol
	public void synpred21_NPortugol_fragment()
	{
		EnterRule_synpred21_NPortugol_fragment();
		EnterRule("synpred21_NPortugol_fragment", 48);
		TraceIn("synpred21_NPortugol_fragment", 48);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:11: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:143:11: function_arg_list
			{
			DebugLocation(143, 11);
			PushFollow(Follow._function_arg_list_in_synpred21_NPortugol682);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred21_NPortugol_fragment", 48);
			LeaveRule("synpred21_NPortugol_fragment", 48);
			LeaveRule_synpred21_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred21_NPortugol

	partial void EnterRule_synpred22_NPortugol_fragment();
	partial void LeaveRule_synpred22_NPortugol_fragment();

	// $ANTLR start synpred22_NPortugol
	public void synpred22_NPortugol_fragment()
	{
		EnterRule_synpred22_NPortugol_fragment();
		EnterRule("synpred22_NPortugol_fragment", 49);
		TraceIn("synpred22_NPortugol_fragment", 49);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:20: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:151:20: function_arg_list
			{
			DebugLocation(151, 20);
			PushFollow(Follow._function_arg_list_in_synpred22_NPortugol782);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred22_NPortugol_fragment", 49);
			LeaveRule("synpred22_NPortugol_fragment", 49);
			LeaveRule_synpred22_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred22_NPortugol

	partial void EnterRule_synpred24_NPortugol_fragment();
	partial void LeaveRule_synpred24_NPortugol_fragment();

	// $ANTLR start synpred24_NPortugol
	public void synpred24_NPortugol_fragment()
	{
		EnterRule_synpred24_NPortugol_fragment();
		EnterRule("synpred24_NPortugol_fragment", 51);
		TraceIn("synpred24_NPortugol_fragment", 51);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:161:9: ( ID '=' '[' INT '..' INT ']' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:161:9: ID '=' '[' INT '..' INT ']'
			{
			DebugLocation(161, 9);
			Match(input,ID,Follow._ID_in_synpred24_NPortugol887); if (state.failed) return;
			DebugLocation(161, 12);
			Match(input,49,Follow._49_in_synpred24_NPortugol889); if (state.failed) return;
			DebugLocation(161, 16);
			Match(input,53,Follow._53_in_synpred24_NPortugol891); if (state.failed) return;
			DebugLocation(161, 20);
			Match(input,INT,Follow._INT_in_synpred24_NPortugol893); if (state.failed) return;
			DebugLocation(161, 24);
			Match(input,45,Follow._45_in_synpred24_NPortugol895); if (state.failed) return;
			DebugLocation(161, 29);
			Match(input,INT,Follow._INT_in_synpred24_NPortugol897); if (state.failed) return;
			DebugLocation(161, 33);
			Match(input,54,Follow._54_in_synpred24_NPortugol899); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_NPortugol_fragment", 51);
			LeaveRule("synpred24_NPortugol_fragment", 51);
			LeaveRule_synpred24_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred24_NPortugol

	partial void EnterRule_synpred26_NPortugol_fragment();
	partial void LeaveRule_synpred26_NPortugol_fragment();

	// $ANTLR start synpred26_NPortugol
	public void synpred26_NPortugol_fragment()
	{
		EnterRule_synpred26_NPortugol_fragment();
		EnterRule("synpred26_NPortugol_fragment", 53);
		TraceIn("synpred26_NPortugol_fragment", 53);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:10: ( ID '=' '{' INT ( ',' INT )* '}' )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:10: ID '=' '{' INT ( ',' INT )* '}'
			{
			DebugLocation(162, 10);
			Match(input,ID,Follow._ID_in_synpred26_NPortugol922); if (state.failed) return;
			DebugLocation(162, 13);
			Match(input,49,Follow._49_in_synpred26_NPortugol924); if (state.failed) return;
			DebugLocation(162, 17);
			Match(input,69,Follow._69_in_synpred26_NPortugol926); if (state.failed) return;
			DebugLocation(162, 21);
			Match(input,INT,Follow._INT_in_synpred26_NPortugol928); if (state.failed) return;
			DebugLocation(162, 25);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:25: ( ',' INT )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==42))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:26: ',' INT
					{
					DebugLocation(162, 26);
					Match(input,42,Follow._42_in_synpred26_NPortugol931); if (state.failed) return;
					DebugLocation(162, 30);
					Match(input,INT,Follow._INT_in_synpred26_NPortugol933); if (state.failed) return;

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }

			DebugLocation(162, 36);
			Match(input,70,Follow._70_in_synpred26_NPortugol937); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_NPortugol_fragment", 53);
			LeaveRule("synpred26_NPortugol_fragment", 53);
			LeaveRule_synpred26_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred26_NPortugol

	partial void EnterRule_synpred41_NPortugol_fragment();
	partial void LeaveRule_synpred41_NPortugol_fragment();

	// $ANTLR start synpred41_NPortugol
	public void synpred41_NPortugol_fragment()
	{
		EnterRule_synpred41_NPortugol_fragment();
		EnterRule("synpred41_NPortugol_fragment", 68);
		TraceIn("synpred41_NPortugol_fragment", 68);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:200:4: ({...}? => function_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:200:4: {...}? => function_call
			{
			DebugLocation(200, 4);
			if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred41_NPortugol", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
			}
			DebugLocation(200, 71);
			PushFollow(Follow._function_call_in_synpred41_NPortugol1200);
			function_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred41_NPortugol_fragment", 68);
			LeaveRule("synpred41_NPortugol_fragment", 68);
			LeaveRule_synpred41_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred41_NPortugol

	partial void EnterRule_synpred42_NPortugol_fragment();
	partial void LeaveRule_synpred42_NPortugol_fragment();

	// $ANTLR start synpred42_NPortugol
	public void synpred42_NPortugol_fragment()
	{
		EnterRule_synpred42_NPortugol_fragment();
		EnterRule("synpred42_NPortugol_fragment", 69);
		TraceIn("synpred42_NPortugol_fragment", 69);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ( ID )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ID
			{
			DebugLocation(201, 4);
			Match(input,ID,Follow._ID_in_synpred42_NPortugol1205); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred42_NPortugol_fragment", 69);
			LeaveRule("synpred42_NPortugol_fragment", 69);
			LeaveRule_synpred42_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred42_NPortugol

	partial void EnterRule_synpred44_NPortugol_fragment();
	partial void LeaveRule_synpred44_NPortugol_fragment();

	// $ANTLR start synpred44_NPortugol
	public void synpred44_NPortugol_fragment()
	{
		EnterRule_synpred44_NPortugol_fragment();
		EnterRule("synpred44_NPortugol_fragment", 71);
		TraceIn("synpred44_NPortugol_fragment", 71);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:203:4: ( method_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:203:4: method_call
			{
			DebugLocation(203, 4);
			PushFollow(Follow._method_call_in_synpred44_NPortugol1231);
			method_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred44_NPortugol_fragment", 71);
			LeaveRule("synpred44_NPortugol_fragment", 71);
			LeaveRule_synpred44_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred44_NPortugol

	partial void EnterRule_synpred45_NPortugol_fragment();
	partial void LeaveRule_synpred45_NPortugol_fragment();

	// $ANTLR start synpred45_NPortugol
	public void synpred45_NPortugol_fragment()
	{
		EnterRule_synpred45_NPortugol_fragment();
		EnterRule("synpred45_NPortugol_fragment", 72);
		TraceIn("synpred45_NPortugol_fragment", 72);
		try
		{
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:204:4: ( property_call )
			DebugEnterAlt(1);
			// E:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:204:4: property_call
			{
			DebugLocation(204, 4);
			PushFollow(Follow._property_call_in_synpred45_NPortugol1237);
			property_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred45_NPortugol_fragment", 72);
			LeaveRule("synpred45_NPortugol_fragment", 72);
			LeaveRule_synpred45_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred45_NPortugol
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script144 = new BitSet(new ulong[]{0x2000000000000002UL});
		public static readonly BitSet _61_in_declare_function154 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_declare_function158 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_declare_function160 = new BitSet(new ulong[]{0x8000010000UL});
		public static readonly BitSet _function_param_list_in_declare_function162 = new BitSet(new ulong[]{0x8000010000UL});
		public static readonly BitSet _39_in_declare_function165 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _statement_in_declare_function167 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _60_in_declare_function170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declare_local_in_statement217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement223 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement229 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement251 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement257 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_param_list285 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _42_in_function_param_list288 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_function_param_list290 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _68_in_declare_local338 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_declare_local342 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _42_in_declare_local345 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_declare_local349 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _66_in_if_stat395 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _logic_expression_in_if_stat399 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _59_in_if_stat401 = new BitSet(new ulong[]{0x9400000000010000UL,0x1FUL});
		public static readonly BitSet _statement_in_if_stat405 = new BitSet(new ulong[]{0x9400000000010000UL,0x1FUL});
		public static readonly BitSet _senao_stat_in_if_stat413 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _60_in_if_stat441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_senao_stat477 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _statement_in_senao_stat481 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _60_in_senao_stat484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_for_stat504 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _assign_var_in_for_stat506 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _55_in_for_stat508 = new BitSet(new ulong[]{0x110000UL});
		public static readonly BitSet _index_in_for_stat510 = new BitSet(new ulong[]{0x9500000000010000UL,0x17UL});
		public static readonly BitSet _56_in_for_stat518 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _statement_in_for_stat520 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _60_in_for_stat523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_for_stat548 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _60_in_for_stat551 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _58_in_while_stat584 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _logic_expression_in_while_stat586 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _statement_in_while_stat588 = new BitSet(new ulong[]{0x9400000000010000UL,0x17UL});
		public static readonly BitSet _60_in_while_stat591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _64_in_repeat_stat623 = new BitSet(new ulong[]{0x8480000000010000UL,0x17UL});
		public static readonly BitSet _statement_in_repeat_stat625 = new BitSet(new ulong[]{0x8480000000010000UL,0x17UL});
		public static readonly BitSet _55_in_repeat_stat628 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _logic_expression_in_repeat_stat630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_call678 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_function_call680 = new BitSet(new ulong[]{0xC100112000UL});
		public static readonly BitSet _function_arg_list_in_function_call682 = new BitSet(new ulong[]{0xC100112000UL});
		public static readonly BitSet _39_in_function_call685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_property_call726 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _44_in_property_call727 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_property_call730 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_method_call774 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _44_in_method_call775 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ID_in_method_call778 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _38_in_method_call780 = new BitSet(new ulong[]{0xC100112000UL});
		public static readonly BitSet _function_arg_list_in_method_call782 = new BitSet(new ulong[]{0xC100112000UL});
		public static readonly BitSet _39_in_method_call785 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_function_arg_list830 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _42_in_function_arg_list833 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _plus_expression_in_function_arg_list835 = new BitSet(new ulong[]{0x40000000002UL});
		public static readonly BitSet _ID_in_assign_var887 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_assign_var889 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_assign_var891 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_assign_var893 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _45_in_assign_var895 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_assign_var897 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_assign_var899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var922 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_assign_var924 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_assign_var926 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_assign_var928 = new BitSet(new ulong[]{0x40000000000UL,0x40UL});
		public static readonly BitSet _42_in_assign_var931 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_assign_var933 = new BitSet(new ulong[]{0x40000000000UL,0x40UL});
		public static readonly BitSet _70_in_assign_var937 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var957 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_assign_var959 = new BitSet(new ulong[]{0x110000UL});
		public static readonly BitSet _index_in_assign_var961 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_assign_var963 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_assign_var965 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _assign_expression_in_assign_var967 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var996 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_assign_var998 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _assign_expression_in_assign_var1000 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _65_in_return_stat1026 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _assign_expression_in_return_stat1028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_logic_expression1053 = new BitSet(new ulong[]{0x421D801000000002UL});
		public static readonly BitSet _binop_in_logic_expression1057 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _plus_expression_in_logic_expression1060 = new BitSet(new ulong[]{0x421D801000000002UL});
		public static readonly BitSet _plus_expression_in_assign_expression1121 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mul_expression_in_plus_expression1131 = new BitSet(new ulong[]{0xA0000000002UL});
		public static readonly BitSet _41_in_plus_expression1135 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1138 = new BitSet(new ulong[]{0xA0000000002UL});
		public static readonly BitSet _43_in_plus_expression1142 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1145 = new BitSet(new ulong[]{0xA0000000002UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1160 = new BitSet(new ulong[]{0x412000000002UL});
		public static readonly BitSet _46_in_mul_expression1165 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1168 = new BitSet(new ulong[]{0x412000000002UL});
		public static readonly BitSet _37_in_mul_expression1172 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1175 = new BitSet(new ulong[]{0x412000000002UL});
		public static readonly BitSet _40_in_mul_expression1179 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1182 = new BitSet(new ulong[]{0x412000000002UL});
		public static readonly BitSet _function_call_in_primary_ar_expression1200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1205 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1210 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_primary_ar_expression1212 = new BitSet(new ulong[]{0x110000UL});
		public static readonly BitSet _index_in_primary_ar_expression1214 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_primary_ar_expression1216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_primary_ar_expression1231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_primary_ar_expression1237 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_ar_expression1242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesisExpression_in_primary_ar_expression1247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _38_in_parenthesisExpression1262 = new BitSet(new ulong[]{0x4100112000UL});
		public static readonly BitSet _plus_expression_in_parenthesisExpression1264 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _39_in_parenthesisExpression1266 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_atom1297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1301 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred21_NPortugol682 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred22_NPortugol782 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred24_NPortugol887 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_synpred24_NPortugol889 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_synpred24_NPortugol891 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_synpred24_NPortugol893 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _45_in_synpred24_NPortugol895 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_synpred24_NPortugol897 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _54_in_synpred24_NPortugol899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred26_NPortugol922 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_synpred26_NPortugol924 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _69_in_synpred26_NPortugol926 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_synpred26_NPortugol928 = new BitSet(new ulong[]{0x40000000000UL,0x40UL});
		public static readonly BitSet _42_in_synpred26_NPortugol931 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INT_in_synpred26_NPortugol933 = new BitSet(new ulong[]{0x40000000000UL,0x40UL});
		public static readonly BitSet _70_in_synpred26_NPortugol937 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_synpred41_NPortugol1200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred42_NPortugol1205 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_synpred44_NPortugol1231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_synpred45_NPortugol1237 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol
