//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g 2014-04-14 02:49:12

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections;
using System;



using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "ASM", "CALL", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "F", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SJMP", "SLIST", "STRING", "T", "UNICODE_ESC", "VAR", "WS", "'!='", "'#'", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'até'", "'decrescente'", "'e'", "'enquanto'", "'então'", "'fim'", "'função'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'senão'", "'variável'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__39=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int ASM=7;
	public const int CALL=8;
	public const int CHAR=9;
	public const int DEC=10;
	public const int ESC_SEQ=11;
	public const int EXP=12;
	public const int EXPONENT=13;
	public const int F=14;
	public const int FLOAT=15;
	public const int FUNC=16;
	public const int HEX_DIGIT=17;
	public const int ID=18;
	public const int ILIST=19;
	public const int INDEX=20;
	public const int INIT=21;
	public const int INT=22;
	public const int JMP=23;
	public const int LEXP=24;
	public const int LOOP=25;
	public const int MCALL=26;
	public const int NEWLINE=27;
	public const int OCTAL_ESC=28;
	public const int PARAM=29;
	public const int PCALL=30;
	public const int RET=31;
	public const int SJMP=32;
	public const int SLIST=33;
	public const int STRING=34;
	public const int T=35;
	public const int UNICODE_ESC=36;
	public const int VAR=37;
	public const int WS=38;

	public NPortugolParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NPortugolParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g"; } }



		Stack<string> paraphrases = new Stack<string>();
		
		public string GetErrorMessage(RecognitionException e)
	        {
	            string msg = "Erro na linha {0} posição {1}: '{2}'. Certifique-se de acentuar as palvras.";
		    msg = string.Format(msg, e.Line, e.CharPositionInLine, e.Token.Text);
	            /*if (paraphrases.Count > 0){
	                string paraphrase = (string)paraphrases.Pop();
	                msg = msg + " " + paraphrase;
	            }*/
	            return msg;
	        }
		protected void mismatch(IIntStream input, int ttype, BitSet follow)	{
			throw new MismatchedTokenException(ttype, input);
		}
		public void recoverFromMismatchedSet(IIntStream input,RecognitionException e, BitSet follow) {
			throw e;
		}

		public List<string> Functions = new List<string>();
		public List<string> Symbols = new List<string>();	
		public bool IsDefinedID(string id){    return Symbols.Contains(id);}
		public bool IsDefined(string name) { return Functions.Contains(name); }
		public void DefineID(IList<IToken> ids){ foreach(var id in ids) { Symbols.Add(id.Text); }}
		public void DefineFunction(string name){ Functions.Add(name);}	


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:8: public script : ( declare_function )* ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<object, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_function1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(77, 34);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:15: ( ( declare_function )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:17: ( declare_function )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(77, 17);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:17: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==65))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:77:17: declare_function
					{
					DebugLocation(77, 17);
					PushFollow(Follow._declare_function_in_script148);
					declare_function1=declare_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declare_function1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(77, 34);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:79:1: declare_function : 'função' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private AstParserRuleReturnScope<object, IToken> declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken i = default(IToken);
		IToken string_literal2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken string_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_param_list4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);

		object i_tree = default(object);
		object string_literal2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal5_tree = default(object);
		object string_literal7_tree = default(object);
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_function_param_list=new RewriteRuleSubtreeStream(adaptor,"rule function_param_list");
		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(79, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:2: ( 'função' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:4: 'função' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim'
			{
			DebugLocation(80, 4);
			string_literal2=(IToken)Match(input,65,Follow._65_in_declare_function159); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_65.Add(string_literal2);

			DebugLocation(80, 14);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_function163); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			DebugLocation(80, 18);
			char_literal3=(IToken)Match(input,42,Follow._42_in_declare_function165); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal3);

			DebugLocation(80, 22);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:22: ( function_param_list )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==ID))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:22: function_param_list
					{
					DebugLocation(80, 22);
					PushFollow(Follow._function_param_list_in_declare_function167);
					function_param_list4=function_param_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_param_list.Add(function_param_list4.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(80, 43);
			char_literal5=(IToken)Match(input,43,Follow._43_in_declare_function170); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_43.Add(char_literal5);

			DebugLocation(80, 47);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:47: ( statement )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==ID||LA3_0==40||LA3_0==62||(LA3_0>=67 && LA3_0<=70)||LA3_0==72))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:80:47: statement
					{
					DebugLocation(80, 47);
					PushFollow(Follow._statement_in_declare_function172);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(80, 58);
			string_literal7=(IToken)Match(input,64,Follow._64_in_declare_function175); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal7);

			DebugLocation(81, 3);
			if (state.backtracking == 0)
			{
				DefineFunction((i!=null?i.Text:null));
			}


			{
			// AST REWRITE
			// elements: ID, statement, function_param_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 82:3: -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
				DebugLocation(82, 6);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:6: ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(82, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(82, 13);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(82, 16);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:16: ( function_param_list )*
				while ( stream_function_param_list.HasNext )
				{
					DebugLocation(82, 16);
					adaptor.AddChild(root_1, stream_function_param_list.NextTree());

				}
				stream_function_param_list.Reset();
				DebugLocation(82, 37);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:37: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(82, 39);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(82, 45);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:45: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(82, 45);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(83, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return retval;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:85:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_local8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_stat9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_stat10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> repeat_stat12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_call13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_var14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_stat15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> asm_code16 = default(AstParserRuleReturnScope<object, IToken>);

		 paraphrases.Push("na sentença"); 
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(85, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:87:2: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | function_call | assign_var | return_stat | asm_code )
			int alt4=9;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case 72:
				{
				alt4 = 1;
				}
				break;
			case 70:
				{
				alt4 = 2;
				}
				break;
			case 67:
				{
				alt4 = 3;
				}
				break;
			case 62:
				{
				alt4 = 4;
				}
				break;
			case 68:
				{
				alt4 = 5;
				}
				break;
			case ID:
				{
				int LA4_6 = input.LA(2);

				if ((LA4_6==42))
				{
					alt4 = 6;
				}
				else if ((LA4_6==53||LA4_6==57))
				{
					alt4 = 7;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 69:
				{
				alt4 = 8;
				}
				break;
			case 40:
				{
				alt4 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:87:4: declare_local
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._declare_local_in_statement222);
				declare_local8=declare_local();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declare_local8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:88:4: if_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._if_stat_in_statement228);
				if_stat9=if_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_stat9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:89:4: for_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._for_stat_in_statement234);
				for_stat10=for_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_stat10.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:90:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._while_stat_in_statement239);
				while_stat11=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat11.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:91:4: repeat_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._repeat_stat_in_statement244);
				repeat_stat12=repeat_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, repeat_stat12.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:92:4: function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(92, 4);
				PushFollow(Follow._function_call_in_statement250);
				function_call13=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call13.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:4: assign_var
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(93, 4);
				PushFollow(Follow._assign_var_in_statement256);
				assign_var14=assign_var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assign_var14.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:94:4: return_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(94, 4);
				PushFollow(Follow._return_stat_in_statement262);
				return_stat15=return_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_stat15.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:95:4: asm_code
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(95, 4);
				PushFollow(Follow._asm_code_in_statement267);
				asm_code16=asm_code();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, asm_code16.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:98:1: function_param_list : ID ( ',' ID )* -> ^( PARAM ( ID )* ) ;
	[GrammarRule("function_param_list")]
	private AstParserRuleReturnScope<object, IToken> function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID17 = default(IToken);
		IToken char_literal18 = default(IToken);
		IToken ID19 = default(IToken);

		object ID17_tree = default(object);
		object char_literal18_tree = default(object);
		object ID19_tree = default(object);
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na lista de parâmetros"); 
		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(98, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:99:2: ( ID ( ',' ID )* -> ^( PARAM ( ID )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:99:4: ID ( ',' ID )*
			{
			DebugLocation(99, 4);
			ID17=(IToken)Match(input,ID,Follow._ID_in_function_param_list295); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID17);

			DebugLocation(99, 7);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:99:7: ( ',' ID )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==46))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:99:8: ',' ID
					{
					DebugLocation(99, 8);
					char_literal18=(IToken)Match(input,46,Follow._46_in_function_param_list298); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_46.Add(char_literal18);

					DebugLocation(99, 12);
					ID19=(IToken)Match(input,ID,Follow._ID_in_function_param_list300); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID19);


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 99:17: -> ^( PARAM ( ID )* )
			{
				DebugLocation(99, 20);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:99:20: ^( PARAM ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(99, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(99, 28);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:99:28: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(99, 28);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(100, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return retval;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:109:1: declare_local : 'variável' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) ;
	[GrammarRule("declare_local")]
	private AstParserRuleReturnScope<object, IToken> declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 5);
		TraceIn("declare_local", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal20 = default(IToken);
		IToken char_literal21 = default(IToken);
		IToken i = default(IToken);
		List<IToken> list_i = null;

		object string_literal20_tree = default(object);
		object char_literal21_tree = default(object);
		object i_tree = default(object);
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		 paraphrases.Push("na definição de variável"); 
		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(109, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:110:2: ( 'variável' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:110:4: 'variável' i+= ID ( ',' i+= ID )*
			{
			DebugLocation(110, 4);
			string_literal20=(IToken)Match(input,72,Follow._72_in_declare_local348); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_72.Add(string_literal20);

			DebugLocation(110, 16);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_local352); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			if (list_i==null) list_i=new List<IToken>();
			list_i.Add(i);

			DebugLocation(110, 21);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:110:21: ( ',' i+= ID )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==46))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:110:22: ',' i+= ID
					{
					DebugLocation(110, 22);
					char_literal21=(IToken)Match(input,46,Follow._46_in_declare_local355); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_46.Add(char_literal21);

					DebugLocation(110, 27);
					i=(IToken)Match(input,ID,Follow._ID_in_declare_local359); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(i);

					if (list_i==null) list_i=new List<IToken>();
					list_i.Add(i);


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(111, 4);
			if (state.backtracking == 0)
			{
				DefineID(list_i);
			}


			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 112:2: -> ^( VAR ( ID )* )
			{
				DebugLocation(112, 5);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:112:5: ^( VAR ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(112, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(112, 11);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:112:11: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(112, 11);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("declare_local", 5);
			LeaveRule("declare_local", 5);
			LeaveRule_declare_local();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return retval;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:1: if_stat : 'se' p= logic_expression 'então' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) ;
	[GrammarRule("if_stat")]
	private AstParserRuleReturnScope<object, IToken> if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 6);
		TraceIn("if_stat", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal22 = default(IToken);
		IToken string_literal23 = default(IToken);
		IToken string_literal24 = default(IToken);
		List<object> list_s1 = null;
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s1 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal22_tree = default(object);
		object string_literal23_tree = default(object);
		object string_literal24_tree = default(object);
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		RewriteRuleSubtreeStream stream_senao_stat=new RewriteRuleSubtreeStream(adaptor,"rule senao_stat");
		 paraphrases.Push("se"); 
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(120, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:122:2: ( 'se' p= logic_expression 'então' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:122:4: 'se' p= logic_expression 'então' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			{
			DebugLocation(122, 4);
			string_literal22=(IToken)Match(input,70,Follow._70_in_if_stat405); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_70.Add(string_literal22);

			DebugLocation(122, 10);
			PushFollow(Follow._logic_expression_in_if_stat409);
			p=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(p.Tree);
			DebugLocation(122, 28);
			string_literal23=(IToken)Match(input,63,Follow._63_in_if_stat411); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal23);

			DebugLocation(122, 38);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:122:38: (s1+= statement )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ID||LA7_0==40||LA7_0==62||(LA7_0>=67 && LA7_0<=70)||LA7_0==72))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:122:38: s1+= statement
					{
					DebugLocation(122, 38);
					PushFollow(Follow._statement_in_if_stat415);
					s1=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s1.Tree);
					if (list_s1==null) list_s1=new List<object>();
					list_s1.Add(s1.Tree);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(123, 2);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:2: (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==71))
			{
				alt8 = 1;
			}
			else if ((LA8_0==64))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:4: s2= senao_stat
				{
				DebugLocation(123, 6);
				PushFollow(Follow._senao_stat_in_if_stat423);
				s2=senao_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_senao_stat.Add(s2.Tree);


				{
				// AST REWRITE
				// elements: p, s1, s2
				// token labels: 
				// rule labels: retval, s2, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s2=new RewriteRuleSubtreeStream(adaptor,"rule s2",s2!=null?s2.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 123:18: -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
				{
					DebugLocation(123, 21);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:21: ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(123, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SJMP, "SJMP"), root_1);

					DebugLocation(123, 28);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:28: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(123, 30);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(123, 36);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(123, 39);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:39: ^( SLIST $s1 $s2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(123, 41);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(123, 48);
					adaptor.AddChild(root_2, stream_s1.NextTree());
					DebugLocation(123, 52);
					adaptor.AddChild(root_2, stream_s2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:124:4: 'fim'
				{
				DebugLocation(124, 4);
				string_literal24=(IToken)Match(input,64,Follow._64_in_if_stat451); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal24);



				{
				// AST REWRITE
				// elements: s1, p
				// token labels: 
				// rule labels: retval, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 124:10: -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
				{
					DebugLocation(124, 13);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:124:13: ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(124, 15);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(JMP, "JMP"), root_1);

					DebugLocation(124, 19);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:124:19: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(124, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(124, 27);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(124, 30);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:124:30: ^( SLIST ( $s1)* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(124, 32);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(124, 39);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:124:39: ( $s1)*
					while ( stream_s1.HasNext )
					{
						DebugLocation(124, 39);
						adaptor.AddChild(root_2, stream_s1.NextTree());

					}
					stream_s1.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("if_stat", 6);
			LeaveRule("if_stat", 6);
			LeaveRule_if_stat();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return retval;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:128:1: senao_stat : 'senão' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private AstParserRuleReturnScope<object, IToken> senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 7);
		TraceIn("senao_stat", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal25 = default(IToken);
		IToken string_literal26 = default(IToken);
		List<object> list_s2 = null;
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal25_tree = default(object);
		object string_literal26_tree = default(object);
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(128, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:2: ( 'senão' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:4: 'senão' (s2+= statement )* 'fim'
			{
			DebugLocation(129, 4);
			string_literal25=(IToken)Match(input,71,Follow._71_in_senao_stat487); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_71.Add(string_literal25);

			DebugLocation(129, 14);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:14: (s2+= statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==ID||LA9_0==40||LA9_0==62||(LA9_0>=67 && LA9_0<=70)||LA9_0==72))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:14: s2+= statement
					{
					DebugLocation(129, 14);
					PushFollow(Follow._statement_in_senao_stat491);
					s2=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s2.Tree);
					if (list_s2==null) list_s2=new List<object>();
					list_s2.Add(s2.Tree);


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(129, 27);
			string_literal26=(IToken)Match(input,64,Follow._64_in_senao_stat494); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal26);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 129:33: -> ^( SLIST ( statement )* )
			{
				DebugLocation(129, 36);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:36: ^( SLIST ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(129, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_1);

				DebugLocation(129, 44);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:129:44: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(129, 44);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("senao_stat", 7);
			LeaveRule("senao_stat", 7);
			LeaveRule_senao_stat();
		}
		DebugLocation(130, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return retval;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:1: for_stat : 'para' assign_var 'até' index ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) ;
	[GrammarRule("for_stat")]
	private AstParserRuleReturnScope<object, IToken> for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 8);
		TraceIn("for_stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal27 = default(IToken);
		IToken string_literal29 = default(IToken);
		IToken string_literal31 = default(IToken);
		IToken string_literal33 = default(IToken);
		IToken string_literal35 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_var28 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index30 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement32 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement34 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal27_tree = default(object);
		object string_literal29_tree = default(object);
		object string_literal31_tree = default(object);
		object string_literal33_tree = default(object);
		object string_literal35_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		RewriteRuleSubtreeStream stream_assign_var=new RewriteRuleSubtreeStream(adaptor,"rule assign_var");
		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(132, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:9: ( 'para' assign_var 'até' index ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:11: 'para' assign_var 'até' index ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			{
			DebugLocation(132, 11);
			string_literal27=(IToken)Match(input,67,Follow._67_in_for_stat514); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal27);

			DebugLocation(132, 18);
			PushFollow(Follow._assign_var_in_for_stat516);
			assign_var28=assign_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_var.Add(assign_var28.Tree);
			DebugLocation(132, 29);
			string_literal29=(IToken)Match(input,59,Follow._59_in_for_stat518); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(string_literal29);

			DebugLocation(132, 35);
			PushFollow(Follow._index_in_for_stat520);
			index30=index();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index.Add(index30.Tree);
			DebugLocation(134, 3);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:3: ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==60))
			{
				alt12 = 1;
			}
			else if ((LA12_0==ID||LA12_0==40||LA12_0==62||LA12_0==64||(LA12_0>=67 && LA12_0<=70)||LA12_0==72))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:5: 'decrescente' ( statement )* 'fim'
				{
				DebugLocation(134, 5);
				string_literal31=(IToken)Match(input,60,Follow._60_in_for_stat528); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_60.Add(string_literal31);

				DebugLocation(134, 19);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:19: ( statement )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if ((LA10_0==ID||LA10_0==40||LA10_0==62||(LA10_0>=67 && LA10_0<=70)||LA10_0==72))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:19: statement
						{
						DebugLocation(134, 19);
						PushFollow(Follow._statement_in_for_stat530);
						statement32=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement32.Tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(134, 30);
				string_literal33=(IToken)Match(input,64,Follow._64_in_for_stat533); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal33);



				{
				// AST REWRITE
				// elements: assign_var, statement, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 134:36: -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(134, 39);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:39: ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(134, 41);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(134, 46);
					adaptor.AddChild(root_1, (object)adaptor.Create(DEC, "DEC"));
					DebugLocation(134, 50);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(134, 61);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(134, 67);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:67: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(134, 69);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(134, 75);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:134:75: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(134, 75);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:5: ( statement )* 'fim'
				{
				DebugLocation(135, 5);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:5: ( statement )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==ID||LA11_0==40||LA11_0==62||(LA11_0>=67 && LA11_0<=70)||LA11_0==72))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:5: statement
						{
						DebugLocation(135, 5);
						PushFollow(Follow._statement_in_for_stat558);
						statement34=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement34.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(135, 16);
				string_literal35=(IToken)Match(input,64,Follow._64_in_for_stat561); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_64.Add(string_literal35);



				{
				// AST REWRITE
				// elements: index, assign_var, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 135:22: -> ^( LOOP assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(135, 25);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:25: ^( LOOP assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(135, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(135, 32);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(135, 43);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(135, 49);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:49: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(135, 51);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(135, 57);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:57: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(135, 57);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("for_stat", 8);
			LeaveRule("for_stat", 8);
			LeaveRule_for_stat();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return retval;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:139:1: while_stat : 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 9);
		TraceIn("while_stat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal36 = default(IToken);
		IToken string_literal39 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_expression37 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement38 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal36_tree = default(object);
		object string_literal39_tree = default(object);
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(139, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:140:2: ( 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:140:4: 'enquanto' logic_expression ( statement )* 'fim'
			{
			DebugLocation(140, 4);
			string_literal36=(IToken)Match(input,62,Follow._62_in_while_stat594); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(string_literal36);

			DebugLocation(140, 15);
			PushFollow(Follow._logic_expression_in_while_stat596);
			logic_expression37=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression37.Tree);
			DebugLocation(140, 32);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:140:32: ( statement )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==ID||LA13_0==40||LA13_0==62||(LA13_0>=67 && LA13_0<=70)||LA13_0==72))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:140:32: statement
					{
					DebugLocation(140, 32);
					PushFollow(Follow._statement_in_while_stat598);
					statement38=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement38.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(140, 43);
			string_literal39=(IToken)Match(input,64,Follow._64_in_while_stat601); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal39);



			{
			// AST REWRITE
			// elements: statement, logic_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 141:3: -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
				DebugLocation(141, 6);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:141:6: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(141, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(141, 13);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:141:13: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(141, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(141, 20);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(141, 38);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:141:38: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(141, 40);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(141, 46);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:141:46: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(141, 46);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("while_stat", 9);
			LeaveRule("while_stat", 9);
			LeaveRule_while_stat();
		}
		DebugLocation(142, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:144:1: repeat_stat : 'repita' ( statement )* 'até' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private AstParserRuleReturnScope<object, IToken> repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 10);
		TraceIn("repeat_stat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal40 = default(IToken);
		IToken string_literal42 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_expression43 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal40_tree = default(object);
		object string_literal42_tree = default(object);
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(144, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:144:13: ( 'repita' ( statement )* 'até' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:144:15: 'repita' ( statement )* 'até' logic_expression
			{
			DebugLocation(144, 15);
			string_literal40=(IToken)Match(input,68,Follow._68_in_repeat_stat633); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(string_literal40);

			DebugLocation(144, 24);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:144:24: ( statement )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ID||LA14_0==40||LA14_0==62||(LA14_0>=67 && LA14_0<=70)||LA14_0==72))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:144:24: statement
					{
					DebugLocation(144, 24);
					PushFollow(Follow._statement_in_repeat_stat635);
					statement41=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement41.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(144, 35);
			string_literal42=(IToken)Match(input,59,Follow._59_in_repeat_stat638); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(string_literal42);

			DebugLocation(144, 41);
			PushFollow(Follow._logic_expression_in_repeat_stat640);
			logic_expression43=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression43.Tree);


			{
			// AST REWRITE
			// elements: logic_expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 145:3: -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
				DebugLocation(145, 6);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:145:6: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(145, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(145, 13);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:145:13: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(145, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(145, 21);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:145:21: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(145, 21);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(145, 33);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:145:33: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(145, 35);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(145, 40);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("repeat_stat", 10);
			LeaveRule("repeat_stat", 10);
			LeaveRule_repeat_stat();
		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return retval;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:148:1: function_call : ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private AstParserRuleReturnScope<object, IToken> function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 11);
		TraceIn("function_call", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID44 = default(IToken);
		IToken char_literal45 = default(IToken);
		IToken char_literal47 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list46 = default(AstParserRuleReturnScope<object, IToken>);

		object ID44_tree = default(object);
		object char_literal45_tree = default(object);
		object char_literal47_tree = default(object);
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de função"); 
		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(148, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:2: ( ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:4: ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(149, 4);
			ID44=(IToken)Match(input,ID,Follow._ID_in_function_call688); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID44);

			DebugLocation(149, 7);
			char_literal45=(IToken)Match(input,42,Follow._42_in_function_call690); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal45);

			DebugLocation(149, 11);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: ( function_arg_list )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if (((LA15_0>=F && LA15_0<=FLOAT)||LA15_0==ID||LA15_0==INT||(LA15_0>=STRING && LA15_0<=T)||LA15_0==42))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: function_arg_list
					{
					DebugLocation(149, 11);
					PushFollow(Follow._function_arg_list_in_function_call692);
					function_arg_list46=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list46.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(149, 30);
			char_literal47=(IToken)Match(input,43,Follow._43_in_function_call695); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_43.Add(char_literal47);



			{
			// AST REWRITE
			// elements: function_arg_list, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 149:34: -> ^( CALL ID ( function_arg_list )* )
			{
				DebugLocation(149, 37);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:37: ^( CALL ID ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(149, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(149, 44);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(149, 47);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:47: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(149, 47);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("function_call", 11);
			LeaveRule("function_call", 11);
			LeaveRule_function_call();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return retval;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:152:1: property_call : o= ID '.' p= ID -> ^( PCALL $o $p) ;
	[GrammarRule("property_call")]
	private AstParserRuleReturnScope<object, IToken> property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 12);
		TraceIn("property_call", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal48 = default(IToken);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal48_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(152, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:153:2: (o= ID '.' p= ID -> ^( PCALL $o $p) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:153:4: o= ID '.' p= ID
			{
			DebugLocation(153, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_property_call736); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(153, 8);
			char_literal48=(IToken)Match(input,48,Follow._48_in_property_call737); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal48);

			DebugLocation(153, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_property_call740); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);



			{
			// AST REWRITE
			// elements: p, o
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 153:17: -> ^( PCALL $o $p)
			{
				DebugLocation(153, 20);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:153:20: ^( PCALL $o $p)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(153, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PCALL, "PCALL"), root_1);

				DebugLocation(153, 29);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(153, 32);
				adaptor.AddChild(root_1, stream_p.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("property_call", 12);
			LeaveRule("property_call", 12);
			LeaveRule_property_call();
		}
		DebugLocation(154, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return retval;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:1: method_call : o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private AstParserRuleReturnScope<object, IToken> method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 13);
		TraceIn("method_call", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal49 = default(IToken);
		IToken char_literal50 = default(IToken);
		IToken char_literal52 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list51 = default(AstParserRuleReturnScope<object, IToken>);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal49_tree = default(object);
		object char_literal50_tree = default(object);
		object char_literal52_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(156, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:2: (o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:4: o= ID '.' p= ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(157, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_method_call784); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(157, 8);
			char_literal49=(IToken)Match(input,48,Follow._48_in_method_call785); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal49);

			DebugLocation(157, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_method_call788); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);

			DebugLocation(157, 16);
			char_literal50=(IToken)Match(input,42,Follow._42_in_method_call790); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal50);

			DebugLocation(157, 20);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: ( function_arg_list )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if (((LA16_0>=F && LA16_0<=FLOAT)||LA16_0==ID||LA16_0==INT||(LA16_0>=STRING && LA16_0<=T)||LA16_0==42))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: function_arg_list
					{
					DebugLocation(157, 20);
					PushFollow(Follow._function_arg_list_in_method_call792);
					function_arg_list51=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list51.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(157, 39);
			char_literal52=(IToken)Match(input,43,Follow._43_in_method_call795); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_43.Add(char_literal52);



			{
			// AST REWRITE
			// elements: p, o, function_arg_list
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 157:43: -> ^( MCALL $o $p ( function_arg_list )* )
			{
				DebugLocation(157, 46);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:46: ^( MCALL $o $p ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(157, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(MCALL, "MCALL"), root_1);

				DebugLocation(157, 55);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(157, 58);
				adaptor.AddChild(root_1, stream_p.NextNode());
				DebugLocation(157, 60);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:60: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(157, 60);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("method_call", 13);
			LeaveRule("method_call", 13);
			LeaveRule_method_call();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return retval;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:160:1: function_arg_list : plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private AstParserRuleReturnScope<object, IToken> function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 14);
		TraceIn("function_arg_list", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal54 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression53 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression55 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal54_tree = default(object);
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		 paraphrases.Push("nos argumentos da função"); 
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(160, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:2: ( plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:4: plus_expression ( ',' plus_expression )*
			{
			DebugLocation(162, 4);
			PushFollow(Follow._plus_expression_in_function_arg_list840);
			plus_expression53=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression53.Tree);
			DebugLocation(162, 20);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:20: ( ',' plus_expression )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==46))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:21: ',' plus_expression
					{
					DebugLocation(162, 21);
					char_literal54=(IToken)Match(input,46,Follow._46_in_function_arg_list843); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_46.Add(char_literal54);

					DebugLocation(162, 25);
					PushFollow(Follow._plus_expression_in_function_arg_list845);
					plus_expression55=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_plus_expression.Add(plus_expression55.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 162:43: -> ^( ARG ( plus_expression )* )
			{
				DebugLocation(162, 46);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:46: ^( ARG ( plus_expression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(162, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(162, 52);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:52: ( plus_expression )*
				while ( stream_plus_expression.HasNext )
				{
					DebugLocation(162, 52);
					adaptor.AddChild(root_1, stream_plus_expression.NextTree());

				}
				stream_plus_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("function_arg_list", 14);
			LeaveRule("function_arg_list", 14);
			LeaveRule_function_arg_list();
		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return retval;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:165:1: assign_var : ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) );
	[GrammarRule("assign_var")]
	private AstParserRuleReturnScope<object, IToken> assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 15);
		TraceIn("assign_var", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID56 = default(IToken);
		IToken char_literal57 = default(IToken);
		IToken char_literal58 = default(IToken);
		IToken INT59 = default(IToken);
		IToken string_literal60 = default(IToken);
		IToken INT61 = default(IToken);
		IToken char_literal62 = default(IToken);
		IToken ID63 = default(IToken);
		IToken char_literal64 = default(IToken);
		IToken char_literal65 = default(IToken);
		IToken INT66 = default(IToken);
		IToken char_literal67 = default(IToken);
		IToken INT68 = default(IToken);
		IToken char_literal69 = default(IToken);
		IToken ID70 = default(IToken);
		IToken char_literal71 = default(IToken);
		IToken char_literal73 = default(IToken);
		IToken char_literal74 = default(IToken);
		IToken ID76 = default(IToken);
		IToken char_literal77 = default(IToken);
		AstParserRuleReturnScope<object, IToken> index72 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression75 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression78 = default(AstParserRuleReturnScope<object, IToken>);

		object ID56_tree = default(object);
		object char_literal57_tree = default(object);
		object char_literal58_tree = default(object);
		object INT59_tree = default(object);
		object string_literal60_tree = default(object);
		object INT61_tree = default(object);
		object char_literal62_tree = default(object);
		object ID63_tree = default(object);
		object char_literal64_tree = default(object);
		object char_literal65_tree = default(object);
		object INT66_tree = default(object);
		object char_literal67_tree = default(object);
		object INT68_tree = default(object);
		object char_literal69_tree = default(object);
		object ID70_tree = default(object);
		object char_literal71_tree = default(object);
		object char_literal73_tree = default(object);
		object char_literal74_tree = default(object);
		object ID76_tree = default(object);
		object char_literal77_tree = default(object);
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleITokenStream stream_74=new RewriteRuleITokenStream(adaptor,"token 74");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		 paraphrases.Push("na atribuição de variável"); 
		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(165, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:166:2: ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ',' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) )
			int alt19=4;
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==ID))
			{
				int LA19_1 = input.LA(2);

				if ((LA19_1==53))
				{
					int LA19_2 = input.LA(3);

					if ((EvaluatePredicate(synpred25_NPortugol_fragment)))
					{
						alt19 = 1;
					}
					else if ((EvaluatePredicate(synpred27_NPortugol_fragment)))
					{
						alt19 = 2;
					}
					else if ((true))
					{
						alt19 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 19, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA19_1==57))
				{
					alt19 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 19, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:9: ID '=' '[' INT '..' INT ']'
				{
				DebugLocation(167, 9);
				ID56=(IToken)Match(input,ID,Follow._ID_in_assign_var897); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID56);

				DebugLocation(167, 12);
				char_literal57=(IToken)Match(input,53,Follow._53_in_assign_var899); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal57);

				DebugLocation(167, 16);
				char_literal58=(IToken)Match(input,57,Follow._57_in_assign_var901); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal58);

				DebugLocation(167, 20);
				INT59=(IToken)Match(input,INT,Follow._INT_in_assign_var903); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT59);

				DebugLocation(167, 24);
				string_literal60=(IToken)Match(input,49,Follow._49_in_assign_var905); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(string_literal60);

				DebugLocation(167, 29);
				INT61=(IToken)Match(input,INT,Follow._INT_in_assign_var907); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT61);

				DebugLocation(167, 33);
				char_literal62=(IToken)Match(input,58,Follow._58_in_assign_var909); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_58.Add(char_literal62);



				{
				// AST REWRITE
				// elements: INT, INT, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 167:37: -> ^( ASGN ID INT INT )
				{
					DebugLocation(167, 40);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:40: ^( ASGN ID INT INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(167, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(167, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(167, 50);
					adaptor.AddChild(root_1, stream_INT.NextNode());
					DebugLocation(167, 54);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:10: ID '=' '{' INT ( ',' INT )* '}'
				{
				DebugLocation(168, 10);
				ID63=(IToken)Match(input,ID,Follow._ID_in_assign_var932); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID63);

				DebugLocation(168, 13);
				char_literal64=(IToken)Match(input,53,Follow._53_in_assign_var934); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal64);

				DebugLocation(168, 17);
				char_literal65=(IToken)Match(input,73,Follow._73_in_assign_var936); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_73.Add(char_literal65);

				DebugLocation(168, 21);
				INT66=(IToken)Match(input,INT,Follow._INT_in_assign_var938); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT66);

				DebugLocation(168, 25);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:25: ( ',' INT )*
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_0 = input.LA(1);

					if ((LA18_0==46))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch ( alt18 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:26: ',' INT
						{
						DebugLocation(168, 26);
						char_literal67=(IToken)Match(input,46,Follow._46_in_assign_var941); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_46.Add(char_literal67);

						DebugLocation(168, 30);
						INT68=(IToken)Match(input,INT,Follow._INT_in_assign_var943); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT68);


						}
						break;

					default:
						goto loop18;
					}
				}

				loop18:
					;

				} finally { DebugExitSubRule(18); }

				DebugLocation(168, 36);
				char_literal69=(IToken)Match(input,74,Follow._74_in_assign_var947); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_74.Add(char_literal69);



				{
				// AST REWRITE
				// elements: INT, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 168:40: -> ^( ASGN ID ^( ILIST ( INT )* ) )
				{
					DebugLocation(168, 43);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:43: ^( ASGN ID ^( ILIST ( INT )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(168, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(168, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(168, 53);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:53: ^( ILIST ( INT )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(168, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ILIST, "ILIST"), root_2);

					DebugLocation(168, 61);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:61: ( INT )*
					while ( stream_INT.HasNext )
					{
						DebugLocation(168, 61);
						adaptor.AddChild(root_2, stream_INT.NextNode());

					}
					stream_INT.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:169:4: ID '[' index ']' '=' assign_expression
				{
				DebugLocation(169, 4);
				ID70=(IToken)Match(input,ID,Follow._ID_in_assign_var967); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID70);

				DebugLocation(169, 7);
				char_literal71=(IToken)Match(input,57,Follow._57_in_assign_var969); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal71);

				DebugLocation(169, 11);
				PushFollow(Follow._index_in_assign_var971);
				index72=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index72.Tree);
				DebugLocation(169, 17);
				char_literal73=(IToken)Match(input,58,Follow._58_in_assign_var973); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_58.Add(char_literal73);

				DebugLocation(169, 21);
				char_literal74=(IToken)Match(input,53,Follow._53_in_assign_var975); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal74);

				DebugLocation(169, 25);
				PushFollow(Follow._assign_expression_in_assign_var977);
				assign_expression75=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression75.Tree);


				{
				// AST REWRITE
				// elements: index, ID, assign_expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 169:44: -> ^( ASGN ^( AR index ) ID assign_expression )
				{
					DebugLocation(169, 47);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:169:47: ^( ASGN ^( AR index ) ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(169, 49);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(169, 54);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:169:54: ^( AR index )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(169, 56);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(AR, "AR"), root_2);

					DebugLocation(169, 59);
					adaptor.AddChild(root_2, stream_index.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(169, 66);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(169, 69);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:170:11: ID '=' assign_expression
				{
				DebugLocation(170, 11);
				ID76=(IToken)Match(input,ID,Follow._ID_in_assign_var1006); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID76);

				DebugLocation(170, 14);
				char_literal77=(IToken)Match(input,53,Follow._53_in_assign_var1008); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(char_literal77);

				DebugLocation(170, 18);
				PushFollow(Follow._assign_expression_in_assign_var1010);
				assign_expression78=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression78.Tree);


				{
				// AST REWRITE
				// elements: assign_expression, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 170:37: -> ^( ASGN ID assign_expression )
				{
					DebugLocation(170, 40);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:170:40: ^( ASGN ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(170, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(170, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(170, 50);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("assign_var", 15);
			LeaveRule("assign_var", 15);
			LeaveRule_assign_var();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return retval;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:173:1: return_stat : 'retorne' assign_expression -> ^( RET assign_expression ) ;
	[GrammarRule("return_stat")]
	private AstParserRuleReturnScope<object, IToken> return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 16);
		TraceIn("return_stat", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_expression80 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal79_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(173, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:174:2: ( 'retorne' assign_expression -> ^( RET assign_expression ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:174:4: 'retorne' assign_expression
			{
			DebugLocation(174, 4);
			string_literal79=(IToken)Match(input,69,Follow._69_in_return_stat1033); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal79);

			DebugLocation(174, 14);
			PushFollow(Follow._assign_expression_in_return_stat1035);
			assign_expression80=assign_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_expression.Add(assign_expression80.Tree);


			{
			// AST REWRITE
			// elements: assign_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 174:33: -> ^( RET assign_expression )
			{
				DebugLocation(174, 36);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:174:36: ^( RET assign_expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(174, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RET, "RET"), root_1);

				DebugLocation(174, 42);
				adaptor.AddChild(root_1, stream_assign_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("return_stat", 16);
			LeaveRule("return_stat", 16);
			LeaveRule_return_stat();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return retval;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_asm_code();
	partial void LeaveRule_asm_code();

	// $ANTLR start "asm_code"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:1: asm_code : '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) ;
	[GrammarRule("asm_code")]
	private AstParserRuleReturnScope<object, IToken> asm_code()
	{
		EnterRule_asm_code();
		EnterRule("asm_code", 17);
		TraceIn("asm_code", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal81 = default(IToken);
		IToken STRING82 = default(IToken);
		IToken char_literal83 = default(IToken);

		object char_literal81_tree = default(object);
		object STRING82_tree = default(object);
		object char_literal83_tree = default(object);
		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "asm_code");
		DebugLocation(178, 8);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:9: ( '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:11: '#' ( STRING )* '#'
			{
			DebugLocation(178, 11);
			char_literal81=(IToken)Match(input,40,Follow._40_in_asm_code1054); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_40.Add(char_literal81);

			DebugLocation(178, 15);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:15: ( STRING )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==STRING))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:15: STRING
					{
					DebugLocation(178, 15);
					STRING82=(IToken)Match(input,STRING,Follow._STRING_in_asm_code1056); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_STRING.Add(STRING82);


					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(178, 23);
			char_literal83=(IToken)Match(input,40,Follow._40_in_asm_code1059); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_40.Add(char_literal83);



			{
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 178:27: -> ^( ASM ( STRING )* )
			{
				DebugLocation(178, 30);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:30: ^( ASM ( STRING )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(178, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASM, "ASM"), root_1);

				DebugLocation(178, 36);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:36: ( STRING )*
				while ( stream_STRING.HasNext )
				{
					DebugLocation(178, 36);
					adaptor.AddChild(root_1, stream_STRING.NextNode());

				}
				stream_STRING.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("asm_code", 17);
			LeaveRule("asm_code", 17);
			LeaveRule_asm_code();
		}
		DebugLocation(179, 8);
		} finally { DebugExitRule(GrammarFileName, "asm_code"); }
		return retval;

	}
	// $ANTLR end "asm_code"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:185:1: logic_expression : ( plus_expression ) ( binop ^ plus_expression )* ;
	[GrammarRule("logic_expression")]
	private AstParserRuleReturnScope<object, IToken> logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 18);
		TraceIn("logic_expression", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression84 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binop85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression86 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(185, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:2: ( ( plus_expression ) ( binop ^ plus_expression )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:4: ( plus_expression ) ( binop ^ plus_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(186, 4);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:4: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:5: plus_expression
			{
			DebugLocation(186, 5);
			PushFollow(Follow._plus_expression_in_logic_expression1091);
			plus_expression84=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression84.Tree);

			}

			DebugLocation(186, 22);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:22: ( binop ^ plus_expression )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==39||(LA21_0>=51 && LA21_0<=52)||(LA21_0>=54 && LA21_0<=56)||LA21_0==61||LA21_0==66))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:23: binop ^ plus_expression
					{
					DebugLocation(186, 28);
					PushFollow(Follow._binop_in_logic_expression1095);
					binop85=binop();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(binop85.Tree, root_0);
					DebugLocation(186, 30);
					PushFollow(Follow._plus_expression_in_logic_expression1098);
					plus_expression86=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression86.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("logic_expression", 18);
			LeaveRule("logic_expression", 18);
			LeaveRule_logic_expression();
		}
		DebugLocation(187, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return retval;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_binop();
	partial void LeaveRule_binop();

	// $ANTLR start "binop"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:189:1: binop : ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' );
	[GrammarRule("binop")]
	private AstParserRuleReturnScope<object, IToken> binop()
	{
		EnterRule_binop();
		EnterRule("binop", 19);
		TraceIn("binop", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set87 = default(IToken);

		object set87_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binop");
		DebugLocation(189, 59);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:189:7: ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(189, 7);

			set87=(IToken)input.LT(1);
			if (input.LA(1)==39||(input.LA(1)>=51 && input.LA(1)<=52)||(input.LA(1)>=54 && input.LA(1)<=56)||input.LA(1)==61||input.LA(1)==66)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set87));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("binop", 19);
			LeaveRule("binop", 19);
			LeaveRule_binop();
		}
		DebugLocation(189, 59);
		} finally { DebugExitRule(GrammarFileName, "binop"); }
		return retval;

	}
	// $ANTLR end "binop"

	partial void EnterRule_assign_expression();
	partial void LeaveRule_assign_expression();

	// $ANTLR start "assign_expression"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:1: assign_expression options {k=3; } : plus_expression ;
	[GrammarRule("assign_expression")]
	private AstParserRuleReturnScope<object, IToken> assign_expression()
	{
		EnterRule_assign_expression();
		EnterRule("assign_expression", 20);
		TraceIn("assign_expression", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression88 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_expression");
		DebugLocation(192, 19);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:194:2: ( plus_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:194:5: plus_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(194, 5);
			PushFollow(Follow._plus_expression_in_assign_expression1159);
			plus_expression88=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression88.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("assign_expression", 20);
			LeaveRule("assign_expression", 20);
			LeaveRule_assign_expression();
		}
		DebugLocation(194, 19);
		} finally { DebugExitRule(GrammarFileName, "assign_expression"); }
		return retval;

	}
	// $ANTLR end "assign_expression"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:1: plus_expression : ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* ;
	[GrammarRule("plus_expression")]
	private AstParserRuleReturnScope<object, IToken> plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 21);
		TraceIn("plus_expression", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal90 = default(IToken);
		IToken char_literal92 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expression89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression91 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression93 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal90_tree = default(object);
		object char_literal92_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(196, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:2: ( ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:4: ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(197, 4);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:4: ( mul_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:5: mul_expression
			{
			DebugLocation(197, 5);
			PushFollow(Follow._mul_expression_in_plus_expression1169);
			mul_expression89=mul_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression89.Tree);

			}

			DebugLocation(197, 21);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:21: ( '+' ^ mul_expression | '-' ^ mul_expression )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=3;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==45))
				{
					alt22 = 1;
				}
				else if ((LA22_0==47))
				{
					alt22 = 2;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:22: '+' ^ mul_expression
					{
					DebugLocation(197, 25);
					char_literal90=(IToken)Match(input,45,Follow._45_in_plus_expression1173); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal90_tree = (object)adaptor.Create(char_literal90);
					root_0 = (object)adaptor.BecomeRoot(char_literal90_tree, root_0);
					}
					DebugLocation(197, 27);
					PushFollow(Follow._mul_expression_in_plus_expression1176);
					mul_expression91=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression91.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:44: '-' ^ mul_expression
					{
					DebugLocation(197, 47);
					char_literal92=(IToken)Match(input,47,Follow._47_in_plus_expression1180); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal92_tree = (object)adaptor.Create(char_literal92);
					root_0 = (object)adaptor.BecomeRoot(char_literal92_tree, root_0);
					}
					DebugLocation(197, 49);
					PushFollow(Follow._mul_expression_in_plus_expression1183);
					mul_expression93=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression93.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("plus_expression", 21);
			LeaveRule("plus_expression", 21);
			LeaveRule_plus_expression();
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return retval;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_mul_expression();
	partial void LeaveRule_mul_expression();

	// $ANTLR start "mul_expression"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:200:1: mul_expression : ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* ;
	[GrammarRule("mul_expression")]
	private AstParserRuleReturnScope<object, IToken> mul_expression()
	{
		EnterRule_mul_expression();
		EnterRule("mul_expression", 22);
		TraceIn("mul_expression", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal95 = default(IToken);
		IToken char_literal97 = default(IToken);
		IToken char_literal99 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression94 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression100 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal95_tree = default(object);
		object char_literal97_tree = default(object);
		object char_literal99_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expression");
		DebugLocation(200, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:2: ( ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(201, 4);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ( primary_ar_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:5: primary_ar_expression
			{
			DebugLocation(201, 5);
			PushFollow(Follow._primary_ar_expression_in_mul_expression1198);
			primary_ar_expression94=primary_ar_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression94.Tree);

			}

			DebugLocation(201, 28);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:28: ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=4;
				try { DebugEnterDecision(23, false);
				switch (input.LA(1))
				{
				case 50:
					{
					alt23 = 1;
					}
					break;
				case 41:
					{
					alt23 = 2;
					}
					break;
				case 44:
					{
					alt23 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:30: '/' ^ primary_ar_expression
					{
					DebugLocation(201, 33);
					char_literal95=(IToken)Match(input,50,Follow._50_in_mul_expression1203); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal95_tree = (object)adaptor.Create(char_literal95);
					root_0 = (object)adaptor.BecomeRoot(char_literal95_tree, root_0);
					}
					DebugLocation(201, 35);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1206);
					primary_ar_expression96=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression96.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:59: '%' ^ primary_ar_expression
					{
					DebugLocation(201, 62);
					char_literal97=(IToken)Match(input,41,Follow._41_in_mul_expression1210); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal97_tree = (object)adaptor.Create(char_literal97);
					root_0 = (object)adaptor.BecomeRoot(char_literal97_tree, root_0);
					}
					DebugLocation(201, 64);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1213);
					primary_ar_expression98=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression98.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:88: '*' ^ primary_ar_expression
					{
					DebugLocation(201, 91);
					char_literal99=(IToken)Match(input,44,Follow._44_in_mul_expression1217); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal99_tree = (object)adaptor.Create(char_literal99);
					root_0 = (object)adaptor.BecomeRoot(char_literal99_tree, root_0);
					}
					DebugLocation(201, 93);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1220);
					primary_ar_expression100=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression100.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("mul_expression", 22);
			LeaveRule("mul_expression", 22);
			LeaveRule_mul_expression();
		}
		DebugLocation(202, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expression"); }
		return retval;

	}
	// $ANTLR end "mul_expression"

	partial void EnterRule_primary_ar_expression();
	partial void LeaveRule_primary_ar_expression();

	// $ANTLR start "primary_ar_expression"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:204:1: primary_ar_expression : ({...}? => function_call | ID | T | F | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression );
	[GrammarRule("primary_ar_expression")]
	private AstParserRuleReturnScope<object, IToken> primary_ar_expression()
	{
		EnterRule_primary_ar_expression();
		EnterRule("primary_ar_expression", 23);
		TraceIn("primary_ar_expression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID102 = default(IToken);
		IToken T103 = default(IToken);
		IToken F104 = default(IToken);
		IToken ID105 = default(IToken);
		IToken char_literal106 = default(IToken);
		IToken char_literal108 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_call101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method_call109 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property_call110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesisExpression112 = default(AstParserRuleReturnScope<object, IToken>);

		object ID102_tree = default(object);
		object T103_tree = default(object);
		object F104_tree = default(object);
		object ID105_tree = default(object);
		object char_literal106_tree = default(object);
		object char_literal108_tree = default(object);
		RewriteRuleITokenStream stream_58=new RewriteRuleITokenStream(adaptor,"token 58");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		try { DebugEnterRule(GrammarFileName, "primary_ar_expression");
		DebugLocation(204, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:2: ({...}? => function_call | ID | T | F | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression )
			int alt24=9;
			try { DebugEnterDecision(24, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case 42:
					{
					int LA24_6 = input.LA(3);

					if ((((( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )&&( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" ))&&EvaluatePredicate(synpred43_NPortugol_fragment))))
					{
						alt24 = 1;
					}
					else if ((EvaluatePredicate(synpred44_NPortugol_fragment)))
					{
						alt24 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 24, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 57:
					{
					alt24 = 5;
					}
					break;
				case 48:
					{
					int LA24_8 = input.LA(3);

					if ((EvaluatePredicate(synpred48_NPortugol_fragment)))
					{
						alt24 = 6;
					}
					else if ((EvaluatePredicate(synpred49_NPortugol_fragment)))
					{
						alt24 = 7;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 24, 8, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case EOF:
				case F:
				case FLOAT:
				case ID:
				case INT:
				case STRING:
				case T:
				case 39:
				case 40:
				case 41:
				case 43:
				case 44:
				case 45:
				case 46:
				case 47:
				case 50:
				case 51:
				case 52:
				case 54:
				case 55:
				case 56:
				case 59:
				case 61:
				case 62:
				case 63:
				case 64:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
					{
					alt24 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 24, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case T:
				{
				alt24 = 3;
				}
				break;
			case F:
				{
				alt24 = 4;
				}
				break;
			case FLOAT:
			case INT:
			case STRING:
				{
				alt24 = 8;
				}
				break;
			case 42:
				{
				alt24 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 24, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: {...}? => function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(205, 4);
				if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary_ar_expression", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
				}
				DebugLocation(205, 71);
				PushFollow(Follow._function_call_in_primary_ar_expression1238);
				function_call101=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call101.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(206, 4);
				ID102=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1243); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID102_tree = (object)adaptor.Create(ID102);
				adaptor.AddChild(root_0, ID102_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:207:4: T
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(207, 4);
				T103=(IToken)Match(input,T,Follow._T_in_primary_ar_expression1248); if (state.failed) return retval;
				if (state.backtracking == 0) {
				T103_tree = (object)adaptor.Create(T103);
				adaptor.AddChild(root_0, T103_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:208:4: F
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(208, 4);
				F104=(IToken)Match(input,F,Follow._F_in_primary_ar_expression1253); if (state.failed) return retval;
				if (state.backtracking == 0) {
				F104_tree = (object)adaptor.Create(F104);
				adaptor.AddChild(root_0, F104_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:4: ID '[' index ']'
				{
				DebugLocation(209, 4);
				ID105=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1258); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID105);

				DebugLocation(209, 7);
				char_literal106=(IToken)Match(input,57,Follow._57_in_primary_ar_expression1260); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal106);

				DebugLocation(209, 11);
				PushFollow(Follow._index_in_primary_ar_expression1262);
				index107=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index107.Tree);
				DebugLocation(209, 17);
				char_literal108=(IToken)Match(input,58,Follow._58_in_primary_ar_expression1264); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_58.Add(char_literal108);



				{
				// AST REWRITE
				// elements: index, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 209:21: -> ^( INDEX index ) ID
				{
					DebugLocation(209, 24);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:24: ^( INDEX index )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(209, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_1);

					DebugLocation(209, 32);
					adaptor.AddChild(root_1, stream_index.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(209, 39);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:210:4: method_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(210, 4);
				PushFollow(Follow._method_call_in_primary_ar_expression1279);
				method_call109=method_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, method_call109.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:211:4: property_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(211, 4);
				PushFollow(Follow._property_call_in_primary_ar_expression1285);
				property_call110=property_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, property_call110.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:212:4: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(212, 4);
				PushFollow(Follow._constant_in_primary_ar_expression1290);
				constant111=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant111.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:213:4: parenthesisExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(213, 4);
				PushFollow(Follow._parenthesisExpression_in_primary_ar_expression1295);
				parenthesisExpression112=parenthesisExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parenthesisExpression112.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("primary_ar_expression", 23);
			LeaveRule("primary_ar_expression", 23);
			LeaveRule_primary_ar_expression();
		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_ar_expression"); }
		return retval;

	}
	// $ANTLR end "primary_ar_expression"

	partial void EnterRule_parenthesisExpression();
	partial void LeaveRule_parenthesisExpression();

	// $ANTLR start "parenthesisExpression"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:1: parenthesisExpression : '(' plus_expression ')' -> plus_expression ;
	[GrammarRule("parenthesisExpression")]
	private AstParserRuleReturnScope<object, IToken> parenthesisExpression()
	{
		EnterRule_parenthesisExpression();
		EnterRule("parenthesisExpression", 24);
		TraceIn("parenthesisExpression", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal113 = default(IToken);
		IToken char_literal115 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression114 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal113_tree = default(object);
		object char_literal115_tree = default(object);
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		try { DebugEnterRule(GrammarFileName, "parenthesisExpression");
		DebugLocation(216, 1);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:22: ( '(' plus_expression ')' -> plus_expression )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:24: '(' plus_expression ')'
			{
			DebugLocation(216, 24);
			char_literal113=(IToken)Match(input,42,Follow._42_in_parenthesisExpression1310); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal113);

			DebugLocation(216, 28);
			PushFollow(Follow._plus_expression_in_parenthesisExpression1312);
			plus_expression114=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression114.Tree);
			DebugLocation(216, 44);
			char_literal115=(IToken)Match(input,43,Follow._43_in_parenthesisExpression1314); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_43.Add(char_literal115);



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 216:48: -> plus_expression
			{
				DebugLocation(216, 51);
				adaptor.AddChild(root_0, stream_plus_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("parenthesisExpression", 24);
			LeaveRule("parenthesisExpression", 24);
			LeaveRule_parenthesisExpression();
		}
		DebugLocation(217, 1);
		} finally { DebugExitRule(GrammarFileName, "parenthesisExpression"); }
		return retval;

	}
	// $ANTLR end "parenthesisExpression"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:219:1: constant : ( INT | FLOAT | STRING );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 25);
		TraceIn("constant", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set116 = default(IToken);

		object set116_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(219, 30);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:219:9: ( INT | FLOAT | STRING )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(219, 9);

			set116=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set116));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("constant", 25);
			LeaveRule("constant", 25);
			LeaveRule_constant();
		}
		DebugLocation(219, 30);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:1: atom : ( constant | ID | T | F );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 26);
		TraceIn("atom", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID118 = default(IToken);
		IToken T119 = default(IToken);
		IToken F120 = default(IToken);
		AstParserRuleReturnScope<object, IToken> constant117 = default(AstParserRuleReturnScope<object, IToken>);

		object ID118_tree = default(object);
		object T119_tree = default(object);
		object F120_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(221, 28);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:6: ( constant | ID | T | F )
			int alt25=4;
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case FLOAT:
			case INT:
			case STRING:
				{
				alt25 = 1;
				}
				break;
			case ID:
				{
				alt25 = 2;
				}
				break;
			case T:
				{
				alt25 = 3;
				}
				break;
			case F:
				{
				alt25 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:8: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 8);
				PushFollow(Follow._constant_in_atom1345);
				constant117=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant117.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:19: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 19);
				ID118=(IToken)Match(input,ID,Follow._ID_in_atom1349); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID118_tree = (object)adaptor.Create(ID118);
				adaptor.AddChild(root_0, ID118_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:24: T
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 24);
				T119=(IToken)Match(input,T,Follow._T_in_atom1353); if (state.failed) return retval;
				if (state.backtracking == 0) {
				T119_tree = (object)adaptor.Create(T119);
				adaptor.AddChild(root_0, T119_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:28: F
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 28);
				F120=(IToken)Match(input,F,Follow._F_in_atom1357); if (state.failed) return retval;
				if (state.backtracking == 0) {
				F120_tree = (object)adaptor.Create(F120);
				adaptor.AddChild(root_0, F120_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("atom", 26);
			LeaveRule("atom", 26);
			LeaveRule_atom();
		}
		DebugLocation(221, 28);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:223:1: index : ( INT | ID );
	[GrammarRule("index")]
	private AstParserRuleReturnScope<object, IToken> index()
	{
		EnterRule_index();
		EnterRule("index", 27);
		TraceIn("index", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set121 = default(IToken);

		object set121_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(223, 16);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:223:7: ( INT | ID )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(223, 7);

			set121=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set121));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("index", 27);
			LeaveRule("index", 27);
			LeaveRule_index();
		}
		DebugLocation(223, 16);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return retval;

	}
	// $ANTLR end "index"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:225:1: number : ( INT | FLOAT );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<object, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 28);
		TraceIn("number", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set122 = default(IToken);

		object set122_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(225, 20);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:225:8: ( INT | FLOAT )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(225, 8);

			set122=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set122));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("number", 28);
			LeaveRule("number", 28);
			LeaveRule_number();
		}
		DebugLocation(225, 20);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_synpred22_NPortugol_fragment();
	partial void LeaveRule_synpred22_NPortugol_fragment();

	// $ANTLR start synpred22_NPortugol
	public void synpred22_NPortugol_fragment()
	{
		EnterRule_synpred22_NPortugol_fragment();
		EnterRule("synpred22_NPortugol_fragment", 50);
		TraceIn("synpred22_NPortugol_fragment", 50);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: function_arg_list
			{
			DebugLocation(149, 11);
			PushFollow(Follow._function_arg_list_in_synpred22_NPortugol692);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred22_NPortugol_fragment", 50);
			LeaveRule("synpred22_NPortugol_fragment", 50);
			LeaveRule_synpred22_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred22_NPortugol

	partial void EnterRule_synpred23_NPortugol_fragment();
	partial void LeaveRule_synpred23_NPortugol_fragment();

	// $ANTLR start synpred23_NPortugol
	public void synpred23_NPortugol_fragment()
	{
		EnterRule_synpred23_NPortugol_fragment();
		EnterRule("synpred23_NPortugol_fragment", 51);
		TraceIn("synpred23_NPortugol_fragment", 51);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: ( function_arg_list )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: function_arg_list
			{
			DebugLocation(157, 20);
			PushFollow(Follow._function_arg_list_in_synpred23_NPortugol792);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred23_NPortugol_fragment", 51);
			LeaveRule("synpred23_NPortugol_fragment", 51);
			LeaveRule_synpred23_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred23_NPortugol

	partial void EnterRule_synpred25_NPortugol_fragment();
	partial void LeaveRule_synpred25_NPortugol_fragment();

	// $ANTLR start synpred25_NPortugol
	public void synpred25_NPortugol_fragment()
	{
		EnterRule_synpred25_NPortugol_fragment();
		EnterRule("synpred25_NPortugol_fragment", 53);
		TraceIn("synpred25_NPortugol_fragment", 53);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:9: ( ID '=' '[' INT '..' INT ']' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:9: ID '=' '[' INT '..' INT ']'
			{
			DebugLocation(167, 9);
			Match(input,ID,Follow._ID_in_synpred25_NPortugol897); if (state.failed) return;
			DebugLocation(167, 12);
			Match(input,53,Follow._53_in_synpred25_NPortugol899); if (state.failed) return;
			DebugLocation(167, 16);
			Match(input,57,Follow._57_in_synpred25_NPortugol901); if (state.failed) return;
			DebugLocation(167, 20);
			Match(input,INT,Follow._INT_in_synpred25_NPortugol903); if (state.failed) return;
			DebugLocation(167, 24);
			Match(input,49,Follow._49_in_synpred25_NPortugol905); if (state.failed) return;
			DebugLocation(167, 29);
			Match(input,INT,Follow._INT_in_synpred25_NPortugol907); if (state.failed) return;
			DebugLocation(167, 33);
			Match(input,58,Follow._58_in_synpred25_NPortugol909); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_NPortugol_fragment", 53);
			LeaveRule("synpred25_NPortugol_fragment", 53);
			LeaveRule_synpred25_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred25_NPortugol

	partial void EnterRule_synpred27_NPortugol_fragment();
	partial void LeaveRule_synpred27_NPortugol_fragment();

	// $ANTLR start synpred27_NPortugol
	public void synpred27_NPortugol_fragment()
	{
		EnterRule_synpred27_NPortugol_fragment();
		EnterRule("synpred27_NPortugol_fragment", 55);
		TraceIn("synpred27_NPortugol_fragment", 55);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:10: ( ID '=' '{' INT ( ',' INT )* '}' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:10: ID '=' '{' INT ( ',' INT )* '}'
			{
			DebugLocation(168, 10);
			Match(input,ID,Follow._ID_in_synpred27_NPortugol932); if (state.failed) return;
			DebugLocation(168, 13);
			Match(input,53,Follow._53_in_synpred27_NPortugol934); if (state.failed) return;
			DebugLocation(168, 17);
			Match(input,73,Follow._73_in_synpred27_NPortugol936); if (state.failed) return;
			DebugLocation(168, 21);
			Match(input,INT,Follow._INT_in_synpred27_NPortugol938); if (state.failed) return;
			DebugLocation(168, 25);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:25: ( ',' INT )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if ((LA27_0==46))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:26: ',' INT
					{
					DebugLocation(168, 26);
					Match(input,46,Follow._46_in_synpred27_NPortugol941); if (state.failed) return;
					DebugLocation(168, 30);
					Match(input,INT,Follow._INT_in_synpred27_NPortugol943); if (state.failed) return;

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }

			DebugLocation(168, 36);
			Match(input,74,Follow._74_in_synpred27_NPortugol947); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred27_NPortugol_fragment", 55);
			LeaveRule("synpred27_NPortugol_fragment", 55);
			LeaveRule_synpred27_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred27_NPortugol

	partial void EnterRule_synpred43_NPortugol_fragment();
	partial void LeaveRule_synpred43_NPortugol_fragment();

	// $ANTLR start synpred43_NPortugol
	public void synpred43_NPortugol_fragment()
	{
		EnterRule_synpred43_NPortugol_fragment();
		EnterRule("synpred43_NPortugol_fragment", 71);
		TraceIn("synpred43_NPortugol_fragment", 71);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: ({...}? => function_call )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: {...}? => function_call
			{
			DebugLocation(205, 4);
			if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred43_NPortugol", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
			}
			DebugLocation(205, 71);
			PushFollow(Follow._function_call_in_synpred43_NPortugol1238);
			function_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred43_NPortugol_fragment", 71);
			LeaveRule("synpred43_NPortugol_fragment", 71);
			LeaveRule_synpred43_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred43_NPortugol

	partial void EnterRule_synpred44_NPortugol_fragment();
	partial void LeaveRule_synpred44_NPortugol_fragment();

	// $ANTLR start synpred44_NPortugol
	public void synpred44_NPortugol_fragment()
	{
		EnterRule_synpred44_NPortugol_fragment();
		EnterRule("synpred44_NPortugol_fragment", 72);
		TraceIn("synpred44_NPortugol_fragment", 72);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: ( ID )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: ID
			{
			DebugLocation(206, 4);
			Match(input,ID,Follow._ID_in_synpred44_NPortugol1243); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred44_NPortugol_fragment", 72);
			LeaveRule("synpred44_NPortugol_fragment", 72);
			LeaveRule_synpred44_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred44_NPortugol

	partial void EnterRule_synpred48_NPortugol_fragment();
	partial void LeaveRule_synpred48_NPortugol_fragment();

	// $ANTLR start synpred48_NPortugol
	public void synpred48_NPortugol_fragment()
	{
		EnterRule_synpred48_NPortugol_fragment();
		EnterRule("synpred48_NPortugol_fragment", 76);
		TraceIn("synpred48_NPortugol_fragment", 76);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:210:4: ( method_call )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:210:4: method_call
			{
			DebugLocation(210, 4);
			PushFollow(Follow._method_call_in_synpred48_NPortugol1279);
			method_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_NPortugol_fragment", 76);
			LeaveRule("synpred48_NPortugol_fragment", 76);
			LeaveRule_synpred48_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred48_NPortugol

	partial void EnterRule_synpred49_NPortugol_fragment();
	partial void LeaveRule_synpred49_NPortugol_fragment();

	// $ANTLR start synpred49_NPortugol
	public void synpred49_NPortugol_fragment()
	{
		EnterRule_synpred49_NPortugol_fragment();
		EnterRule("synpred49_NPortugol_fragment", 77);
		TraceIn("synpred49_NPortugol_fragment", 77);
		try
		{
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:211:4: ( property_call )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\NPortugol\\src\\grammar\\NPortugol.g:211:4: property_call
			{
			DebugLocation(211, 4);
			PushFollow(Follow._property_call_in_synpred49_NPortugol1285);
			property_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred49_NPortugol_fragment", 77);
			LeaveRule("synpred49_NPortugol_fragment", 77);
			LeaveRule_synpred49_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred49_NPortugol
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script148 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _65_in_declare_function159 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_declare_function163 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_declare_function165 = new BitSet(new ulong[]{0x80000040000UL});
		public static readonly BitSet _function_param_list_in_declare_function167 = new BitSet(new ulong[]{0x80000040000UL});
		public static readonly BitSet _43_in_declare_function170 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _statement_in_declare_function172 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _64_in_declare_function175 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declare_local_in_statement222 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement228 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement256 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement262 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _asm_code_in_statement267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_param_list295 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _46_in_function_param_list298 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_function_param_list300 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _72_in_declare_local348 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_declare_local352 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _46_in_declare_local355 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_declare_local359 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _70_in_if_stat405 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _logic_expression_in_if_stat409 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_if_stat411 = new BitSet(new ulong[]{0x4000010000040000UL,0x1F9UL});
		public static readonly BitSet _statement_in_if_stat415 = new BitSet(new ulong[]{0x4000010000040000UL,0x1F9UL});
		public static readonly BitSet _senao_stat_in_if_stat423 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _64_in_if_stat451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _71_in_senao_stat487 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _statement_in_senao_stat491 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _64_in_senao_stat494 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_for_stat514 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _assign_var_in_for_stat516 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _59_in_for_stat518 = new BitSet(new ulong[]{0x440000UL});
		public static readonly BitSet _index_in_for_stat520 = new BitSet(new ulong[]{0x5000010000040000UL,0x179UL});
		public static readonly BitSet _60_in_for_stat528 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _statement_in_for_stat530 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _64_in_for_stat533 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_for_stat558 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _64_in_for_stat561 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _62_in_while_stat594 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _logic_expression_in_while_stat596 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _statement_in_while_stat598 = new BitSet(new ulong[]{0x4000010000040000UL,0x179UL});
		public static readonly BitSet _64_in_while_stat601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_repeat_stat633 = new BitSet(new ulong[]{0x4800010000040000UL,0x178UL});
		public static readonly BitSet _statement_in_repeat_stat635 = new BitSet(new ulong[]{0x4800010000040000UL,0x178UL});
		public static readonly BitSet _59_in_repeat_stat638 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _logic_expression_in_repeat_stat640 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_call688 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_function_call690 = new BitSet(new ulong[]{0xC0C0044C000UL});
		public static readonly BitSet _function_arg_list_in_function_call692 = new BitSet(new ulong[]{0xC0C0044C000UL});
		public static readonly BitSet _43_in_function_call695 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_property_call736 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_property_call737 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_property_call740 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_method_call784 = new BitSet(new ulong[]{0x1000000000000UL});
		public static readonly BitSet _48_in_method_call785 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_method_call788 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _42_in_method_call790 = new BitSet(new ulong[]{0xC0C0044C000UL});
		public static readonly BitSet _function_arg_list_in_method_call792 = new BitSet(new ulong[]{0xC0C0044C000UL});
		public static readonly BitSet _43_in_method_call795 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_function_arg_list840 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _46_in_function_arg_list843 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _plus_expression_in_function_arg_list845 = new BitSet(new ulong[]{0x400000000002UL});
		public static readonly BitSet _ID_in_assign_var897 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_assign_var899 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var901 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_assign_var903 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_assign_var905 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_assign_var907 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_assign_var909 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var932 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_assign_var934 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_assign_var936 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_assign_var938 = new BitSet(new ulong[]{0x400000000000UL,0x400UL});
		public static readonly BitSet _46_in_assign_var941 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_assign_var943 = new BitSet(new ulong[]{0x400000000000UL,0x400UL});
		public static readonly BitSet _74_in_assign_var947 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var967 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var969 = new BitSet(new ulong[]{0x440000UL});
		public static readonly BitSet _index_in_assign_var971 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_assign_var973 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_assign_var975 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _assign_expression_in_assign_var977 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1006 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_assign_var1008 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _assign_expression_in_assign_var1010 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _69_in_return_stat1033 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _assign_expression_in_return_stat1035 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _40_in_asm_code1054 = new BitSet(new ulong[]{0x10400000000UL});
		public static readonly BitSet _STRING_in_asm_code1056 = new BitSet(new ulong[]{0x10400000000UL});
		public static readonly BitSet _40_in_asm_code1059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_logic_expression1091 = new BitSet(new ulong[]{0x21D8008000000002UL,0x4UL});
		public static readonly BitSet _binop_in_logic_expression1095 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _plus_expression_in_logic_expression1098 = new BitSet(new ulong[]{0x21D8008000000002UL,0x4UL});
		public static readonly BitSet _plus_expression_in_assign_expression1159 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mul_expression_in_plus_expression1169 = new BitSet(new ulong[]{0xA00000000002UL});
		public static readonly BitSet _45_in_plus_expression1173 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1176 = new BitSet(new ulong[]{0xA00000000002UL});
		public static readonly BitSet _47_in_plus_expression1180 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1183 = new BitSet(new ulong[]{0xA00000000002UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1198 = new BitSet(new ulong[]{0x4120000000002UL});
		public static readonly BitSet _50_in_mul_expression1203 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1206 = new BitSet(new ulong[]{0x4120000000002UL});
		public static readonly BitSet _41_in_mul_expression1210 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1213 = new BitSet(new ulong[]{0x4120000000002UL});
		public static readonly BitSet _44_in_mul_expression1217 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1220 = new BitSet(new ulong[]{0x4120000000002UL});
		public static readonly BitSet _function_call_in_primary_ar_expression1238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1243 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _T_in_primary_ar_expression1248 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_primary_ar_expression1253 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1258 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_primary_ar_expression1260 = new BitSet(new ulong[]{0x440000UL});
		public static readonly BitSet _index_in_primary_ar_expression1262 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_primary_ar_expression1264 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_primary_ar_expression1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_primary_ar_expression1285 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_ar_expression1290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesisExpression_in_primary_ar_expression1295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_parenthesisExpression1310 = new BitSet(new ulong[]{0x40C0044C000UL});
		public static readonly BitSet _plus_expression_in_parenthesisExpression1312 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _43_in_parenthesisExpression1314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_atom1345 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _T_in_atom1353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_atom1357 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred22_NPortugol692 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred23_NPortugol792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred25_NPortugol897 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_synpred25_NPortugol899 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred25_NPortugol901 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_synpred25_NPortugol903 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_synpred25_NPortugol905 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_synpred25_NPortugol907 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _58_in_synpred25_NPortugol909 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred27_NPortugol932 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_synpred27_NPortugol934 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _73_in_synpred27_NPortugol936 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_synpred27_NPortugol938 = new BitSet(new ulong[]{0x400000000000UL,0x400UL});
		public static readonly BitSet _46_in_synpred27_NPortugol941 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _INT_in_synpred27_NPortugol943 = new BitSet(new ulong[]{0x400000000000UL,0x400UL});
		public static readonly BitSet _74_in_synpred27_NPortugol947 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_synpred43_NPortugol1238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred44_NPortugol1243 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_synpred48_NPortugol1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_synpred49_NPortugol1285 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol
