//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g 2014-04-24 11:21:14

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections;
using System;



using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace NPortugol
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class NPortugolParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AR", "ARG", "ASGN", "ASM", "CALL", "CASE", "CHAR", "DEC", "ESC_SEQ", "EXP", "EXPONENT", "F", "FLOAT", "FUNC", "HEX_DIGIT", "ID", "ILIST", "INDEX", "INIT", "INT", "JMP", "LEXP", "LOOP", "MCALL", "NEWLINE", "OCTAL_ESC", "PARAM", "PCALL", "RET", "SEL", "SJMP", "SLIST", "STRING", "T", "UNICODE_ESC", "VAR", "WS", "'!='", "'#'", "'%'", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'..'", "'/'", "':'", "';'", "'<'", "'<='", "'='", "'=='", "'>'", "'>='", "'['", "']'", "'até'", "'caso'", "'decrescente'", "'e'", "'enquanto'", "'então'", "'fim'", "'função'", "'ou'", "'para'", "'repita'", "'retorne'", "'se'", "'selecione'", "'senão'", "'variável'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int AR=4;
	public const int ARG=5;
	public const int ASGN=6;
	public const int ASM=7;
	public const int CALL=8;
	public const int CASE=9;
	public const int CHAR=10;
	public const int DEC=11;
	public const int ESC_SEQ=12;
	public const int EXP=13;
	public const int EXPONENT=14;
	public const int F=15;
	public const int FLOAT=16;
	public const int FUNC=17;
	public const int HEX_DIGIT=18;
	public const int ID=19;
	public const int ILIST=20;
	public const int INDEX=21;
	public const int INIT=22;
	public const int INT=23;
	public const int JMP=24;
	public const int LEXP=25;
	public const int LOOP=26;
	public const int MCALL=27;
	public const int NEWLINE=28;
	public const int OCTAL_ESC=29;
	public const int PARAM=30;
	public const int PCALL=31;
	public const int RET=32;
	public const int SEL=33;
	public const int SJMP=34;
	public const int SLIST=35;
	public const int STRING=36;
	public const int T=37;
	public const int UNICODE_ESC=38;
	public const int VAR=39;
	public const int WS=40;

	public NPortugolParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public NPortugolParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return NPortugolParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g"; } }



		Stack<string> paraphrases = new Stack<string>();
		
		public string GetErrorMessage(RecognitionException e)
	        {
	            string msg = "Erro na linha {0} posição {1}: '{2}'. Certifique-se de acentuar as palvras.";
		    msg = string.Format(msg, e.Line, e.CharPositionInLine, e.Token.Text);
	            /*if (paraphrases.Count > 0){
	                string paraphrase = (string)paraphrases.Pop();
	                msg = msg + " " + paraphrase;
	            }*/
	            return msg;
	        }
		protected void mismatch(IIntStream input, int ttype, BitSet follow)	{
			throw new MismatchedTokenException(ttype, input);
		}
		public void recoverFromMismatchedSet(IIntStream input,RecognitionException e, BitSet follow) {
			throw e;
		}

		public List<string> Functions = new List<string>();
		public List<string> Symbols = new List<string>();	
		public bool IsDefinedID(string id){    return Symbols.Contains(id);}
		public bool IsDefined(string name) { return Functions.Contains(name); }
		public void DefineID(IList<IToken> ids){ foreach(var id in ids) { Symbols.Add(id.Text); }}
		public void DefineFunction(string name){ Functions.Add(name);}	


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_script();
	partial void LeaveRule_script();

	// $ANTLR start "script"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:79:8: public script : ( declare_function )* ;
	[GrammarRule("script")]
	public AstParserRuleReturnScope<object, IToken> script()
	{
		EnterRule_script();
		EnterRule("script", 1);
		TraceIn("script", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_function1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "script");
		DebugLocation(79, 34);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:79:15: ( ( declare_function )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:79:17: ( declare_function )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(79, 17);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:79:17: ( declare_function )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==70))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:79:17: declare_function
					{
					DebugLocation(79, 17);
					PushFollow(Follow._declare_function_in_script156);
					declare_function1=declare_function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, declare_function1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("script", 1);
			LeaveRule("script", 1);
			LeaveRule_script();
		}
		DebugLocation(79, 34);
		} finally { DebugExitRule(GrammarFileName, "script"); }
		return retval;

	}
	// $ANTLR end "script"

	partial void EnterRule_declare_function();
	partial void LeaveRule_declare_function();

	// $ANTLR start "declare_function"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:81:1: declare_function : 'função' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) ;
	[GrammarRule("declare_function")]
	private AstParserRuleReturnScope<object, IToken> declare_function()
	{
		EnterRule_declare_function();
		EnterRule("declare_function", 2);
		TraceIn("declare_function", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken i = default(IToken);
		IToken string_literal2 = default(IToken);
		IToken char_literal3 = default(IToken);
		IToken char_literal5 = default(IToken);
		IToken string_literal7 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_param_list4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);

		object i_tree = default(object);
		object string_literal2_tree = default(object);
		object char_literal3_tree = default(object);
		object char_literal5_tree = default(object);
		object string_literal7_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_function_param_list=new RewriteRuleSubtreeStream(adaptor,"rule function_param_list");
		try { DebugEnterRule(GrammarFileName, "declare_function");
		DebugLocation(81, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:2: ( 'função' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim' -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:4: 'função' i= ID '(' ( function_param_list )* ')' ( statement )* 'fim'
			{
			DebugLocation(82, 4);
			string_literal2=(IToken)Match(input,70,Follow._70_in_declare_function167); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_70.Add(string_literal2);

			DebugLocation(82, 14);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_function171); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			DebugLocation(82, 18);
			char_literal3=(IToken)Match(input,44,Follow._44_in_declare_function173); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_44.Add(char_literal3);

			DebugLocation(82, 22);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:22: ( function_param_list )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==ID))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:22: function_param_list
					{
					DebugLocation(82, 22);
					PushFollow(Follow._function_param_list_in_declare_function175);
					function_param_list4=function_param_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_param_list.Add(function_param_list4.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(82, 43);
			char_literal5=(IToken)Match(input,45,Follow._45_in_declare_function178); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_45.Add(char_literal5);

			DebugLocation(82, 47);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:47: ( statement )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==ID||LA3_0==42||LA3_0==67||(LA3_0>=72 && LA3_0<=76)||LA3_0==78))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:82:47: statement
					{
					DebugLocation(82, 47);
					PushFollow(Follow._statement_in_declare_function180);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(82, 58);
			string_literal7=(IToken)Match(input,69,Follow._69_in_declare_function183); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal7);

			DebugLocation(83, 3);
			if (state.backtracking == 0)
			{
				DefineFunction((i!=null?i.Text:null));
			}


			{
			// AST REWRITE
			// elements: statement, function_param_list, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 84:3: -> ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
			{
				DebugLocation(84, 6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:84:6: ^( FUNC ID ( function_param_list )* ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(84, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(84, 13);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(84, 16);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:84:16: ( function_param_list )*
				while ( stream_function_param_list.HasNext )
				{
					DebugLocation(84, 16);
					adaptor.AddChild(root_1, stream_function_param_list.NextTree());

				}
				stream_function_param_list.Reset();
				DebugLocation(84, 37);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:84:37: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(84, 39);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(84, 45);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:84:45: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(84, 45);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("declare_function", 2);
			LeaveRule("declare_function", 2);
			LeaveRule_declare_function();
		}
		DebugLocation(85, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_function"); }
		return retval;

	}
	// $ANTLR end "declare_function"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:87:1: statement : ( declare_local | if_stat | for_stat | while_stat | repeat_stat | select_stat | function_call | assign_var | return_stat | asm_code );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 3);
		TraceIn("statement", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declare_local8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_stat9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_stat10 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> repeat_stat12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> select_stat13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_call14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_var15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_stat16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> asm_code17 = default(AstParserRuleReturnScope<object, IToken>);

		 paraphrases.Push("na sentença"); 
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(87, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:89:2: ( declare_local | if_stat | for_stat | while_stat | repeat_stat | select_stat | function_call | assign_var | return_stat | asm_code )
			int alt4=10;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case 78:
				{
				alt4 = 1;
				}
				break;
			case 75:
				{
				alt4 = 2;
				}
				break;
			case 72:
				{
				alt4 = 3;
				}
				break;
			case 67:
				{
				alt4 = 4;
				}
				break;
			case 73:
				{
				alt4 = 5;
				}
				break;
			case 76:
				{
				alt4 = 6;
				}
				break;
			case ID:
				{
				int LA4_7 = input.LA(2);

				if ((LA4_7==44))
				{
					alt4 = 7;
				}
				else if ((LA4_7==57||LA4_7==61))
				{
					alt4 = 8;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 7, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 74:
				{
				alt4 = 9;
				}
				break;
			case 42:
				{
				alt4 = 10;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:89:4: declare_local
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._declare_local_in_statement230);
				declare_local8=declare_local();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declare_local8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:90:4: if_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(90, 4);
				PushFollow(Follow._if_stat_in_statement236);
				if_stat9=if_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_stat9.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:91:4: for_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(91, 4);
				PushFollow(Follow._for_stat_in_statement242);
				for_stat10=for_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_stat10.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:92:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(92, 4);
				PushFollow(Follow._while_stat_in_statement247);
				while_stat11=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat11.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:93:4: repeat_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(93, 4);
				PushFollow(Follow._repeat_stat_in_statement252);
				repeat_stat12=repeat_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, repeat_stat12.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:94:4: select_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(94, 4);
				PushFollow(Follow._select_stat_in_statement258);
				select_stat13=select_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, select_stat13.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:95:4: function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(95, 4);
				PushFollow(Follow._function_call_in_statement263);
				function_call14=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call14.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:96:4: assign_var
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(96, 4);
				PushFollow(Follow._assign_var_in_statement269);
				assign_var15=assign_var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assign_var15.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:97:4: return_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(97, 4);
				PushFollow(Follow._return_stat_in_statement275);
				return_stat16=return_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, return_stat16.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:98:4: asm_code
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(98, 4);
				PushFollow(Follow._asm_code_in_statement280);
				asm_code17=asm_code();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, asm_code17.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("statement", 3);
			LeaveRule("statement", 3);
			LeaveRule_statement();
		}
		DebugLocation(99, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_function_param_list();
	partial void LeaveRule_function_param_list();

	// $ANTLR start "function_param_list"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:101:1: function_param_list : ID ( ',' ID )* -> ^( PARAM ( ID )* ) ;
	[GrammarRule("function_param_list")]
	private AstParserRuleReturnScope<object, IToken> function_param_list()
	{
		EnterRule_function_param_list();
		EnterRule("function_param_list", 4);
		TraceIn("function_param_list", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID18 = default(IToken);
		IToken char_literal19 = default(IToken);
		IToken ID20 = default(IToken);

		object ID18_tree = default(object);
		object char_literal19_tree = default(object);
		object ID20_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na lista de parâmetros"); 
		try { DebugEnterRule(GrammarFileName, "function_param_list");
		DebugLocation(101, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:102:2: ( ID ( ',' ID )* -> ^( PARAM ( ID )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:102:4: ID ( ',' ID )*
			{
			DebugLocation(102, 4);
			ID18=(IToken)Match(input,ID,Follow._ID_in_function_param_list308); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID18);

			DebugLocation(102, 7);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:102:7: ( ',' ID )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==48))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:102:8: ',' ID
					{
					DebugLocation(102, 8);
					char_literal19=(IToken)Match(input,48,Follow._48_in_function_param_list311); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_48.Add(char_literal19);

					DebugLocation(102, 12);
					ID20=(IToken)Match(input,ID,Follow._ID_in_function_param_list313); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(ID20);


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 102:17: -> ^( PARAM ( ID )* )
			{
				DebugLocation(102, 20);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:102:20: ^( PARAM ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(102, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(102, 28);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:102:28: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(102, 28);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("function_param_list", 4);
			LeaveRule("function_param_list", 4);
			LeaveRule_function_param_list();
		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "function_param_list"); }
		return retval;

	}
	// $ANTLR end "function_param_list"

	partial void EnterRule_declare_local();
	partial void LeaveRule_declare_local();

	// $ANTLR start "declare_local"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:105:1: declare_local : 'variável' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) ;
	[GrammarRule("declare_local")]
	private AstParserRuleReturnScope<object, IToken> declare_local()
	{
		EnterRule_declare_local();
		EnterRule("declare_local", 5);
		TraceIn("declare_local", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal21 = default(IToken);
		IToken char_literal22 = default(IToken);
		IToken i = default(IToken);
		List<IToken> list_i = null;

		object string_literal21_tree = default(object);
		object char_literal22_tree = default(object);
		object i_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		 paraphrases.Push("na definição de variável"); 
		try { DebugEnterRule(GrammarFileName, "declare_local");
		DebugLocation(105, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:106:2: ( 'variável' i+= ID ( ',' i+= ID )* -> ^( VAR ( ID )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:106:4: 'variável' i+= ID ( ',' i+= ID )*
			{
			DebugLocation(106, 4);
			string_literal21=(IToken)Match(input,78,Follow._78_in_declare_local359); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_78.Add(string_literal21);

			DebugLocation(106, 16);
			i=(IToken)Match(input,ID,Follow._ID_in_declare_local363); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);

			if (list_i==null) list_i=new List<IToken>();
			list_i.Add(i);

			DebugLocation(106, 21);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:106:21: ( ',' i+= ID )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==48))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:106:22: ',' i+= ID
					{
					DebugLocation(106, 22);
					char_literal22=(IToken)Match(input,48,Follow._48_in_declare_local366); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_48.Add(char_literal22);

					DebugLocation(106, 27);
					i=(IToken)Match(input,ID,Follow._ID_in_declare_local370); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_ID.Add(i);

					if (list_i==null) list_i=new List<IToken>();
					list_i.Add(i);


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(107, 4);
			if (state.backtracking == 0)
			{
				DefineID(list_i);
			}


			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 108:2: -> ^( VAR ( ID )* )
			{
				DebugLocation(108, 5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:108:5: ^( VAR ( ID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(108, 7);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(108, 11);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:108:11: ( ID )*
				while ( stream_ID.HasNext )
				{
					DebugLocation(108, 11);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("declare_local", 5);
			LeaveRule("declare_local", 5);
			LeaveRule_declare_local();
		}
		DebugLocation(109, 1);
		} finally { DebugExitRule(GrammarFileName, "declare_local"); }
		return retval;

	}
	// $ANTLR end "declare_local"

	partial void EnterRule_if_stat();
	partial void LeaveRule_if_stat();

	// $ANTLR start "if_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:111:1: if_stat : 'se' p= logic_expression 'então' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) ;
	[GrammarRule("if_stat")]
	private AstParserRuleReturnScope<object, IToken> if_stat()
	{
		EnterRule_if_stat();
		EnterRule("if_stat", 6);
		TraceIn("if_stat", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal23 = default(IToken);
		IToken string_literal24 = default(IToken);
		IToken string_literal25 = default(IToken);
		List<object> list_s1 = null;
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s1 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal23_tree = default(object);
		object string_literal24_tree = default(object);
		object string_literal25_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_75=new RewriteRuleITokenStream(adaptor,"token 75");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		RewriteRuleSubtreeStream stream_senao_stat=new RewriteRuleSubtreeStream(adaptor,"rule senao_stat");
		 paraphrases.Push("se"); 
		try { DebugEnterRule(GrammarFileName, "if_stat");
		DebugLocation(111, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:113:2: ( 'se' p= logic_expression 'então' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:113:4: 'se' p= logic_expression 'então' (s1+= statement )* (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			{
			DebugLocation(113, 4);
			string_literal23=(IToken)Match(input,75,Follow._75_in_if_stat413); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_75.Add(string_literal23);

			DebugLocation(113, 10);
			PushFollow(Follow._logic_expression_in_if_stat417);
			p=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(p.Tree);
			DebugLocation(113, 28);
			string_literal24=(IToken)Match(input,68,Follow._68_in_if_stat419); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(string_literal24);

			DebugLocation(113, 38);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:113:38: (s1+= statement )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ID||LA7_0==42||LA7_0==67||(LA7_0>=72 && LA7_0<=76)||LA7_0==78))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:113:38: s1+= statement
					{
					DebugLocation(113, 38);
					PushFollow(Follow._statement_in_if_stat423);
					s1=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s1.Tree);
					if (list_s1==null) list_s1=new List<object>();
					list_s1.Add(s1.Tree);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(114, 2);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:114:2: (s2= senao_stat -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) ) | 'fim' -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) ) )
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==77))
			{
				alt8 = 1;
			}
			else if ((LA8_0==69))
			{
				alt8 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:114:4: s2= senao_stat
				{
				DebugLocation(114, 6);
				PushFollow(Follow._senao_stat_in_if_stat431);
				s2=senao_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_senao_stat.Add(s2.Tree);


				{
				// AST REWRITE
				// elements: p, s1, s2
				// token labels: 
				// rule labels: retval, s2, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_s2=new RewriteRuleSubtreeStream(adaptor,"rule s2",s2!=null?s2.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 114:18: -> ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
				{
					DebugLocation(114, 21);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:114:21: ^( SJMP ^( LEXP $p) ^( SLIST $s1 $s2) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(114, 23);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SJMP, "SJMP"), root_1);

					DebugLocation(114, 28);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:114:28: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(114, 30);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(114, 36);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(114, 39);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:114:39: ^( SLIST $s1 $s2)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(114, 41);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(114, 48);
					adaptor.AddChild(root_2, stream_s1.NextTree());
					DebugLocation(114, 52);
					adaptor.AddChild(root_2, stream_s2.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:115:4: 'fim'
				{
				DebugLocation(115, 4);
				string_literal25=(IToken)Match(input,69,Follow._69_in_if_stat459); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(string_literal25);



				{
				// AST REWRITE
				// elements: p, s1
				// token labels: 
				// rule labels: retval, p
				// token list labels: 
				// rule list labels: s1
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
				RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,"token s1",list_s1);
				root_0 = (object)adaptor.Nil();
				// 115:10: -> ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
				{
					DebugLocation(115, 13);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:115:13: ^( JMP ^( LEXP $p) ^( SLIST ( $s1)* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(115, 15);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(JMP, "JMP"), root_1);

					DebugLocation(115, 19);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:115:19: ^( LEXP $p)
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(115, 21);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

					DebugLocation(115, 27);
					adaptor.AddChild(root_2, stream_p.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(115, 30);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:115:30: ^( SLIST ( $s1)* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(115, 32);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(115, 39);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:115:39: ( $s1)*
					while ( stream_s1.HasNext )
					{
						DebugLocation(115, 39);
						adaptor.AddChild(root_2, stream_s1.NextTree());

					}
					stream_s1.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("if_stat", 6);
			LeaveRule("if_stat", 6);
			LeaveRule_if_stat();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stat"); }
		return retval;

	}
	// $ANTLR end "if_stat"

	partial void EnterRule_senao_stat();
	partial void LeaveRule_senao_stat();

	// $ANTLR start "senao_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:119:1: senao_stat : 'senão' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) ;
	[GrammarRule("senao_stat")]
	private AstParserRuleReturnScope<object, IToken> senao_stat()
	{
		EnterRule_senao_stat();
		EnterRule("senao_stat", 7);
		TraceIn("senao_stat", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal26 = default(IToken);
		IToken string_literal27 = default(IToken);
		List<object> list_s2 = null;
		AstParserRuleReturnScope<object, IToken> s2 = default(AstParserRuleReturnScope<object, IToken>);
		object string_literal26_tree = default(object);
		object string_literal27_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "senao_stat");
		DebugLocation(119, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:2: ( 'senão' (s2+= statement )* 'fim' -> ^( SLIST ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:4: 'senão' (s2+= statement )* 'fim'
			{
			DebugLocation(120, 4);
			string_literal26=(IToken)Match(input,77,Follow._77_in_senao_stat495); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_77.Add(string_literal26);

			DebugLocation(120, 14);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:14: (s2+= statement )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==ID||LA9_0==42||LA9_0==67||(LA9_0>=72 && LA9_0<=76)||LA9_0==78))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:14: s2+= statement
					{
					DebugLocation(120, 14);
					PushFollow(Follow._statement_in_senao_stat499);
					s2=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(s2.Tree);
					if (list_s2==null) list_s2=new List<object>();
					list_s2.Add(s2.Tree);


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(120, 27);
			string_literal27=(IToken)Match(input,69,Follow._69_in_senao_stat502); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal27);



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 120:33: -> ^( SLIST ( statement )* )
			{
				DebugLocation(120, 36);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:36: ^( SLIST ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(120, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_1);

				DebugLocation(120, 44);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:120:44: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(120, 44);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("senao_stat", 7);
			LeaveRule("senao_stat", 7);
			LeaveRule_senao_stat();
		}
		DebugLocation(121, 1);
		} finally { DebugExitRule(GrammarFileName, "senao_stat"); }
		return retval;

	}
	// $ANTLR end "senao_stat"

	partial void EnterRule_for_stat();
	partial void LeaveRule_for_stat();

	// $ANTLR start "for_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:1: for_stat : 'para' assign_var 'até' index ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) ;
	[GrammarRule("for_stat")]
	private AstParserRuleReturnScope<object, IToken> for_stat()
	{
		EnterRule_for_stat();
		EnterRule("for_stat", 8);
		TraceIn("for_stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal28 = default(IToken);
		IToken string_literal30 = default(IToken);
		IToken string_literal32 = default(IToken);
		IToken string_literal34 = default(IToken);
		IToken string_literal36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_var29 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement33 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement35 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal28_tree = default(object);
		object string_literal30_tree = default(object);
		object string_literal32_tree = default(object);
		object string_literal34_tree = default(object);
		object string_literal36_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		RewriteRuleSubtreeStream stream_assign_var=new RewriteRuleSubtreeStream(adaptor,"rule assign_var");
		try { DebugEnterRule(GrammarFileName, "for_stat");
		DebugLocation(123, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:9: ( 'para' assign_var 'até' index ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:123:11: 'para' assign_var 'até' index ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			{
			DebugLocation(123, 11);
			string_literal28=(IToken)Match(input,72,Follow._72_in_for_stat522); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_72.Add(string_literal28);

			DebugLocation(123, 18);
			PushFollow(Follow._assign_var_in_for_stat524);
			assign_var29=assign_var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_var.Add(assign_var29.Tree);
			DebugLocation(123, 29);
			string_literal30=(IToken)Match(input,63,Follow._63_in_for_stat526); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal30);

			DebugLocation(123, 35);
			PushFollow(Follow._index_in_for_stat528);
			index31=index();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_index.Add(index31.Tree);
			DebugLocation(125, 3);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:3: ( 'decrescente' ( statement )* 'fim' -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) ) | ( statement )* 'fim' -> ^( LOOP assign_var index ^( SLIST ( statement )* ) ) )
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==65))
			{
				alt12 = 1;
			}
			else if ((LA12_0==ID||LA12_0==42||LA12_0==67||LA12_0==69||(LA12_0>=72 && LA12_0<=76)||LA12_0==78))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:5: 'decrescente' ( statement )* 'fim'
				{
				DebugLocation(125, 5);
				string_literal32=(IToken)Match(input,65,Follow._65_in_for_stat536); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_65.Add(string_literal32);

				DebugLocation(125, 19);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:19: ( statement )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if ((LA10_0==ID||LA10_0==42||LA10_0==67||(LA10_0>=72 && LA10_0<=76)||LA10_0==78))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:19: statement
						{
						DebugLocation(125, 19);
						PushFollow(Follow._statement_in_for_stat538);
						statement33=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement33.Tree);

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }

				DebugLocation(125, 30);
				string_literal34=(IToken)Match(input,69,Follow._69_in_for_stat541); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(string_literal34);



				{
				// AST REWRITE
				// elements: index, assign_var, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 125:36: -> ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(125, 39);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:39: ^( LOOP DEC assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(125, 41);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(125, 46);
					adaptor.AddChild(root_1, (object)adaptor.Create(DEC, "DEC"));
					DebugLocation(125, 50);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(125, 61);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(125, 67);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:67: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(125, 69);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(125, 75);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:125:75: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(125, 75);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:5: ( statement )* 'fim'
				{
				DebugLocation(126, 5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:5: ( statement )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==ID||LA11_0==42||LA11_0==67||(LA11_0>=72 && LA11_0<=76)||LA11_0==78))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:5: statement
						{
						DebugLocation(126, 5);
						PushFollow(Follow._statement_in_for_stat566);
						statement35=statement();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_statement.Add(statement35.Tree);

						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(126, 16);
				string_literal36=(IToken)Match(input,69,Follow._69_in_for_stat569); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_69.Add(string_literal36);



				{
				// AST REWRITE
				// elements: statement, assign_var, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 126:22: -> ^( LOOP assign_var index ^( SLIST ( statement )* ) )
				{
					DebugLocation(126, 25);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:25: ^( LOOP assign_var index ^( SLIST ( statement )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(126, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

					DebugLocation(126, 32);
					adaptor.AddChild(root_1, stream_assign_var.NextTree());
					DebugLocation(126, 43);
					adaptor.AddChild(root_1, stream_index.NextTree());
					DebugLocation(126, 49);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:49: ^( SLIST ( statement )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(126, 51);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

					DebugLocation(126, 57);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:126:57: ( statement )*
					while ( stream_statement.HasNext )
					{
						DebugLocation(126, 57);
						adaptor.AddChild(root_2, stream_statement.NextTree());

					}
					stream_statement.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("for_stat", 8);
			LeaveRule("for_stat", 8);
			LeaveRule_for_stat();
		}
		DebugLocation(128, 1);
		} finally { DebugExitRule(GrammarFileName, "for_stat"); }
		return retval;

	}
	// $ANTLR end "for_stat"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:130:1: while_stat : 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 9);
		TraceIn("while_stat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal37 = default(IToken);
		IToken string_literal40 = default(IToken);
		AstParserRuleReturnScope<object, IToken> logic_expression38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement39 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal37_tree = default(object);
		object string_literal40_tree = default(object);
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(130, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:131:2: ( 'enquanto' logic_expression ( statement )* 'fim' -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:131:4: 'enquanto' logic_expression ( statement )* 'fim'
			{
			DebugLocation(131, 4);
			string_literal37=(IToken)Match(input,67,Follow._67_in_while_stat602); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_67.Add(string_literal37);

			DebugLocation(131, 15);
			PushFollow(Follow._logic_expression_in_while_stat604);
			logic_expression38=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression38.Tree);
			DebugLocation(131, 32);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:131:32: ( statement )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==ID||LA13_0==42||LA13_0==67||(LA13_0>=72 && LA13_0<=76)||LA13_0==78))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:131:32: statement
					{
					DebugLocation(131, 32);
					PushFollow(Follow._statement_in_while_stat606);
					statement39=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement39.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(131, 43);
			string_literal40=(IToken)Match(input,69,Follow._69_in_while_stat609); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal40);



			{
			// AST REWRITE
			// elements: logic_expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 132:3: -> ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
			{
				DebugLocation(132, 6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:6: ^( LOOP ^( LEXP logic_expression ) ^( SLIST ( statement )* ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(132, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(132, 13);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:13: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(132, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(132, 20);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(132, 38);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:38: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(132, 40);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(132, 46);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:132:46: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(132, 46);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("while_stat", 9);
			LeaveRule("while_stat", 9);
			LeaveRule_while_stat();
		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_repeat_stat();
	partial void LeaveRule_repeat_stat();

	// $ANTLR start "repeat_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:1: repeat_stat : 'repita' ( statement )* 'até' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) ;
	[GrammarRule("repeat_stat")]
	private AstParserRuleReturnScope<object, IToken> repeat_stat()
	{
		EnterRule_repeat_stat();
		EnterRule("repeat_stat", 10);
		TraceIn("repeat_stat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal41 = default(IToken);
		IToken string_literal43 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statement42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logic_expression44 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal41_tree = default(object);
		object string_literal43_tree = default(object);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_logic_expression=new RewriteRuleSubtreeStream(adaptor,"rule logic_expression");
		try { DebugEnterRule(GrammarFileName, "repeat_stat");
		DebugLocation(135, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:12: ( 'repita' ( statement )* 'até' logic_expression -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:14: 'repita' ( statement )* 'até' logic_expression
			{
			DebugLocation(135, 14);
			string_literal41=(IToken)Match(input,73,Follow._73_in_repeat_stat640); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_73.Add(string_literal41);

			DebugLocation(135, 23);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:23: ( statement )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==ID||LA14_0==42||LA14_0==67||(LA14_0>=72 && LA14_0<=76)||LA14_0==78))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:135:23: statement
					{
					DebugLocation(135, 23);
					PushFollow(Follow._statement_in_repeat_stat642);
					statement42=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement42.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(135, 34);
			string_literal43=(IToken)Match(input,63,Follow._63_in_repeat_stat645); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(string_literal43);

			DebugLocation(135, 40);
			PushFollow(Follow._logic_expression_in_repeat_stat647);
			logic_expression44=logic_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logic_expression.Add(logic_expression44.Tree);


			{
			// AST REWRITE
			// elements: logic_expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 136:3: -> ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
			{
				DebugLocation(136, 6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:136:6: ^( LOOP ^( SLIST ( statement )* ) ^( LEXP logic_expression ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(136, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LOOP, "LOOP"), root_1);

				DebugLocation(136, 13);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:136:13: ^( SLIST ( statement )* )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(136, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, "SLIST"), root_2);

				DebugLocation(136, 21);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:136:21: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(136, 21);
					adaptor.AddChild(root_2, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(136, 33);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:136:33: ^( LEXP logic_expression )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(136, 35);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(LEXP, "LEXP"), root_2);

				DebugLocation(136, 40);
				adaptor.AddChild(root_2, stream_logic_expression.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("repeat_stat", 10);
			LeaveRule("repeat_stat", 10);
			LeaveRule_repeat_stat();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "repeat_stat"); }
		return retval;

	}
	// $ANTLR end "repeat_stat"

	partial void EnterRule_select_stat();
	partial void LeaveRule_select_stat();

	// $ANTLR start "select_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:139:1: select_stat : 'selecione' atom ( select_case )+ 'fim' -> ^( SEL atom ( select_case )+ ) ;
	[GrammarRule("select_stat")]
	private AstParserRuleReturnScope<object, IToken> select_stat()
	{
		EnterRule_select_stat();
		EnterRule("select_stat", 11);
		TraceIn("select_stat", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal45 = default(IToken);
		IToken string_literal48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> select_case47 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal45_tree = default(object);
		object string_literal48_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_76=new RewriteRuleITokenStream(adaptor,"token 76");
		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		RewriteRuleSubtreeStream stream_select_case=new RewriteRuleSubtreeStream(adaptor,"rule select_case");
		try { DebugEnterRule(GrammarFileName, "select_stat");
		DebugLocation(139, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:140:2: ( 'selecione' atom ( select_case )+ 'fim' -> ^( SEL atom ( select_case )+ ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:140:4: 'selecione' atom ( select_case )+ 'fim'
			{
			DebugLocation(140, 4);
			string_literal45=(IToken)Match(input,76,Follow._76_in_select_stat680); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_76.Add(string_literal45);

			DebugLocation(140, 16);
			PushFollow(Follow._atom_in_select_stat682);
			atom46=atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_atom.Add(atom46.Tree);
			DebugLocation(141, 14);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:141:14: ( select_case )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==64))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:141:14: select_case
					{
					DebugLocation(141, 14);
					PushFollow(Follow._select_case_in_select_stat698);
					select_case47=select_case();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_select_case.Add(select_case47.Tree);

					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(142, 10);
			string_literal48=(IToken)Match(input,69,Follow._69_in_select_stat710); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal48);



			{
			// AST REWRITE
			// elements: select_case, atom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 144:10: -> ^( SEL atom ( select_case )+ )
			{
				DebugLocation(144, 13);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:144:13: ^( SEL atom ( select_case )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(144, 15);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SEL, "SEL"), root_1);

				DebugLocation(144, 19);
				adaptor.AddChild(root_1, stream_atom.NextTree());
				DebugLocation(144, 24);
				if (!(stream_select_case.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_select_case.HasNext )
				{
					DebugLocation(144, 24);
					adaptor.AddChild(root_1, stream_select_case.NextTree());

				}
				stream_select_case.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("select_stat", 11);
			LeaveRule("select_stat", 11);
			LeaveRule_select_stat();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "select_stat"); }
		return retval;

	}
	// $ANTLR end "select_stat"

	partial void EnterRule_select_case();
	partial void LeaveRule_select_case();

	// $ANTLR start "select_case"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:1: select_case : 'caso' atom ':' ( statement )* 'fim' -> ^( CASE atom ( statement )* ) ;
	[GrammarRule("select_case")]
	private AstParserRuleReturnScope<object, IToken> select_case()
	{
		EnterRule_select_case();
		EnterRule("select_case", 12);
		TraceIn("select_case", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal49 = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken string_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom50 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement52 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal49_tree = default(object);
		object char_literal51_tree = default(object);
		object string_literal53_tree = default(object);
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "select_case");
		DebugLocation(146, 74);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:13: ( 'caso' atom ':' ( statement )* 'fim' -> ^( CASE atom ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:15: 'caso' atom ':' ( statement )* 'fim'
			{
			DebugLocation(146, 15);
			string_literal49=(IToken)Match(input,64,Follow._64_in_select_case749); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_64.Add(string_literal49);

			DebugLocation(146, 22);
			PushFollow(Follow._atom_in_select_case751);
			atom50=atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_atom.Add(atom50.Tree);
			DebugLocation(146, 27);
			char_literal51=(IToken)Match(input,53,Follow._53_in_select_case753); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_53.Add(char_literal51);

			DebugLocation(146, 31);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:31: ( statement )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==ID||LA16_0==42||LA16_0==67||(LA16_0>=72 && LA16_0<=76)||LA16_0==78))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:31: statement
					{
					DebugLocation(146, 31);
					PushFollow(Follow._statement_in_select_case755);
					statement52=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement52.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(146, 42);
			string_literal53=(IToken)Match(input,69,Follow._69_in_select_case758); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_69.Add(string_literal53);



			{
			// AST REWRITE
			// elements: atom, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 146:48: -> ^( CASE atom ( statement )* )
			{
				DebugLocation(146, 51);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:51: ^( CASE atom ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(146, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CASE, "CASE"), root_1);

				DebugLocation(146, 58);
				adaptor.AddChild(root_1, stream_atom.NextTree());
				DebugLocation(146, 63);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:146:63: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(146, 63);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("select_case", 12);
			LeaveRule("select_case", 12);
			LeaveRule_select_case();
		}
		DebugLocation(146, 74);
		} finally { DebugExitRule(GrammarFileName, "select_case"); }
		return retval;

	}
	// $ANTLR end "select_case"

	partial void EnterRule_function_call();
	partial void LeaveRule_function_call();

	// $ANTLR start "function_call"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:148:1: function_call : ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) ;
	[GrammarRule("function_call")]
	private AstParserRuleReturnScope<object, IToken> function_call()
	{
		EnterRule_function_call();
		EnterRule("function_call", 13);
		TraceIn("function_call", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID54 = default(IToken);
		IToken char_literal55 = default(IToken);
		IToken char_literal57 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list56 = default(AstParserRuleReturnScope<object, IToken>);

		object ID54_tree = default(object);
		object char_literal55_tree = default(object);
		object char_literal57_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de função"); 
		try { DebugEnterRule(GrammarFileName, "function_call");
		DebugLocation(148, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:2: ( ID '(' ( function_arg_list )* ')' -> ^( CALL ID ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:4: ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(149, 4);
			ID54=(IToken)Match(input,ID,Follow._ID_in_function_call796); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID54);

			DebugLocation(149, 7);
			char_literal55=(IToken)Match(input,44,Follow._44_in_function_call798); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_44.Add(char_literal55);

			DebugLocation(149, 11);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: ( function_arg_list )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if (((LA17_0>=F && LA17_0<=FLOAT)||LA17_0==ID||LA17_0==INT||(LA17_0>=STRING && LA17_0<=T)||LA17_0==44))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: function_arg_list
					{
					DebugLocation(149, 11);
					PushFollow(Follow._function_arg_list_in_function_call800);
					function_arg_list56=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list56.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(149, 30);
			char_literal57=(IToken)Match(input,45,Follow._45_in_function_call803); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_45.Add(char_literal57);



			{
			// AST REWRITE
			// elements: ID, function_arg_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 149:34: -> ^( CALL ID ( function_arg_list )* )
			{
				DebugLocation(149, 37);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:37: ^( CALL ID ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(149, 39);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CALL, "CALL"), root_1);

				DebugLocation(149, 44);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(149, 47);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:47: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(149, 47);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("function_call", 13);
			LeaveRule("function_call", 13);
			LeaveRule_function_call();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "function_call"); }
		return retval;

	}
	// $ANTLR end "function_call"

	partial void EnterRule_property_call();
	partial void LeaveRule_property_call();

	// $ANTLR start "property_call"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:152:1: property_call : o= ID '.' p= ID -> ^( PCALL $o $p) ;
	[GrammarRule("property_call")]
	private AstParserRuleReturnScope<object, IToken> property_call()
	{
		EnterRule_property_call();
		EnterRule("property_call", 14);
		TraceIn("property_call", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal58 = default(IToken);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal58_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "property_call");
		DebugLocation(152, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:153:2: (o= ID '.' p= ID -> ^( PCALL $o $p) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:153:4: o= ID '.' p= ID
			{
			DebugLocation(153, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_property_call844); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(153, 8);
			char_literal58=(IToken)Match(input,50,Follow._50_in_property_call845); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_50.Add(char_literal58);

			DebugLocation(153, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_property_call848); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);



			{
			// AST REWRITE
			// elements: o, p
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 153:17: -> ^( PCALL $o $p)
			{
				DebugLocation(153, 20);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:153:20: ^( PCALL $o $p)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(153, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PCALL, "PCALL"), root_1);

				DebugLocation(153, 29);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(153, 32);
				adaptor.AddChild(root_1, stream_p.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("property_call", 14);
			LeaveRule("property_call", 14);
			LeaveRule_property_call();
		}
		DebugLocation(154, 1);
		} finally { DebugExitRule(GrammarFileName, "property_call"); }
		return retval;

	}
	// $ANTLR end "property_call"

	partial void EnterRule_method_call();
	partial void LeaveRule_method_call();

	// $ANTLR start "method_call"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:156:1: method_call : o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) ;
	[GrammarRule("method_call")]
	private AstParserRuleReturnScope<object, IToken> method_call()
	{
		EnterRule_method_call();
		EnterRule("method_call", 15);
		TraceIn("method_call", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken o = default(IToken);
		IToken p = default(IToken);
		IToken char_literal59 = default(IToken);
		IToken char_literal60 = default(IToken);
		IToken char_literal62 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_arg_list61 = default(AstParserRuleReturnScope<object, IToken>);

		object o_tree = default(object);
		object p_tree = default(object);
		object char_literal59_tree = default(object);
		object char_literal60_tree = default(object);
		object char_literal62_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleSubtreeStream stream_function_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule function_arg_list");
		 paraphrases.Push("na chamada de propriedade"); 
		try { DebugEnterRule(GrammarFileName, "method_call");
		DebugLocation(156, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:2: (o= ID '.' p= ID '(' ( function_arg_list )* ')' -> ^( MCALL $o $p ( function_arg_list )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:4: o= ID '.' p= ID '(' ( function_arg_list )* ')'
			{
			DebugLocation(157, 5);
			o=(IToken)Match(input,ID,Follow._ID_in_method_call892); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(o);

			DebugLocation(157, 8);
			char_literal59=(IToken)Match(input,50,Follow._50_in_method_call893); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_50.Add(char_literal59);

			DebugLocation(157, 12);
			p=(IToken)Match(input,ID,Follow._ID_in_method_call896); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(p);

			DebugLocation(157, 16);
			char_literal60=(IToken)Match(input,44,Follow._44_in_method_call898); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_44.Add(char_literal60);

			DebugLocation(157, 20);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: ( function_arg_list )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if (((LA18_0>=F && LA18_0<=FLOAT)||LA18_0==ID||LA18_0==INT||(LA18_0>=STRING && LA18_0<=T)||LA18_0==44))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: function_arg_list
					{
					DebugLocation(157, 20);
					PushFollow(Follow._function_arg_list_in_method_call900);
					function_arg_list61=function_arg_list();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function_arg_list.Add(function_arg_list61.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(157, 39);
			char_literal62=(IToken)Match(input,45,Follow._45_in_method_call903); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_45.Add(char_literal62);



			{
			// AST REWRITE
			// elements: function_arg_list, o, p
			// token labels: p, o
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_p=new RewriteRuleITokenStream(adaptor,"token p",p);
			RewriteRuleITokenStream stream_o=new RewriteRuleITokenStream(adaptor,"token o",o);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 157:43: -> ^( MCALL $o $p ( function_arg_list )* )
			{
				DebugLocation(157, 46);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:46: ^( MCALL $o $p ( function_arg_list )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(157, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(MCALL, "MCALL"), root_1);

				DebugLocation(157, 55);
				adaptor.AddChild(root_1, stream_o.NextNode());
				DebugLocation(157, 58);
				adaptor.AddChild(root_1, stream_p.NextNode());
				DebugLocation(157, 60);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:60: ( function_arg_list )*
				while ( stream_function_arg_list.HasNext )
				{
					DebugLocation(157, 60);
					adaptor.AddChild(root_1, stream_function_arg_list.NextTree());

				}
				stream_function_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("method_call", 15);
			LeaveRule("method_call", 15);
			LeaveRule_method_call();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "method_call"); }
		return retval;

	}
	// $ANTLR end "method_call"

	partial void EnterRule_function_arg_list();
	partial void LeaveRule_function_arg_list();

	// $ANTLR start "function_arg_list"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:160:1: function_arg_list : plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) ;
	[GrammarRule("function_arg_list")]
	private AstParserRuleReturnScope<object, IToken> function_arg_list()
	{
		EnterRule_function_arg_list();
		EnterRule("function_arg_list", 16);
		TraceIn("function_arg_list", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal64 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression63 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression65 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal64_tree = default(object);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		 paraphrases.Push("nos argumentos da função"); 
		try { DebugEnterRule(GrammarFileName, "function_arg_list");
		DebugLocation(160, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:2: ( plus_expression ( ',' plus_expression )* -> ^( ARG ( plus_expression )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:4: plus_expression ( ',' plus_expression )*
			{
			DebugLocation(162, 4);
			PushFollow(Follow._plus_expression_in_function_arg_list948);
			plus_expression63=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression63.Tree);
			DebugLocation(162, 20);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:20: ( ',' plus_expression )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==48))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:21: ',' plus_expression
					{
					DebugLocation(162, 21);
					char_literal64=(IToken)Match(input,48,Follow._48_in_function_arg_list951); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_48.Add(char_literal64);

					DebugLocation(162, 25);
					PushFollow(Follow._plus_expression_in_function_arg_list953);
					plus_expression65=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_plus_expression.Add(plus_expression65.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 162:43: -> ^( ARG ( plus_expression )* )
			{
				DebugLocation(162, 46);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:46: ^( ARG ( plus_expression )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(162, 48);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(162, 52);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:162:52: ( plus_expression )*
				while ( stream_plus_expression.HasNext )
				{
					DebugLocation(162, 52);
					adaptor.AddChild(root_1, stream_plus_expression.NextTree());

				}
				stream_plus_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("function_arg_list", 16);
			LeaveRule("function_arg_list", 16);
			LeaveRule_function_arg_list();
		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "function_arg_list"); }
		return retval;

	}
	// $ANTLR end "function_arg_list"

	partial void EnterRule_assign_var();
	partial void LeaveRule_assign_var();

	// $ANTLR start "assign_var"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:165:1: assign_var : ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ';' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) );
	[GrammarRule("assign_var")]
	private AstParserRuleReturnScope<object, IToken> assign_var()
	{
		EnterRule_assign_var();
		EnterRule("assign_var", 17);
		TraceIn("assign_var", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID66 = default(IToken);
		IToken char_literal67 = default(IToken);
		IToken char_literal68 = default(IToken);
		IToken INT69 = default(IToken);
		IToken string_literal70 = default(IToken);
		IToken INT71 = default(IToken);
		IToken char_literal72 = default(IToken);
		IToken ID73 = default(IToken);
		IToken char_literal74 = default(IToken);
		IToken char_literal75 = default(IToken);
		IToken INT76 = default(IToken);
		IToken char_literal77 = default(IToken);
		IToken INT78 = default(IToken);
		IToken char_literal79 = default(IToken);
		IToken ID80 = default(IToken);
		IToken char_literal81 = default(IToken);
		IToken char_literal83 = default(IToken);
		IToken char_literal84 = default(IToken);
		IToken ID86 = default(IToken);
		IToken char_literal87 = default(IToken);
		AstParserRuleReturnScope<object, IToken> index82 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assign_expression88 = default(AstParserRuleReturnScope<object, IToken>);

		object ID66_tree = default(object);
		object char_literal67_tree = default(object);
		object char_literal68_tree = default(object);
		object INT69_tree = default(object);
		object string_literal70_tree = default(object);
		object INT71_tree = default(object);
		object char_literal72_tree = default(object);
		object ID73_tree = default(object);
		object char_literal74_tree = default(object);
		object char_literal75_tree = default(object);
		object INT76_tree = default(object);
		object char_literal77_tree = default(object);
		object INT78_tree = default(object);
		object char_literal79_tree = default(object);
		object ID80_tree = default(object);
		object char_literal81_tree = default(object);
		object char_literal83_tree = default(object);
		object char_literal84_tree = default(object);
		object ID86_tree = default(object);
		object char_literal87_tree = default(object);
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleITokenStream stream_INT=new RewriteRuleITokenStream(adaptor,"token INT");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_51=new RewriteRuleITokenStream(adaptor,"token 51");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_54=new RewriteRuleITokenStream(adaptor,"token 54");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		 paraphrases.Push("na atribuição de variável"); 
		try { DebugEnterRule(GrammarFileName, "assign_var");
		DebugLocation(165, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:166:2: ( ID '=' '[' INT '..' INT ']' -> ^( ASGN ID INT INT ) | ID '=' '{' INT ( ';' INT )* '}' -> ^( ASGN ID ^( ILIST ( INT )* ) ) | ID '[' index ']' '=' assign_expression -> ^( ASGN ^( AR index ) ID assign_expression ) | ID '=' assign_expression -> ^( ASGN ID assign_expression ) )
			int alt21=4;
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==ID))
			{
				int LA21_1 = input.LA(2);

				if ((LA21_1==57))
				{
					int LA21_2 = input.LA(3);

					if ((EvaluatePredicate(synpred28_NPortugol_fragment)))
					{
						alt21 = 1;
					}
					else if ((EvaluatePredicate(synpred30_NPortugol_fragment)))
					{
						alt21 = 2;
					}
					else if ((true))
					{
						alt21 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 21, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA21_1==61))
				{
					alt21 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:9: ID '=' '[' INT '..' INT ']'
				{
				DebugLocation(167, 9);
				ID66=(IToken)Match(input,ID,Follow._ID_in_assign_var1005); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID66);

				DebugLocation(167, 12);
				char_literal67=(IToken)Match(input,57,Follow._57_in_assign_var1007); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal67);

				DebugLocation(167, 16);
				char_literal68=(IToken)Match(input,61,Follow._61_in_assign_var1009); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(char_literal68);

				DebugLocation(167, 20);
				INT69=(IToken)Match(input,INT,Follow._INT_in_assign_var1011); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT69);

				DebugLocation(167, 24);
				string_literal70=(IToken)Match(input,51,Follow._51_in_assign_var1013); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_51.Add(string_literal70);

				DebugLocation(167, 29);
				INT71=(IToken)Match(input,INT,Follow._INT_in_assign_var1015); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT71);

				DebugLocation(167, 33);
				char_literal72=(IToken)Match(input,62,Follow._62_in_assign_var1017); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal72);



				{
				// AST REWRITE
				// elements: ID, INT, INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 167:37: -> ^( ASGN ID INT INT )
				{
					DebugLocation(167, 40);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:40: ^( ASGN ID INT INT )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(167, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(167, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(167, 50);
					adaptor.AddChild(root_1, stream_INT.NextNode());
					DebugLocation(167, 54);
					adaptor.AddChild(root_1, stream_INT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:10: ID '=' '{' INT ( ';' INT )* '}'
				{
				DebugLocation(168, 10);
				ID73=(IToken)Match(input,ID,Follow._ID_in_assign_var1040); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID73);

				DebugLocation(168, 13);
				char_literal74=(IToken)Match(input,57,Follow._57_in_assign_var1042); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal74);

				DebugLocation(168, 17);
				char_literal75=(IToken)Match(input,79,Follow._79_in_assign_var1044); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_79.Add(char_literal75);

				DebugLocation(168, 21);
				INT76=(IToken)Match(input,INT,Follow._INT_in_assign_var1046); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INT.Add(INT76);

				DebugLocation(168, 25);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:25: ( ';' INT )*
				try { DebugEnterSubRule(20);
				while (true)
				{
					int alt20=2;
					try { DebugEnterDecision(20, false);
					int LA20_0 = input.LA(1);

					if ((LA20_0==54))
					{
						alt20 = 1;
					}


					} finally { DebugExitDecision(20); }
					switch ( alt20 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:26: ';' INT
						{
						DebugLocation(168, 26);
						char_literal77=(IToken)Match(input,54,Follow._54_in_assign_var1049); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_54.Add(char_literal77);

						DebugLocation(168, 30);
						INT78=(IToken)Match(input,INT,Follow._INT_in_assign_var1051); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_INT.Add(INT78);


						}
						break;

					default:
						goto loop20;
					}
				}

				loop20:
					;

				} finally { DebugExitSubRule(20); }

				DebugLocation(168, 36);
				char_literal79=(IToken)Match(input,80,Follow._80_in_assign_var1055); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_80.Add(char_literal79);



				{
				// AST REWRITE
				// elements: ID, INT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 168:40: -> ^( ASGN ID ^( ILIST ( INT )* ) )
				{
					DebugLocation(168, 43);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:43: ^( ASGN ID ^( ILIST ( INT )* ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(168, 45);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(168, 50);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(168, 53);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:53: ^( ILIST ( INT )* )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(168, 55);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ILIST, "ILIST"), root_2);

					DebugLocation(168, 61);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:61: ( INT )*
					while ( stream_INT.HasNext )
					{
						DebugLocation(168, 61);
						adaptor.AddChild(root_2, stream_INT.NextNode());

					}
					stream_INT.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:169:4: ID '[' index ']' '=' assign_expression
				{
				DebugLocation(169, 4);
				ID80=(IToken)Match(input,ID,Follow._ID_in_assign_var1075); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID80);

				DebugLocation(169, 7);
				char_literal81=(IToken)Match(input,61,Follow._61_in_assign_var1077); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(char_literal81);

				DebugLocation(169, 11);
				PushFollow(Follow._index_in_assign_var1079);
				index82=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index82.Tree);
				DebugLocation(169, 17);
				char_literal83=(IToken)Match(input,62,Follow._62_in_assign_var1081); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal83);

				DebugLocation(169, 21);
				char_literal84=(IToken)Match(input,57,Follow._57_in_assign_var1083); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal84);

				DebugLocation(169, 25);
				PushFollow(Follow._assign_expression_in_assign_var1085);
				assign_expression85=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression85.Tree);


				{
				// AST REWRITE
				// elements: index, ID, assign_expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 169:44: -> ^( ASGN ^( AR index ) ID assign_expression )
				{
					DebugLocation(169, 47);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:169:47: ^( ASGN ^( AR index ) ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(169, 49);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(169, 54);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:169:54: ^( AR index )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(169, 56);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(AR, "AR"), root_2);

					DebugLocation(169, 59);
					adaptor.AddChild(root_2, stream_index.NextTree());

					adaptor.AddChild(root_1, root_2);
					}
					DebugLocation(169, 66);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(169, 69);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:170:11: ID '=' assign_expression
				{
				DebugLocation(170, 11);
				ID86=(IToken)Match(input,ID,Follow._ID_in_assign_var1114); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID86);

				DebugLocation(170, 14);
				char_literal87=(IToken)Match(input,57,Follow._57_in_assign_var1116); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(char_literal87);

				DebugLocation(170, 18);
				PushFollow(Follow._assign_expression_in_assign_var1118);
				assign_expression88=assign_expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assign_expression.Add(assign_expression88.Tree);


				{
				// AST REWRITE
				// elements: ID, assign_expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 170:37: -> ^( ASGN ID assign_expression )
				{
					DebugLocation(170, 40);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:170:40: ^( ASGN ID assign_expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(170, 42);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASGN, "ASGN"), root_1);

					DebugLocation(170, 47);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(170, 50);
					adaptor.AddChild(root_1, stream_assign_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				 paraphrases.Pop(); 
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("assign_var", 17);
			LeaveRule("assign_var", 17);
			LeaveRule_assign_var();
		}
		DebugLocation(171, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_var"); }
		return retval;

	}
	// $ANTLR end "assign_var"

	partial void EnterRule_return_stat();
	partial void LeaveRule_return_stat();

	// $ANTLR start "return_stat"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:173:1: return_stat : 'retorne' assign_expression -> ^( RET assign_expression ) ;
	[GrammarRule("return_stat")]
	private AstParserRuleReturnScope<object, IToken> return_stat()
	{
		EnterRule_return_stat();
		EnterRule("return_stat", 18);
		TraceIn("return_stat", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal89 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assign_expression90 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal89_tree = default(object);
		RewriteRuleITokenStream stream_74=new RewriteRuleITokenStream(adaptor,"token 74");
		RewriteRuleSubtreeStream stream_assign_expression=new RewriteRuleSubtreeStream(adaptor,"rule assign_expression");
		try { DebugEnterRule(GrammarFileName, "return_stat");
		DebugLocation(173, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:174:2: ( 'retorne' assign_expression -> ^( RET assign_expression ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:174:4: 'retorne' assign_expression
			{
			DebugLocation(174, 4);
			string_literal89=(IToken)Match(input,74,Follow._74_in_return_stat1141); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_74.Add(string_literal89);

			DebugLocation(174, 14);
			PushFollow(Follow._assign_expression_in_return_stat1143);
			assign_expression90=assign_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assign_expression.Add(assign_expression90.Tree);


			{
			// AST REWRITE
			// elements: assign_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 174:33: -> ^( RET assign_expression )
			{
				DebugLocation(174, 36);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:174:36: ^( RET assign_expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(174, 38);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RET, "RET"), root_1);

				DebugLocation(174, 42);
				adaptor.AddChild(root_1, stream_assign_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("return_stat", 18);
			LeaveRule("return_stat", 18);
			LeaveRule_return_stat();
		}
		DebugLocation(175, 1);
		} finally { DebugExitRule(GrammarFileName, "return_stat"); }
		return retval;

	}
	// $ANTLR end "return_stat"

	partial void EnterRule_asm_code();
	partial void LeaveRule_asm_code();

	// $ANTLR start "asm_code"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:1: asm_code : '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) ;
	[GrammarRule("asm_code")]
	private AstParserRuleReturnScope<object, IToken> asm_code()
	{
		EnterRule_asm_code();
		EnterRule("asm_code", 19);
		TraceIn("asm_code", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal91 = default(IToken);
		IToken STRING92 = default(IToken);
		IToken char_literal93 = default(IToken);

		object char_literal91_tree = default(object);
		object STRING92_tree = default(object);
		object char_literal93_tree = default(object);
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "asm_code");
		DebugLocation(178, 8);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:9: ( '#' ( STRING )* '#' -> ^( ASM ( STRING )* ) )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:11: '#' ( STRING )* '#'
			{
			DebugLocation(178, 11);
			char_literal91=(IToken)Match(input,42,Follow._42_in_asm_code1162); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal91);

			DebugLocation(178, 15);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:15: ( STRING )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==STRING))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:15: STRING
					{
					DebugLocation(178, 15);
					STRING92=(IToken)Match(input,STRING,Follow._STRING_in_asm_code1164); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_STRING.Add(STRING92);


					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(178, 23);
			char_literal93=(IToken)Match(input,42,Follow._42_in_asm_code1167); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_42.Add(char_literal93);



			{
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 178:27: -> ^( ASM ( STRING )* )
			{
				DebugLocation(178, 30);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:30: ^( ASM ( STRING )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(178, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ASM, "ASM"), root_1);

				DebugLocation(178, 36);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:178:36: ( STRING )*
				while ( stream_STRING.HasNext )
				{
					DebugLocation(178, 36);
					adaptor.AddChild(root_1, stream_STRING.NextNode());

				}
				stream_STRING.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("asm_code", 19);
			LeaveRule("asm_code", 19);
			LeaveRule_asm_code();
		}
		DebugLocation(179, 8);
		} finally { DebugExitRule(GrammarFileName, "asm_code"); }
		return retval;

	}
	// $ANTLR end "asm_code"

	partial void EnterRule_logic_expression();
	partial void LeaveRule_logic_expression();

	// $ANTLR start "logic_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:185:1: logic_expression : ( plus_expression ) ( binop ^ plus_expression )* ;
	[GrammarRule("logic_expression")]
	private AstParserRuleReturnScope<object, IToken> logic_expression()
	{
		EnterRule_logic_expression();
		EnterRule("logic_expression", 20);
		TraceIn("logic_expression", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression94 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> binop95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> plus_expression96 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "logic_expression");
		DebugLocation(185, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:2: ( ( plus_expression ) ( binop ^ plus_expression )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:4: ( plus_expression ) ( binop ^ plus_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(186, 4);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:4: ( plus_expression )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:5: plus_expression
			{
			DebugLocation(186, 5);
			PushFollow(Follow._plus_expression_in_logic_expression1199);
			plus_expression94=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression94.Tree);

			}

			DebugLocation(186, 22);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:22: ( binop ^ plus_expression )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==41||(LA23_0>=55 && LA23_0<=56)||(LA23_0>=58 && LA23_0<=60)||LA23_0==66||LA23_0==71))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:186:23: binop ^ plus_expression
					{
					DebugLocation(186, 28);
					PushFollow(Follow._binop_in_logic_expression1203);
					binop95=binop();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot(binop95.Tree, root_0);
					DebugLocation(186, 30);
					PushFollow(Follow._plus_expression_in_logic_expression1206);
					plus_expression96=plus_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression96.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("logic_expression", 20);
			LeaveRule("logic_expression", 20);
			LeaveRule_logic_expression();
		}
		DebugLocation(187, 1);
		} finally { DebugExitRule(GrammarFileName, "logic_expression"); }
		return retval;

	}
	// $ANTLR end "logic_expression"

	partial void EnterRule_binop();
	partial void LeaveRule_binop();

	// $ANTLR start "binop"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:189:1: binop : ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' );
	[GrammarRule("binop")]
	private AstParserRuleReturnScope<object, IToken> binop()
	{
		EnterRule_binop();
		EnterRule("binop", 21);
		TraceIn("binop", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set97 = default(IToken);

		object set97_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binop");
		DebugLocation(189, 59);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:189:7: ( '<' | '>' | '<=' | '>=' | '==' | '!=' | 'e' | 'ou' )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(189, 7);

			set97=(IToken)input.LT(1);
			if (input.LA(1)==41||(input.LA(1)>=55 && input.LA(1)<=56)||(input.LA(1)>=58 && input.LA(1)<=60)||input.LA(1)==66||input.LA(1)==71)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set97));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("binop", 21);
			LeaveRule("binop", 21);
			LeaveRule_binop();
		}
		DebugLocation(189, 59);
		} finally { DebugExitRule(GrammarFileName, "binop"); }
		return retval;

	}
	// $ANTLR end "binop"

	partial void EnterRule_assign_expression();
	partial void LeaveRule_assign_expression();

	// $ANTLR start "assign_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:192:1: assign_expression options {k=3; } : plus_expression ;
	[GrammarRule("assign_expression")]
	private AstParserRuleReturnScope<object, IToken> assign_expression()
	{
		EnterRule_assign_expression();
		EnterRule("assign_expression", 22);
		TraceIn("assign_expression", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> plus_expression98 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "assign_expression");
		DebugLocation(192, 19);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:194:2: ( plus_expression )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:194:5: plus_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(194, 5);
			PushFollow(Follow._plus_expression_in_assign_expression1267);
			plus_expression98=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, plus_expression98.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("assign_expression", 22);
			LeaveRule("assign_expression", 22);
			LeaveRule_assign_expression();
		}
		DebugLocation(194, 19);
		} finally { DebugExitRule(GrammarFileName, "assign_expression"); }
		return retval;

	}
	// $ANTLR end "assign_expression"

	partial void EnterRule_plus_expression();
	partial void LeaveRule_plus_expression();

	// $ANTLR start "plus_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:196:1: plus_expression : ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* ;
	[GrammarRule("plus_expression")]
	private AstParserRuleReturnScope<object, IToken> plus_expression()
	{
		EnterRule_plus_expression();
		EnterRule("plus_expression", 23);
		TraceIn("plus_expression", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal100 = default(IToken);
		IToken char_literal102 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mul_expression99 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mul_expression103 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal100_tree = default(object);
		object char_literal102_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "plus_expression");
		DebugLocation(196, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:2: ( ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:4: ( mul_expression ) ( '+' ^ mul_expression | '-' ^ mul_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(197, 4);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:4: ( mul_expression )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:5: mul_expression
			{
			DebugLocation(197, 5);
			PushFollow(Follow._mul_expression_in_plus_expression1277);
			mul_expression99=mul_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression99.Tree);

			}

			DebugLocation(197, 21);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:21: ( '+' ^ mul_expression | '-' ^ mul_expression )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=3;
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==47))
				{
					alt24 = 1;
				}
				else if ((LA24_0==49))
				{
					alt24 = 2;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:22: '+' ^ mul_expression
					{
					DebugLocation(197, 25);
					char_literal100=(IToken)Match(input,47,Follow._47_in_plus_expression1281); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal100_tree = (object)adaptor.Create(char_literal100);
					root_0 = (object)adaptor.BecomeRoot(char_literal100_tree, root_0);
					}
					DebugLocation(197, 27);
					PushFollow(Follow._mul_expression_in_plus_expression1284);
					mul_expression101=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression101.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:197:44: '-' ^ mul_expression
					{
					DebugLocation(197, 47);
					char_literal102=(IToken)Match(input,49,Follow._49_in_plus_expression1288); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal102_tree = (object)adaptor.Create(char_literal102);
					root_0 = (object)adaptor.BecomeRoot(char_literal102_tree, root_0);
					}
					DebugLocation(197, 49);
					PushFollow(Follow._mul_expression_in_plus_expression1291);
					mul_expression103=mul_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, mul_expression103.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("plus_expression", 23);
			LeaveRule("plus_expression", 23);
			LeaveRule_plus_expression();
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "plus_expression"); }
		return retval;

	}
	// $ANTLR end "plus_expression"

	partial void EnterRule_mul_expression();
	partial void LeaveRule_mul_expression();

	// $ANTLR start "mul_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:200:1: mul_expression : ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* ;
	[GrammarRule("mul_expression")]
	private AstParserRuleReturnScope<object, IToken> mul_expression()
	{
		EnterRule_mul_expression();
		EnterRule("mul_expression", 24);
		TraceIn("mul_expression", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal105 = default(IToken);
		IToken char_literal107 = default(IToken);
		IToken char_literal109 = default(IToken);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression104 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression106 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression108 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> primary_ar_expression110 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal105_tree = default(object);
		object char_literal107_tree = default(object);
		object char_literal109_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mul_expression");
		DebugLocation(200, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:2: ( ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )* )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ( primary_ar_expression ) ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(201, 4);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:4: ( primary_ar_expression )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:5: primary_ar_expression
			{
			DebugLocation(201, 5);
			PushFollow(Follow._primary_ar_expression_in_mul_expression1306);
			primary_ar_expression104=primary_ar_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression104.Tree);

			}

			DebugLocation(201, 28);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:28: ( '/' ^ primary_ar_expression | '%' ^ primary_ar_expression | '*' ^ primary_ar_expression )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=4;
				try { DebugEnterDecision(25, false);
				switch (input.LA(1))
				{
				case 52:
					{
					alt25 = 1;
					}
					break;
				case 43:
					{
					alt25 = 2;
					}
					break;
				case 46:
					{
					alt25 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:30: '/' ^ primary_ar_expression
					{
					DebugLocation(201, 33);
					char_literal105=(IToken)Match(input,52,Follow._52_in_mul_expression1311); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal105_tree = (object)adaptor.Create(char_literal105);
					root_0 = (object)adaptor.BecomeRoot(char_literal105_tree, root_0);
					}
					DebugLocation(201, 35);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1314);
					primary_ar_expression106=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression106.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:59: '%' ^ primary_ar_expression
					{
					DebugLocation(201, 62);
					char_literal107=(IToken)Match(input,43,Follow._43_in_mul_expression1318); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal107_tree = (object)adaptor.Create(char_literal107);
					root_0 = (object)adaptor.BecomeRoot(char_literal107_tree, root_0);
					}
					DebugLocation(201, 64);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1321);
					primary_ar_expression108=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression108.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:201:88: '*' ^ primary_ar_expression
					{
					DebugLocation(201, 91);
					char_literal109=(IToken)Match(input,46,Follow._46_in_mul_expression1325); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal109_tree = (object)adaptor.Create(char_literal109);
					root_0 = (object)adaptor.BecomeRoot(char_literal109_tree, root_0);
					}
					DebugLocation(201, 93);
					PushFollow(Follow._primary_ar_expression_in_mul_expression1328);
					primary_ar_expression110=primary_ar_expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primary_ar_expression110.Tree);

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("mul_expression", 24);
			LeaveRule("mul_expression", 24);
			LeaveRule_mul_expression();
		}
		DebugLocation(202, 1);
		} finally { DebugExitRule(GrammarFileName, "mul_expression"); }
		return retval;

	}
	// $ANTLR end "mul_expression"

	partial void EnterRule_primary_ar_expression();
	partial void LeaveRule_primary_ar_expression();

	// $ANTLR start "primary_ar_expression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:204:1: primary_ar_expression : ({...}? => function_call | ID | T | F | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression );
	[GrammarRule("primary_ar_expression")]
	private AstParserRuleReturnScope<object, IToken> primary_ar_expression()
	{
		EnterRule_primary_ar_expression();
		EnterRule("primary_ar_expression", 25);
		TraceIn("primary_ar_expression", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID112 = default(IToken);
		IToken T113 = default(IToken);
		IToken F114 = default(IToken);
		IToken ID115 = default(IToken);
		IToken char_literal116 = default(IToken);
		IToken char_literal118 = default(IToken);
		AstParserRuleReturnScope<object, IToken> function_call111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> index117 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> method_call119 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> property_call120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant121 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesisExpression122 = default(AstParserRuleReturnScope<object, IToken>);

		object ID112_tree = default(object);
		object T113_tree = default(object);
		object F114_tree = default(object);
		object ID115_tree = default(object);
		object char_literal116_tree = default(object);
		object char_literal118_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleITokenStream stream_61=new RewriteRuleITokenStream(adaptor,"token 61");
		RewriteRuleSubtreeStream stream_index=new RewriteRuleSubtreeStream(adaptor,"rule index");
		try { DebugEnterRule(GrammarFileName, "primary_ar_expression");
		DebugLocation(204, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:2: ({...}? => function_call | ID | T | F | ID '[' index ']' -> ^( INDEX index ) ID | method_call | property_call | constant | parenthesisExpression )
			int alt26=9;
			try { DebugEnterDecision(26, false);
			switch (input.LA(1))
			{
			case ID:
				{
				switch (input.LA(2))
				{
				case 44:
					{
					int LA26_6 = input.LA(3);

					if ((((( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )&&( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" ))&&EvaluatePredicate(synpred46_NPortugol_fragment))))
					{
						alt26 = 1;
					}
					else if ((EvaluatePredicate(synpred47_NPortugol_fragment)))
					{
						alt26 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 26, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case 61:
					{
					alt26 = 5;
					}
					break;
				case 50:
					{
					int LA26_8 = input.LA(3);

					if ((EvaluatePredicate(synpred51_NPortugol_fragment)))
					{
						alt26 = 6;
					}
					else if ((EvaluatePredicate(synpred52_NPortugol_fragment)))
					{
						alt26 = 7;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 26, 8, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case EOF:
				case F:
				case FLOAT:
				case ID:
				case INT:
				case STRING:
				case T:
				case 41:
				case 42:
				case 43:
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
				case 52:
				case 55:
				case 56:
				case 58:
				case 59:
				case 60:
				case 63:
				case 66:
				case 67:
				case 68:
				case 69:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
					{
					alt26 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 26, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				}
				break;
			case T:
				{
				alt26 = 3;
				}
				break;
			case F:
				{
				alt26 = 4;
				}
				break;
			case FLOAT:
			case INT:
			case STRING:
				{
				alt26 = 8;
				}
				break;
			case 44:
				{
				alt26 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: {...}? => function_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(205, 4);
				if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "primary_ar_expression", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
				}
				DebugLocation(205, 71);
				PushFollow(Follow._function_call_in_primary_ar_expression1346);
				function_call111=function_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function_call111.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(206, 4);
				ID112=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1351); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID112_tree = (object)adaptor.Create(ID112);
				adaptor.AddChild(root_0, ID112_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:207:4: T
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(207, 4);
				T113=(IToken)Match(input,T,Follow._T_in_primary_ar_expression1356); if (state.failed) return retval;
				if (state.backtracking == 0) {
				T113_tree = (object)adaptor.Create(T113);
				adaptor.AddChild(root_0, T113_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:208:4: F
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(208, 4);
				F114=(IToken)Match(input,F,Follow._F_in_primary_ar_expression1361); if (state.failed) return retval;
				if (state.backtracking == 0) {
				F114_tree = (object)adaptor.Create(F114);
				adaptor.AddChild(root_0, F114_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:4: ID '[' index ']'
				{
				DebugLocation(209, 4);
				ID115=(IToken)Match(input,ID,Follow._ID_in_primary_ar_expression1366); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID115);

				DebugLocation(209, 7);
				char_literal116=(IToken)Match(input,61,Follow._61_in_primary_ar_expression1368); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_61.Add(char_literal116);

				DebugLocation(209, 11);
				PushFollow(Follow._index_in_primary_ar_expression1370);
				index117=index();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_index.Add(index117.Tree);
				DebugLocation(209, 17);
				char_literal118=(IToken)Match(input,62,Follow._62_in_primary_ar_expression1372); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal118);



				{
				// AST REWRITE
				// elements: ID, index
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 209:21: -> ^( INDEX index ) ID
				{
					DebugLocation(209, 24);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:209:24: ^( INDEX index )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(209, 26);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INDEX, "INDEX"), root_1);

					DebugLocation(209, 32);
					adaptor.AddChild(root_1, stream_index.NextTree());

					adaptor.AddChild(root_0, root_1);
					}
					DebugLocation(209, 39);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:210:4: method_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(210, 4);
				PushFollow(Follow._method_call_in_primary_ar_expression1387);
				method_call119=method_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, method_call119.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:211:4: property_call
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(211, 4);
				PushFollow(Follow._property_call_in_primary_ar_expression1393);
				property_call120=property_call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, property_call120.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:212:4: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(212, 4);
				PushFollow(Follow._constant_in_primary_ar_expression1398);
				constant121=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant121.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:213:4: parenthesisExpression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(213, 4);
				PushFollow(Follow._parenthesisExpression_in_primary_ar_expression1403);
				parenthesisExpression122=parenthesisExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parenthesisExpression122.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("primary_ar_expression", 25);
			LeaveRule("primary_ar_expression", 25);
			LeaveRule_primary_ar_expression();
		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "primary_ar_expression"); }
		return retval;

	}
	// $ANTLR end "primary_ar_expression"

	partial void EnterRule_parenthesisExpression();
	partial void LeaveRule_parenthesisExpression();

	// $ANTLR start "parenthesisExpression"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:1: parenthesisExpression : '(' plus_expression ')' -> plus_expression ;
	[GrammarRule("parenthesisExpression")]
	private AstParserRuleReturnScope<object, IToken> parenthesisExpression()
	{
		EnterRule_parenthesisExpression();
		EnterRule("parenthesisExpression", 26);
		TraceIn("parenthesisExpression", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal123 = default(IToken);
		IToken char_literal125 = default(IToken);
		AstParserRuleReturnScope<object, IToken> plus_expression124 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal123_tree = default(object);
		object char_literal125_tree = default(object);
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleITokenStream stream_44=new RewriteRuleITokenStream(adaptor,"token 44");
		RewriteRuleSubtreeStream stream_plus_expression=new RewriteRuleSubtreeStream(adaptor,"rule plus_expression");
		try { DebugEnterRule(GrammarFileName, "parenthesisExpression");
		DebugLocation(216, 1);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:22: ( '(' plus_expression ')' -> plus_expression )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:216:24: '(' plus_expression ')'
			{
			DebugLocation(216, 24);
			char_literal123=(IToken)Match(input,44,Follow._44_in_parenthesisExpression1418); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_44.Add(char_literal123);

			DebugLocation(216, 28);
			PushFollow(Follow._plus_expression_in_parenthesisExpression1420);
			plus_expression124=plus_expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_plus_expression.Add(plus_expression124.Tree);
			DebugLocation(216, 44);
			char_literal125=(IToken)Match(input,45,Follow._45_in_parenthesisExpression1422); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_45.Add(char_literal125);



			{
			// AST REWRITE
			// elements: plus_expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 216:48: -> plus_expression
			{
				DebugLocation(216, 51);
				adaptor.AddChild(root_0, stream_plus_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("parenthesisExpression", 26);
			LeaveRule("parenthesisExpression", 26);
			LeaveRule_parenthesisExpression();
		}
		DebugLocation(217, 1);
		} finally { DebugExitRule(GrammarFileName, "parenthesisExpression"); }
		return retval;

	}
	// $ANTLR end "parenthesisExpression"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:219:1: constant : ( INT | FLOAT | STRING );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<object, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 27);
		TraceIn("constant", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set126 = default(IToken);

		object set126_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(219, 30);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:219:9: ( INT | FLOAT | STRING )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(219, 9);

			set126=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set126));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("constant", 27);
			LeaveRule("constant", 27);
			LeaveRule_constant();
		}
		DebugLocation(219, 30);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:1: atom : ( constant | ID | T | F );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 28);
		TraceIn("atom", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID128 = default(IToken);
		IToken T129 = default(IToken);
		IToken F130 = default(IToken);
		AstParserRuleReturnScope<object, IToken> constant127 = default(AstParserRuleReturnScope<object, IToken>);

		object ID128_tree = default(object);
		object T129_tree = default(object);
		object F130_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(221, 28);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:6: ( constant | ID | T | F )
			int alt27=4;
			try { DebugEnterDecision(27, false);
			switch (input.LA(1))
			{
			case FLOAT:
			case INT:
			case STRING:
				{
				alt27 = 1;
				}
				break;
			case ID:
				{
				alt27 = 2;
				}
				break;
			case T:
				{
				alt27 = 3;
				}
				break;
			case F:
				{
				alt27 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:8: constant
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 8);
				PushFollow(Follow._constant_in_atom1453);
				constant127=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant127.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:19: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 19);
				ID128=(IToken)Match(input,ID,Follow._ID_in_atom1457); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID128_tree = (object)adaptor.Create(ID128);
				adaptor.AddChild(root_0, ID128_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:24: T
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 24);
				T129=(IToken)Match(input,T,Follow._T_in_atom1461); if (state.failed) return retval;
				if (state.backtracking == 0) {
				T129_tree = (object)adaptor.Create(T129);
				adaptor.AddChild(root_0, T129_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:221:28: F
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(221, 28);
				F130=(IToken)Match(input,F,Follow._F_in_atom1465); if (state.failed) return retval;
				if (state.backtracking == 0) {
				F130_tree = (object)adaptor.Create(F130);
				adaptor.AddChild(root_0, F130_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("atom", 28);
			LeaveRule("atom", 28);
			LeaveRule_atom();
		}
		DebugLocation(221, 28);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_index();
	partial void LeaveRule_index();

	// $ANTLR start "index"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:223:1: index : ( INT | ID );
	[GrammarRule("index")]
	private AstParserRuleReturnScope<object, IToken> index()
	{
		EnterRule_index();
		EnterRule("index", 29);
		TraceIn("index", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set131 = default(IToken);

		object set131_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "index");
		DebugLocation(223, 16);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:223:7: ( INT | ID )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(223, 7);

			set131=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set131));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("index", 29);
			LeaveRule("index", 29);
			LeaveRule_index();
		}
		DebugLocation(223, 16);
		} finally { DebugExitRule(GrammarFileName, "index"); }
		return retval;

	}
	// $ANTLR end "index"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:225:1: number : ( INT | FLOAT );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<object, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 30);
		TraceIn("number", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set132 = default(IToken);

		object set132_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(225, 20);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:225:8: ( INT | FLOAT )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(225, 8);

			set132=(IToken)input.LT(1);
			if (input.LA(1)==FLOAT||input.LA(1)==INT)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set132));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

			catch (RecognitionException e) {
				throw new Exception(GetErrorMessage(e));
			}

		finally
		{
			TraceOut("number", 30);
			LeaveRule("number", 30);
			LeaveRule_number();
		}
		DebugLocation(225, 20);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_synpred25_NPortugol_fragment();
	partial void LeaveRule_synpred25_NPortugol_fragment();

	// $ANTLR start synpred25_NPortugol
	public void synpred25_NPortugol_fragment()
	{
		EnterRule_synpred25_NPortugol_fragment();
		EnterRule("synpred25_NPortugol_fragment", 55);
		TraceIn("synpred25_NPortugol_fragment", 55);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: ( function_arg_list )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:149:11: function_arg_list
			{
			DebugLocation(149, 11);
			PushFollow(Follow._function_arg_list_in_synpred25_NPortugol800);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_NPortugol_fragment", 55);
			LeaveRule("synpred25_NPortugol_fragment", 55);
			LeaveRule_synpred25_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred25_NPortugol

	partial void EnterRule_synpred26_NPortugol_fragment();
	partial void LeaveRule_synpred26_NPortugol_fragment();

	// $ANTLR start synpred26_NPortugol
	public void synpred26_NPortugol_fragment()
	{
		EnterRule_synpred26_NPortugol_fragment();
		EnterRule("synpred26_NPortugol_fragment", 56);
		TraceIn("synpred26_NPortugol_fragment", 56);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: ( function_arg_list )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:157:20: function_arg_list
			{
			DebugLocation(157, 20);
			PushFollow(Follow._function_arg_list_in_synpred26_NPortugol900);
			function_arg_list();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_NPortugol_fragment", 56);
			LeaveRule("synpred26_NPortugol_fragment", 56);
			LeaveRule_synpred26_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred26_NPortugol

	partial void EnterRule_synpred28_NPortugol_fragment();
	partial void LeaveRule_synpred28_NPortugol_fragment();

	// $ANTLR start synpred28_NPortugol
	public void synpred28_NPortugol_fragment()
	{
		EnterRule_synpred28_NPortugol_fragment();
		EnterRule("synpred28_NPortugol_fragment", 58);
		TraceIn("synpred28_NPortugol_fragment", 58);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:9: ( ID '=' '[' INT '..' INT ']' )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:167:9: ID '=' '[' INT '..' INT ']'
			{
			DebugLocation(167, 9);
			Match(input,ID,Follow._ID_in_synpred28_NPortugol1005); if (state.failed) return;
			DebugLocation(167, 12);
			Match(input,57,Follow._57_in_synpred28_NPortugol1007); if (state.failed) return;
			DebugLocation(167, 16);
			Match(input,61,Follow._61_in_synpred28_NPortugol1009); if (state.failed) return;
			DebugLocation(167, 20);
			Match(input,INT,Follow._INT_in_synpred28_NPortugol1011); if (state.failed) return;
			DebugLocation(167, 24);
			Match(input,51,Follow._51_in_synpred28_NPortugol1013); if (state.failed) return;
			DebugLocation(167, 29);
			Match(input,INT,Follow._INT_in_synpred28_NPortugol1015); if (state.failed) return;
			DebugLocation(167, 33);
			Match(input,62,Follow._62_in_synpred28_NPortugol1017); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred28_NPortugol_fragment", 58);
			LeaveRule("synpred28_NPortugol_fragment", 58);
			LeaveRule_synpred28_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred28_NPortugol

	partial void EnterRule_synpred30_NPortugol_fragment();
	partial void LeaveRule_synpred30_NPortugol_fragment();

	// $ANTLR start synpred30_NPortugol
	public void synpred30_NPortugol_fragment()
	{
		EnterRule_synpred30_NPortugol_fragment();
		EnterRule("synpred30_NPortugol_fragment", 60);
		TraceIn("synpred30_NPortugol_fragment", 60);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:10: ( ID '=' '{' INT ( ';' INT )* '}' )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:10: ID '=' '{' INT ( ';' INT )* '}'
			{
			DebugLocation(168, 10);
			Match(input,ID,Follow._ID_in_synpred30_NPortugol1040); if (state.failed) return;
			DebugLocation(168, 13);
			Match(input,57,Follow._57_in_synpred30_NPortugol1042); if (state.failed) return;
			DebugLocation(168, 17);
			Match(input,79,Follow._79_in_synpred30_NPortugol1044); if (state.failed) return;
			DebugLocation(168, 21);
			Match(input,INT,Follow._INT_in_synpred30_NPortugol1046); if (state.failed) return;
			DebugLocation(168, 25);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:25: ( ';' INT )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==54))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:168:26: ';' INT
					{
					DebugLocation(168, 26);
					Match(input,54,Follow._54_in_synpred30_NPortugol1049); if (state.failed) return;
					DebugLocation(168, 30);
					Match(input,INT,Follow._INT_in_synpred30_NPortugol1051); if (state.failed) return;

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }

			DebugLocation(168, 36);
			Match(input,80,Follow._80_in_synpred30_NPortugol1055); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred30_NPortugol_fragment", 60);
			LeaveRule("synpred30_NPortugol_fragment", 60);
			LeaveRule_synpred30_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred30_NPortugol

	partial void EnterRule_synpred46_NPortugol_fragment();
	partial void LeaveRule_synpred46_NPortugol_fragment();

	// $ANTLR start synpred46_NPortugol
	public void synpred46_NPortugol_fragment()
	{
		EnterRule_synpred46_NPortugol_fragment();
		EnterRule("synpred46_NPortugol_fragment", 76);
		TraceIn("synpred46_NPortugol_fragment", 76);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: ({...}? => function_call )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:205:4: {...}? => function_call
			{
			DebugLocation(205, 4);
			if (!(( (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text =="(" )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred46_NPortugol", " (!IsDefinedID(input.LT(1).Text)) && input.LT(2).Text ==\"(\" ");
			}
			DebugLocation(205, 71);
			PushFollow(Follow._function_call_in_synpred46_NPortugol1346);
			function_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred46_NPortugol_fragment", 76);
			LeaveRule("synpred46_NPortugol_fragment", 76);
			LeaveRule_synpred46_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred46_NPortugol

	partial void EnterRule_synpred47_NPortugol_fragment();
	partial void LeaveRule_synpred47_NPortugol_fragment();

	// $ANTLR start synpred47_NPortugol
	public void synpred47_NPortugol_fragment()
	{
		EnterRule_synpred47_NPortugol_fragment();
		EnterRule("synpred47_NPortugol_fragment", 77);
		TraceIn("synpred47_NPortugol_fragment", 77);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: ( ID )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:206:4: ID
			{
			DebugLocation(206, 4);
			Match(input,ID,Follow._ID_in_synpred47_NPortugol1351); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred47_NPortugol_fragment", 77);
			LeaveRule("synpred47_NPortugol_fragment", 77);
			LeaveRule_synpred47_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred47_NPortugol

	partial void EnterRule_synpred51_NPortugol_fragment();
	partial void LeaveRule_synpred51_NPortugol_fragment();

	// $ANTLR start synpred51_NPortugol
	public void synpred51_NPortugol_fragment()
	{
		EnterRule_synpred51_NPortugol_fragment();
		EnterRule("synpred51_NPortugol_fragment", 81);
		TraceIn("synpred51_NPortugol_fragment", 81);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:210:4: ( method_call )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:210:4: method_call
			{
			DebugLocation(210, 4);
			PushFollow(Follow._method_call_in_synpred51_NPortugol1387);
			method_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred51_NPortugol_fragment", 81);
			LeaveRule("synpred51_NPortugol_fragment", 81);
			LeaveRule_synpred51_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred51_NPortugol

	partial void EnterRule_synpred52_NPortugol_fragment();
	partial void LeaveRule_synpred52_NPortugol_fragment();

	// $ANTLR start synpred52_NPortugol
	public void synpred52_NPortugol_fragment()
	{
		EnterRule_synpred52_NPortugol_fragment();
		EnterRule("synpred52_NPortugol_fragment", 82);
		TraceIn("synpred52_NPortugol_fragment", 82);
		try
		{
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:211:4: ( property_call )
			DebugEnterAlt(1);
			// C:\\Git\\NPortugol\\src\\grammar\\NPortugol.g:211:4: property_call
			{
			DebugLocation(211, 4);
			PushFollow(Follow._property_call_in_synpred52_NPortugol1393);
			property_call();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred52_NPortugol_fragment", 82);
			LeaveRule("synpred52_NPortugol_fragment", 82);
			LeaveRule_synpred52_NPortugol_fragment();
		}
	}
	// $ANTLR end synpred52_NPortugol
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declare_function_in_script156 = new BitSet(new ulong[]{0x2UL,0x40UL});
		public static readonly BitSet _70_in_declare_function167 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_declare_function171 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _44_in_declare_function173 = new BitSet(new ulong[]{0x200000080000UL});
		public static readonly BitSet _function_param_list_in_declare_function175 = new BitSet(new ulong[]{0x200000080000UL});
		public static readonly BitSet _45_in_declare_function178 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _statement_in_declare_function180 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _69_in_declare_function183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declare_local_in_statement230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stat_in_statement236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_stat_in_statement242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_statement247 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _repeat_stat_in_statement252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _select_stat_in_statement258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_statement263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_var_in_statement269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_stat_in_statement275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _asm_code_in_statement280 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_param_list308 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _48_in_function_param_list311 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_function_param_list313 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _78_in_declare_local359 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_declare_local363 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _48_in_declare_local366 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_declare_local370 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _75_in_if_stat413 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _logic_expression_in_if_stat417 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _68_in_if_stat419 = new BitSet(new ulong[]{0x40000080000UL,0x7F28UL});
		public static readonly BitSet _statement_in_if_stat423 = new BitSet(new ulong[]{0x40000080000UL,0x7F28UL});
		public static readonly BitSet _senao_stat_in_if_stat431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _69_in_if_stat459 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _77_in_senao_stat495 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _statement_in_senao_stat499 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _69_in_senao_stat502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _72_in_for_stat522 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _assign_var_in_for_stat524 = new BitSet(new ulong[]{0x8000000000000000UL});
		public static readonly BitSet _63_in_for_stat526 = new BitSet(new ulong[]{0x880000UL});
		public static readonly BitSet _index_in_for_stat528 = new BitSet(new ulong[]{0x40000080000UL,0x5F2AUL});
		public static readonly BitSet _65_in_for_stat536 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _statement_in_for_stat538 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _69_in_for_stat541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_for_stat566 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _69_in_for_stat569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _67_in_while_stat602 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _logic_expression_in_while_stat604 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _statement_in_while_stat606 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _69_in_while_stat609 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _73_in_repeat_stat640 = new BitSet(new ulong[]{0x8000040000080000UL,0x5F08UL});
		public static readonly BitSet _statement_in_repeat_stat642 = new BitSet(new ulong[]{0x8000040000080000UL,0x5F08UL});
		public static readonly BitSet _63_in_repeat_stat645 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _logic_expression_in_repeat_stat647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _76_in_select_stat680 = new BitSet(new ulong[]{0x3000898000UL});
		public static readonly BitSet _atom_in_select_stat682 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _select_case_in_select_stat698 = new BitSet(new ulong[]{0x0UL,0x21UL});
		public static readonly BitSet _69_in_select_stat710 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _64_in_select_case749 = new BitSet(new ulong[]{0x3000898000UL});
		public static readonly BitSet _atom_in_select_case751 = new BitSet(new ulong[]{0x20000000000000UL});
		public static readonly BitSet _53_in_select_case753 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _statement_in_select_case755 = new BitSet(new ulong[]{0x40000080000UL,0x5F28UL});
		public static readonly BitSet _69_in_select_case758 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_function_call796 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _44_in_function_call798 = new BitSet(new ulong[]{0x303000898000UL});
		public static readonly BitSet _function_arg_list_in_function_call800 = new BitSet(new ulong[]{0x303000898000UL});
		public static readonly BitSet _45_in_function_call803 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_property_call844 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _50_in_property_call845 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_property_call848 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_method_call892 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _50_in_method_call893 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ID_in_method_call896 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _44_in_method_call898 = new BitSet(new ulong[]{0x303000898000UL});
		public static readonly BitSet _function_arg_list_in_method_call900 = new BitSet(new ulong[]{0x303000898000UL});
		public static readonly BitSet _45_in_method_call903 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_function_arg_list948 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _48_in_function_arg_list951 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _plus_expression_in_function_arg_list953 = new BitSet(new ulong[]{0x1000000000002UL});
		public static readonly BitSet _ID_in_assign_var1005 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var1007 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_assign_var1009 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_assign_var1011 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_assign_var1013 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_assign_var1015 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_assign_var1017 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1040 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var1042 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _79_in_assign_var1044 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_assign_var1046 = new BitSet(new ulong[]{0x40000000000000UL,0x10000UL});
		public static readonly BitSet _54_in_assign_var1049 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_assign_var1051 = new BitSet(new ulong[]{0x40000000000000UL,0x10000UL});
		public static readonly BitSet _80_in_assign_var1055 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1075 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_assign_var1077 = new BitSet(new ulong[]{0x880000UL});
		public static readonly BitSet _index_in_assign_var1079 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_assign_var1081 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var1083 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _assign_expression_in_assign_var1085 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_var1114 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_assign_var1116 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _assign_expression_in_assign_var1118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _74_in_return_stat1141 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _assign_expression_in_return_stat1143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _42_in_asm_code1162 = new BitSet(new ulong[]{0x41000000000UL});
		public static readonly BitSet _STRING_in_asm_code1164 = new BitSet(new ulong[]{0x41000000000UL});
		public static readonly BitSet _42_in_asm_code1167 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _plus_expression_in_logic_expression1199 = new BitSet(new ulong[]{0x1D80020000000002UL,0x84UL});
		public static readonly BitSet _binop_in_logic_expression1203 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _plus_expression_in_logic_expression1206 = new BitSet(new ulong[]{0x1D80020000000002UL,0x84UL});
		public static readonly BitSet _plus_expression_in_assign_expression1267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mul_expression_in_plus_expression1277 = new BitSet(new ulong[]{0x2800000000002UL});
		public static readonly BitSet _47_in_plus_expression1281 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1284 = new BitSet(new ulong[]{0x2800000000002UL});
		public static readonly BitSet _49_in_plus_expression1288 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _mul_expression_in_plus_expression1291 = new BitSet(new ulong[]{0x2800000000002UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1306 = new BitSet(new ulong[]{0x10480000000002UL});
		public static readonly BitSet _52_in_mul_expression1311 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1314 = new BitSet(new ulong[]{0x10480000000002UL});
		public static readonly BitSet _43_in_mul_expression1318 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1321 = new BitSet(new ulong[]{0x10480000000002UL});
		public static readonly BitSet _46_in_mul_expression1325 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _primary_ar_expression_in_mul_expression1328 = new BitSet(new ulong[]{0x10480000000002UL});
		public static readonly BitSet _function_call_in_primary_ar_expression1346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1351 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _T_in_primary_ar_expression1356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_primary_ar_expression1361 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_primary_ar_expression1366 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_primary_ar_expression1368 = new BitSet(new ulong[]{0x880000UL});
		public static readonly BitSet _index_in_primary_ar_expression1370 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_primary_ar_expression1372 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_primary_ar_expression1387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_primary_ar_expression1393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primary_ar_expression1398 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesisExpression_in_primary_ar_expression1403 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _44_in_parenthesisExpression1418 = new BitSet(new ulong[]{0x103000898000UL});
		public static readonly BitSet _plus_expression_in_parenthesisExpression1420 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _45_in_parenthesisExpression1422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_atom1453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_atom1457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _T_in_atom1461 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _F_in_atom1465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred25_NPortugol800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_arg_list_in_synpred26_NPortugol900 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred28_NPortugol1005 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred28_NPortugol1007 = new BitSet(new ulong[]{0x2000000000000000UL});
		public static readonly BitSet _61_in_synpred28_NPortugol1009 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol1011 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _51_in_synpred28_NPortugol1013 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred28_NPortugol1015 = new BitSet(new ulong[]{0x4000000000000000UL});
		public static readonly BitSet _62_in_synpred28_NPortugol1017 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred30_NPortugol1040 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _57_in_synpred30_NPortugol1042 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _79_in_synpred30_NPortugol1044 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred30_NPortugol1046 = new BitSet(new ulong[]{0x40000000000000UL,0x10000UL});
		public static readonly BitSet _54_in_synpred30_NPortugol1049 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _INT_in_synpred30_NPortugol1051 = new BitSet(new ulong[]{0x40000000000000UL,0x10000UL});
		public static readonly BitSet _80_in_synpred30_NPortugol1055 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_call_in_synpred46_NPortugol1346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred47_NPortugol1351 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_call_in_synpred51_NPortugol1387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_call_in_synpred52_NPortugol1393 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace NPortugol
